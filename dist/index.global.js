var PiniaHistory = (() => {
  var JA = Object.create
  var Nu = Object.defineProperty
  var YA = Object.getOwnPropertyDescriptor
  var QA = Object.getOwnPropertyNames
  var ZA = Object.getPrototypeOf,
    eP = Object.prototype.hasOwnProperty
  var Kf = (t) => Nu(t, '__esModule', { value: !0 })
  var ig = ((t) =>
    typeof require != 'undefined'
      ? require
      : typeof Proxy != 'undefined'
      ? new Proxy(t, {
          get: (e, s) => (typeof require != 'undefined' ? require : e)[s],
        })
      : t)(function (t) {
    if (typeof require != 'undefined') return require.apply(this, arguments)
    throw new Error('Dynamic require of "' + t + '" is not supported')
  })
  var Oe = (t, e) => () => (
      e || t((e = { exports: {} }).exports, e), e.exports
    ),
    tP = (t, e) => {
      Kf(t)
      for (var s in e) Nu(t, s, { get: e[s], enumerable: !0 })
    },
    Xf = (t, e, s) => {
      if ((e && typeof e == 'object') || typeof e == 'function')
        for (let i of QA(e))
          !eP.call(t, i) &&
            i !== 'default' &&
            Nu(t, i, {
              get: () => e[i],
              enumerable: !(s = YA(e, i)) || s.enumerable,
            })
      return t
    },
    Gf = (t) =>
      Xf(
        Kf(
          Nu(
            t != null ? JA(ZA(t)) : {},
            'default',
            t && t.__esModule && 'default' in t
              ? { get: () => t.default, enumerable: !0 }
              : { value: t, enumerable: !0 }
          )
        ),
        t
      )
  var yg = Oe((ce) => {
    'use strict'
    Object.defineProperty(ce, '__esModule', { value: !0 })
    function Ps(t, e) {
      let s = new Set(t.split(','))
      return e ? (i) => s.has(i.toLowerCase()) : (i) => s.has(i)
    }
    var sP = {},
      iP = [],
      rP = () => {},
      nP = () => !1,
      aP = (t) =>
        t.charCodeAt(0) === 111 &&
        t.charCodeAt(1) === 110 &&
        (t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97),
      oP = (t) => t.startsWith('onUpdate:'),
      uP = Object.assign,
      lP = (t, e) => {
        let s = t.indexOf(e)
        s > -1 && t.splice(s, 1)
      },
      cP = Object.prototype.hasOwnProperty,
      fP = (t, e) => cP.call(t, e),
      Fr = Array.isArray,
      rg = (t) => Br(t) === '[object Map]',
      ng = (t) => Br(t) === '[object Set]',
      Wf = (t) => Br(t) === '[object Date]',
      hP = (t) => Br(t) === '[object RegExp]',
      Ia = (t) => typeof t == 'function',
      Js = (t) => typeof t == 'string',
      Oa = (t) => typeof t == 'symbol',
      zi = (t) => t !== null && typeof t == 'object',
      pP = (t) => (zi(t) || Ia(t)) && Ia(t.then) && Ia(t.catch),
      zf = Object.prototype.toString,
      Br = (t) => zf.call(t),
      dP = (t) => Br(t).slice(8, -1),
      ag = (t) => Br(t) === '[object Object]',
      mP = (t) =>
        Js(t) && t !== 'NaN' && t[0] !== '-' && '' + parseInt(t, 10) === t,
      gP = Ps(
        ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
      ),
      yP = Ps(
        'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'
      ),
      Iu = (t) => {
        let e = Object.create(null)
        return (s) => e[s] || (e[s] = t(s))
      },
      bP = /-(\w)/g,
      EP = Iu((t) => t.replace(bP, (e, s) => (s ? s.toUpperCase() : ''))),
      SP = /\B([A-Z])/g,
      og = Iu((t) => t.replace(SP, '-$1').toLowerCase()),
      ug = Iu((t) => t.charAt(0).toUpperCase() + t.slice(1)),
      TP = Iu((t) => (t ? `on${ug(t)}` : '')),
      _P = (t, e) => !Object.is(t, e),
      xP = (t, ...e) => {
        for (let s = 0; s < t.length; s++) t[s](...e)
      },
      AP = (t, e, s, i = !1) => {
        Object.defineProperty(t, e, {
          configurable: !0,
          enumerable: !1,
          writable: i,
          value: s,
        })
      },
      PP = (t) => {
        let e = parseFloat(t)
        return isNaN(e) ? t : e
      },
      CP = (t) => {
        let e = Js(t) ? Number(t) : NaN
        return isNaN(e) ? t : e
      },
      lg,
      vP = () =>
        lg ||
        (lg =
          typeof globalThis != 'undefined'
            ? globalThis
            : typeof self != 'undefined'
            ? self
            : typeof window != 'undefined'
            ? window
            : typeof global != 'undefined'
            ? global
            : {}),
      NP = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/
    function IP(t) {
      return NP.test(t) ? `__props.${t}` : `__props[${JSON.stringify(t)}]`
    }
    var OP = {
        TEXT: 1,
        1: 'TEXT',
        CLASS: 2,
        2: 'CLASS',
        STYLE: 4,
        4: 'STYLE',
        PROPS: 8,
        8: 'PROPS',
        FULL_PROPS: 16,
        16: 'FULL_PROPS',
        NEED_HYDRATION: 32,
        32: 'NEED_HYDRATION',
        STABLE_FRAGMENT: 64,
        64: 'STABLE_FRAGMENT',
        KEYED_FRAGMENT: 128,
        128: 'KEYED_FRAGMENT',
        UNKEYED_FRAGMENT: 256,
        256: 'UNKEYED_FRAGMENT',
        NEED_PATCH: 512,
        512: 'NEED_PATCH',
        DYNAMIC_SLOTS: 1024,
        1024: 'DYNAMIC_SLOTS',
        DEV_ROOT_FRAGMENT: 2048,
        2048: 'DEV_ROOT_FRAGMENT',
        HOISTED: -1,
        '-1': 'HOISTED',
        BAIL: -2,
        '-2': 'BAIL',
      },
      wP = {
        [1]: 'TEXT',
        [2]: 'CLASS',
        [4]: 'STYLE',
        [8]: 'PROPS',
        [16]: 'FULL_PROPS',
        [32]: 'NEED_HYDRATION',
        [64]: 'STABLE_FRAGMENT',
        [128]: 'KEYED_FRAGMENT',
        [256]: 'UNKEYED_FRAGMENT',
        [512]: 'NEED_PATCH',
        [1024]: 'DYNAMIC_SLOTS',
        [2048]: 'DEV_ROOT_FRAGMENT',
        [-1]: 'HOISTED',
        [-2]: 'BAIL',
      },
      MP = {
        ELEMENT: 1,
        1: 'ELEMENT',
        FUNCTIONAL_COMPONENT: 2,
        2: 'FUNCTIONAL_COMPONENT',
        STATEFUL_COMPONENT: 4,
        4: 'STATEFUL_COMPONENT',
        TEXT_CHILDREN: 8,
        8: 'TEXT_CHILDREN',
        ARRAY_CHILDREN: 16,
        16: 'ARRAY_CHILDREN',
        SLOTS_CHILDREN: 32,
        32: 'SLOTS_CHILDREN',
        TELEPORT: 64,
        64: 'TELEPORT',
        SUSPENSE: 128,
        128: 'SUSPENSE',
        COMPONENT_SHOULD_KEEP_ALIVE: 256,
        256: 'COMPONENT_SHOULD_KEEP_ALIVE',
        COMPONENT_KEPT_ALIVE: 512,
        512: 'COMPONENT_KEPT_ALIVE',
        COMPONENT: 6,
        6: 'COMPONENT',
      },
      RP = {
        STABLE: 1,
        1: 'STABLE',
        DYNAMIC: 2,
        2: 'DYNAMIC',
        FORWARDED: 3,
        3: 'FORWARDED',
      },
      LP = { [1]: 'STABLE', [2]: 'DYNAMIC', [3]: 'FORWARDED' },
      kP =
        'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error',
      cg = Ps(kP),
      DP = cg,
      fg = 2
    function FP(t, e = 0, s = t.length) {
      if (
        ((e = Math.max(0, Math.min(e, t.length))),
        (s = Math.max(0, Math.min(s, t.length))),
        e > s)
      )
        return ''
      let i = t.split(/(\r?\n)/),
        r = i.filter((o, u) => u % 2 == 1)
      i = i.filter((o, u) => u % 2 == 0)
      let n = 0,
        a = []
      for (let o = 0; o < i.length; o++)
        if (((n += i[o].length + ((r[o] && r[o].length) || 0)), n >= e)) {
          for (let u = o - fg; u <= o + fg || s > n; u++) {
            if (u < 0 || u >= i.length) continue
            let l = u + 1
            a.push(
              `${l}${' '.repeat(Math.max(3 - String(l).length, 0))}|  ${i[u]}`
            )
            let c = i[u].length,
              f = (r[u] && r[u].length) || 0
            if (u === o) {
              let h = e - (n - (c + f)),
                p = Math.max(1, s > n ? c - h : s - e)
              a.push('   |  ' + ' '.repeat(h) + '^'.repeat(p))
            } else if (u > o) {
              if (s > n) {
                let h = Math.max(Math.min(s - n, c), 1)
                a.push('   |  ' + '^'.repeat(h))
              }
              n += c + f
            }
          }
          break
        }
      return a.join(`
`)
    }
    function Jf(t) {
      if (Fr(t)) {
        let e = {}
        for (let s = 0; s < t.length; s++) {
          let i = t[s],
            r = Js(i) ? hg(i) : Jf(i)
          if (r) for (let n in r) e[n] = r[n]
        }
        return e
      } else if (Js(t) || zi(t)) return t
    }
    var BP = /;(?![^(]*\))/g,
      VP = /:([^]+)/,
      UP = /\/\*[^]*?\*\//g
    function hg(t) {
      let e = {}
      return (
        t
          .replace(UP, '')
          .split(BP)
          .forEach((s) => {
            if (s) {
              let i = s.split(VP)
              i.length > 1 && (e[i[0].trim()] = i[1].trim())
            }
          }),
        e
      )
    }
    function HP(t) {
      let e = ''
      if (!t || Js(t)) return e
      for (let s in t) {
        let i = t[s]
        ;(Js(i) || typeof i == 'number') &&
          (e += `${s.startsWith('--') ? s : og(s)}:${i};`)
      }
      return e
    }
    function Yf(t) {
      let e = ''
      if (Js(t)) e = t
      else if (Fr(t))
        for (let s = 0; s < t.length; s++) {
          let i = Yf(t[s])
          i && (e += i + ' ')
        }
      else if (zi(t)) for (let s in t) t[s] && (e += s + ' ')
      return e.trim()
    }
    function $P(t) {
      if (!t) return null
      let { class: e, style: s } = t
      return e && !Js(e) && (t.class = Yf(e)), s && (t.style = Jf(s)), t
    }
    var jP =
        'html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot',
      qP =
        'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view',
      KP =
        'annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics',
      XP =
        'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr',
      GP = Ps(jP),
      WP = Ps(qP),
      zP = Ps(KP),
      JP = Ps(XP),
      pg =
        'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
      YP = Ps(pg),
      QP = Ps(
        pg +
          ',async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected'
      )
    function ZP(t) {
      return !!t || t === ''
    }
    var e3 = /[>/="'\u0009\u000a\u000c\u0020]/,
      Qf = {}
    function t3(t) {
      if (Qf.hasOwnProperty(t)) return Qf[t]
      let e = e3.test(t)
      return e && console.error(`unsafe attribute name: ${t}`), (Qf[t] = !e)
    }
    var s3 = {
        acceptCharset: 'accept-charset',
        className: 'class',
        htmlFor: 'for',
        httpEquiv: 'http-equiv',
      },
      i3 = Ps(
        'accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap'
      ),
      r3 = Ps(
        'xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan'
      )
    function n3(t) {
      if (t == null) return !1
      let e = typeof t
      return e === 'string' || e === 'number' || e === 'boolean'
    }
    var a3 = /["'&<>]/
    function o3(t) {
      let e = '' + t,
        s = a3.exec(e)
      if (!s) return e
      let i = '',
        r,
        n,
        a = 0
      for (n = s.index; n < e.length; n++) {
        switch (e.charCodeAt(n)) {
          case 34:
            r = '&quot;'
            break
          case 38:
            r = '&amp;'
            break
          case 39:
            r = '&#39;'
            break
          case 60:
            r = '&lt;'
            break
          case 62:
            r = '&gt;'
            break
          default:
            continue
        }
        a !== n && (i += e.slice(a, n)), (a = n + 1), (i += r)
      }
      return a !== n ? i + e.slice(a, n) : i
    }
    var u3 = /^-?>|<!--|-->|--!>|<!-$/g
    function l3(t) {
      return t.replace(u3, '')
    }
    function c3(t, e) {
      if (t.length !== e.length) return !1
      let s = !0
      for (let i = 0; s && i < t.length; i++) s = Ou(t[i], e[i])
      return s
    }
    function Ou(t, e) {
      if (t === e) return !0
      let s = Wf(t),
        i = Wf(e)
      if (s || i) return s && i ? t.getTime() === e.getTime() : !1
      if (((s = Oa(t)), (i = Oa(e)), s || i)) return t === e
      if (((s = Fr(t)), (i = Fr(e)), s || i)) return s && i ? c3(t, e) : !1
      if (((s = zi(t)), (i = zi(e)), s || i)) {
        if (!s || !i) return !1
        let r = Object.keys(t).length,
          n = Object.keys(e).length
        if (r !== n) return !1
        for (let a in t) {
          let o = t.hasOwnProperty(a),
            u = e.hasOwnProperty(a)
          if ((o && !u) || (!o && u) || !Ou(t[a], e[a])) return !1
        }
      }
      return String(t) === String(e)
    }
    function f3(t, e) {
      return t.findIndex((s) => Ou(s, e))
    }
    var dg = (t) => !!(t && t.__v_isRef === !0),
      mg = (t) =>
        Js(t)
          ? t
          : t == null
          ? ''
          : Fr(t) || (zi(t) && (t.toString === zf || !Ia(t.toString)))
          ? dg(t)
            ? mg(t.value)
            : JSON.stringify(t, gg, 2)
          : String(t),
      gg = (t, e) =>
        dg(e)
          ? gg(t, e.value)
          : rg(e)
          ? {
              [`Map(${e.size})`]: [...e.entries()].reduce(
                (s, [i, r], n) => ((s[Zf(i, n) + ' =>'] = r), s),
                {}
              ),
            }
          : ng(e)
          ? { [`Set(${e.size})`]: [...e.values()].map((s) => Zf(s)) }
          : Oa(e)
          ? Zf(e)
          : zi(e) && !Fr(e) && !ag(e)
          ? String(e)
          : e,
      Zf = (t, e = '') => {
        var s
        return Oa(t) ? `Symbol(${(s = t.description) != null ? s : e})` : t
      }
    ce.EMPTY_ARR = iP
    ce.EMPTY_OBJ = sP
    ce.NO = nP
    ce.NOOP = rP
    ce.PatchFlagNames = wP
    ce.PatchFlags = OP
    ce.ShapeFlags = MP
    ce.SlotFlags = RP
    ce.camelize = EP
    ce.capitalize = ug
    ce.def = AP
    ce.escapeHtml = o3
    ce.escapeHtmlComment = l3
    ce.extend = uP
    ce.genPropsAccessExp = IP
    ce.generateCodeFrame = FP
    ce.getGlobalThis = vP
    ce.hasChanged = _P
    ce.hasOwn = fP
    ce.hyphenate = og
    ce.includeBooleanAttr = ZP
    ce.invokeArrayFns = xP
    ce.isArray = Fr
    ce.isBooleanAttr = QP
    ce.isBuiltInDirective = yP
    ce.isDate = Wf
    ce.isFunction = Ia
    ce.isGloballyAllowed = cg
    ce.isGloballyWhitelisted = DP
    ce.isHTMLTag = GP
    ce.isIntegerKey = mP
    ce.isKnownHtmlAttr = i3
    ce.isKnownSvgAttr = r3
    ce.isMap = rg
    ce.isMathMLTag = zP
    ce.isModelListener = oP
    ce.isObject = zi
    ce.isOn = aP
    ce.isPlainObject = ag
    ce.isPromise = pP
    ce.isRegExp = hP
    ce.isRenderableAttrValue = n3
    ce.isReservedProp = gP
    ce.isSSRSafeAttrName = t3
    ce.isSVGTag = WP
    ce.isSet = ng
    ce.isSpecialBooleanAttr = YP
    ce.isString = Js
    ce.isSymbol = Oa
    ce.isVoidTag = JP
    ce.looseEqual = Ou
    ce.looseIndexOf = f3
    ce.looseToNumber = PP
    ce.makeMap = Ps
    ce.normalizeClass = Yf
    ce.normalizeProps = $P
    ce.normalizeStyle = Jf
    ce.objectToString = zf
    ce.parseStringStyle = hg
    ce.propsToAttrMap = s3
    ce.remove = lP
    ce.slotFlagsText = LP
    ce.stringifyStyle = HP
    ce.toDisplayString = mg
    ce.toHandlerKey = TP
    ce.toNumber = CP
    ce.toRawType = dP
    ce.toTypeString = Br
  })
  var wg = Oe((fe) => {
    'use strict'
    Object.defineProperty(fe, '__esModule', { value: !0 })
    function Cs(t, e) {
      let s = new Set(t.split(','))
      return e ? (i) => s.has(i.toLowerCase()) : (i) => s.has(i)
    }
    var h3 = Object.freeze({}),
      p3 = Object.freeze([]),
      d3 = () => {},
      m3 = () => !1,
      g3 = (t) =>
        t.charCodeAt(0) === 111 &&
        t.charCodeAt(1) === 110 &&
        (t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97),
      y3 = (t) => t.startsWith('onUpdate:'),
      b3 = Object.assign,
      E3 = (t, e) => {
        let s = t.indexOf(e)
        s > -1 && t.splice(s, 1)
      },
      S3 = Object.prototype.hasOwnProperty,
      T3 = (t, e) => S3.call(t, e),
      Vr = Array.isArray,
      bg = (t) => Ur(t) === '[object Map]',
      Eg = (t) => Ur(t) === '[object Set]',
      eh = (t) => Ur(t) === '[object Date]',
      _3 = (t) => Ur(t) === '[object RegExp]',
      wa = (t) => typeof t == 'function',
      Ys = (t) => typeof t == 'string',
      Ma = (t) => typeof t == 'symbol',
      Ji = (t) => t !== null && typeof t == 'object',
      x3 = (t) => (Ji(t) || wa(t)) && wa(t.then) && wa(t.catch),
      th = Object.prototype.toString,
      Ur = (t) => th.call(t),
      A3 = (t) => Ur(t).slice(8, -1),
      Sg = (t) => Ur(t) === '[object Object]',
      P3 = (t) =>
        Ys(t) && t !== 'NaN' && t[0] !== '-' && '' + parseInt(t, 10) === t,
      C3 = Cs(
        ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
      ),
      v3 = Cs(
        'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'
      ),
      wu = (t) => {
        let e = Object.create(null)
        return (s) => e[s] || (e[s] = t(s))
      },
      N3 = /-(\w)/g,
      I3 = wu((t) => t.replace(N3, (e, s) => (s ? s.toUpperCase() : ''))),
      O3 = /\B([A-Z])/g,
      Tg = wu((t) => t.replace(O3, '-$1').toLowerCase()),
      _g = wu((t) => t.charAt(0).toUpperCase() + t.slice(1)),
      w3 = wu((t) => (t ? `on${_g(t)}` : '')),
      M3 = (t, e) => !Object.is(t, e),
      R3 = (t, ...e) => {
        for (let s = 0; s < t.length; s++) t[s](...e)
      },
      L3 = (t, e, s, i = !1) => {
        Object.defineProperty(t, e, {
          configurable: !0,
          enumerable: !1,
          writable: i,
          value: s,
        })
      },
      k3 = (t) => {
        let e = parseFloat(t)
        return isNaN(e) ? t : e
      },
      D3 = (t) => {
        let e = Ys(t) ? Number(t) : NaN
        return isNaN(e) ? t : e
      },
      xg,
      F3 = () =>
        xg ||
        (xg =
          typeof globalThis != 'undefined'
            ? globalThis
            : typeof self != 'undefined'
            ? self
            : typeof window != 'undefined'
            ? window
            : typeof global != 'undefined'
            ? global
            : {}),
      B3 = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/
    function V3(t) {
      return B3.test(t) ? `__props.${t}` : `__props[${JSON.stringify(t)}]`
    }
    var U3 = {
        TEXT: 1,
        1: 'TEXT',
        CLASS: 2,
        2: 'CLASS',
        STYLE: 4,
        4: 'STYLE',
        PROPS: 8,
        8: 'PROPS',
        FULL_PROPS: 16,
        16: 'FULL_PROPS',
        NEED_HYDRATION: 32,
        32: 'NEED_HYDRATION',
        STABLE_FRAGMENT: 64,
        64: 'STABLE_FRAGMENT',
        KEYED_FRAGMENT: 128,
        128: 'KEYED_FRAGMENT',
        UNKEYED_FRAGMENT: 256,
        256: 'UNKEYED_FRAGMENT',
        NEED_PATCH: 512,
        512: 'NEED_PATCH',
        DYNAMIC_SLOTS: 1024,
        1024: 'DYNAMIC_SLOTS',
        DEV_ROOT_FRAGMENT: 2048,
        2048: 'DEV_ROOT_FRAGMENT',
        HOISTED: -1,
        '-1': 'HOISTED',
        BAIL: -2,
        '-2': 'BAIL',
      },
      H3 = {
        [1]: 'TEXT',
        [2]: 'CLASS',
        [4]: 'STYLE',
        [8]: 'PROPS',
        [16]: 'FULL_PROPS',
        [32]: 'NEED_HYDRATION',
        [64]: 'STABLE_FRAGMENT',
        [128]: 'KEYED_FRAGMENT',
        [256]: 'UNKEYED_FRAGMENT',
        [512]: 'NEED_PATCH',
        [1024]: 'DYNAMIC_SLOTS',
        [2048]: 'DEV_ROOT_FRAGMENT',
        [-1]: 'HOISTED',
        [-2]: 'BAIL',
      },
      $3 = {
        ELEMENT: 1,
        1: 'ELEMENT',
        FUNCTIONAL_COMPONENT: 2,
        2: 'FUNCTIONAL_COMPONENT',
        STATEFUL_COMPONENT: 4,
        4: 'STATEFUL_COMPONENT',
        TEXT_CHILDREN: 8,
        8: 'TEXT_CHILDREN',
        ARRAY_CHILDREN: 16,
        16: 'ARRAY_CHILDREN',
        SLOTS_CHILDREN: 32,
        32: 'SLOTS_CHILDREN',
        TELEPORT: 64,
        64: 'TELEPORT',
        SUSPENSE: 128,
        128: 'SUSPENSE',
        COMPONENT_SHOULD_KEEP_ALIVE: 256,
        256: 'COMPONENT_SHOULD_KEEP_ALIVE',
        COMPONENT_KEPT_ALIVE: 512,
        512: 'COMPONENT_KEPT_ALIVE',
        COMPONENT: 6,
        6: 'COMPONENT',
      },
      j3 = {
        STABLE: 1,
        1: 'STABLE',
        DYNAMIC: 2,
        2: 'DYNAMIC',
        FORWARDED: 3,
        3: 'FORWARDED',
      },
      q3 = { [1]: 'STABLE', [2]: 'DYNAMIC', [3]: 'FORWARDED' },
      K3 =
        'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error',
      Ag = Cs(K3),
      X3 = Ag,
      Pg = 2
    function G3(t, e = 0, s = t.length) {
      if (
        ((e = Math.max(0, Math.min(e, t.length))),
        (s = Math.max(0, Math.min(s, t.length))),
        e > s)
      )
        return ''
      let i = t.split(/(\r?\n)/),
        r = i.filter((o, u) => u % 2 == 1)
      i = i.filter((o, u) => u % 2 == 0)
      let n = 0,
        a = []
      for (let o = 0; o < i.length; o++)
        if (((n += i[o].length + ((r[o] && r[o].length) || 0)), n >= e)) {
          for (let u = o - Pg; u <= o + Pg || s > n; u++) {
            if (u < 0 || u >= i.length) continue
            let l = u + 1
            a.push(
              `${l}${' '.repeat(Math.max(3 - String(l).length, 0))}|  ${i[u]}`
            )
            let c = i[u].length,
              f = (r[u] && r[u].length) || 0
            if (u === o) {
              let h = e - (n - (c + f)),
                p = Math.max(1, s > n ? c - h : s - e)
              a.push('   |  ' + ' '.repeat(h) + '^'.repeat(p))
            } else if (u > o) {
              if (s > n) {
                let h = Math.max(Math.min(s - n, c), 1)
                a.push('   |  ' + '^'.repeat(h))
              }
              n += c + f
            }
          }
          break
        }
      return a.join(`
`)
    }
    function sh(t) {
      if (Vr(t)) {
        let e = {}
        for (let s = 0; s < t.length; s++) {
          let i = t[s],
            r = Ys(i) ? Cg(i) : sh(i)
          if (r) for (let n in r) e[n] = r[n]
        }
        return e
      } else if (Ys(t) || Ji(t)) return t
    }
    var W3 = /;(?![^(]*\))/g,
      z3 = /:([^]+)/,
      J3 = /\/\*[^]*?\*\//g
    function Cg(t) {
      let e = {}
      return (
        t
          .replace(J3, '')
          .split(W3)
          .forEach((s) => {
            if (s) {
              let i = s.split(z3)
              i.length > 1 && (e[i[0].trim()] = i[1].trim())
            }
          }),
        e
      )
    }
    function Y3(t) {
      let e = ''
      if (!t || Ys(t)) return e
      for (let s in t) {
        let i = t[s]
        ;(Ys(i) || typeof i == 'number') &&
          (e += `${s.startsWith('--') ? s : Tg(s)}:${i};`)
      }
      return e
    }
    function ih(t) {
      let e = ''
      if (Ys(t)) e = t
      else if (Vr(t))
        for (let s = 0; s < t.length; s++) {
          let i = ih(t[s])
          i && (e += i + ' ')
        }
      else if (Ji(t)) for (let s in t) t[s] && (e += s + ' ')
      return e.trim()
    }
    function Q3(t) {
      if (!t) return null
      let { class: e, style: s } = t
      return e && !Ys(e) && (t.class = ih(e)), s && (t.style = sh(s)), t
    }
    var Z3 =
        'html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot',
      eC =
        'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view',
      tC =
        'annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics',
      sC =
        'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr',
      iC = Cs(Z3),
      rC = Cs(eC),
      nC = Cs(tC),
      aC = Cs(sC),
      vg =
        'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
      oC = Cs(vg),
      uC = Cs(
        vg +
          ',async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected'
      )
    function lC(t) {
      return !!t || t === ''
    }
    var cC = /[>/="'\u0009\u000a\u000c\u0020]/,
      rh = {}
    function fC(t) {
      if (rh.hasOwnProperty(t)) return rh[t]
      let e = cC.test(t)
      return e && console.error(`unsafe attribute name: ${t}`), (rh[t] = !e)
    }
    var hC = {
        acceptCharset: 'accept-charset',
        className: 'class',
        htmlFor: 'for',
        httpEquiv: 'http-equiv',
      },
      pC = Cs(
        'accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap'
      ),
      dC = Cs(
        'xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan'
      )
    function mC(t) {
      if (t == null) return !1
      let e = typeof t
      return e === 'string' || e === 'number' || e === 'boolean'
    }
    var gC = /["'&<>]/
    function yC(t) {
      let e = '' + t,
        s = gC.exec(e)
      if (!s) return e
      let i = '',
        r,
        n,
        a = 0
      for (n = s.index; n < e.length; n++) {
        switch (e.charCodeAt(n)) {
          case 34:
            r = '&quot;'
            break
          case 38:
            r = '&amp;'
            break
          case 39:
            r = '&#39;'
            break
          case 60:
            r = '&lt;'
            break
          case 62:
            r = '&gt;'
            break
          default:
            continue
        }
        a !== n && (i += e.slice(a, n)), (a = n + 1), (i += r)
      }
      return a !== n ? i + e.slice(a, n) : i
    }
    var bC = /^-?>|<!--|-->|--!>|<!-$/g
    function EC(t) {
      return t.replace(bC, '')
    }
    function SC(t, e) {
      if (t.length !== e.length) return !1
      let s = !0
      for (let i = 0; s && i < t.length; i++) s = Mu(t[i], e[i])
      return s
    }
    function Mu(t, e) {
      if (t === e) return !0
      let s = eh(t),
        i = eh(e)
      if (s || i) return s && i ? t.getTime() === e.getTime() : !1
      if (((s = Ma(t)), (i = Ma(e)), s || i)) return t === e
      if (((s = Vr(t)), (i = Vr(e)), s || i)) return s && i ? SC(t, e) : !1
      if (((s = Ji(t)), (i = Ji(e)), s || i)) {
        if (!s || !i) return !1
        let r = Object.keys(t).length,
          n = Object.keys(e).length
        if (r !== n) return !1
        for (let a in t) {
          let o = t.hasOwnProperty(a),
            u = e.hasOwnProperty(a)
          if ((o && !u) || (!o && u) || !Mu(t[a], e[a])) return !1
        }
      }
      return String(t) === String(e)
    }
    function TC(t, e) {
      return t.findIndex((s) => Mu(s, e))
    }
    var Ng = (t) => !!(t && t.__v_isRef === !0),
      Ig = (t) =>
        Ys(t)
          ? t
          : t == null
          ? ''
          : Vr(t) || (Ji(t) && (t.toString === th || !wa(t.toString)))
          ? Ng(t)
            ? Ig(t.value)
            : JSON.stringify(t, Og, 2)
          : String(t),
      Og = (t, e) =>
        Ng(e)
          ? Og(t, e.value)
          : bg(e)
          ? {
              [`Map(${e.size})`]: [...e.entries()].reduce(
                (s, [i, r], n) => ((s[nh(i, n) + ' =>'] = r), s),
                {}
              ),
            }
          : Eg(e)
          ? { [`Set(${e.size})`]: [...e.values()].map((s) => nh(s)) }
          : Ma(e)
          ? nh(e)
          : Ji(e) && !Vr(e) && !Sg(e)
          ? String(e)
          : e,
      nh = (t, e = '') => {
        var s
        return Ma(t) ? `Symbol(${(s = t.description) != null ? s : e})` : t
      }
    fe.EMPTY_ARR = p3
    fe.EMPTY_OBJ = h3
    fe.NO = m3
    fe.NOOP = d3
    fe.PatchFlagNames = H3
    fe.PatchFlags = U3
    fe.ShapeFlags = $3
    fe.SlotFlags = j3
    fe.camelize = I3
    fe.capitalize = _g
    fe.def = L3
    fe.escapeHtml = yC
    fe.escapeHtmlComment = EC
    fe.extend = b3
    fe.genPropsAccessExp = V3
    fe.generateCodeFrame = G3
    fe.getGlobalThis = F3
    fe.hasChanged = M3
    fe.hasOwn = T3
    fe.hyphenate = Tg
    fe.includeBooleanAttr = lC
    fe.invokeArrayFns = R3
    fe.isArray = Vr
    fe.isBooleanAttr = uC
    fe.isBuiltInDirective = v3
    fe.isDate = eh
    fe.isFunction = wa
    fe.isGloballyAllowed = Ag
    fe.isGloballyWhitelisted = X3
    fe.isHTMLTag = iC
    fe.isIntegerKey = P3
    fe.isKnownHtmlAttr = pC
    fe.isKnownSvgAttr = dC
    fe.isMap = bg
    fe.isMathMLTag = nC
    fe.isModelListener = y3
    fe.isObject = Ji
    fe.isOn = g3
    fe.isPlainObject = Sg
    fe.isPromise = x3
    fe.isRegExp = _3
    fe.isRenderableAttrValue = mC
    fe.isReservedProp = C3
    fe.isSSRSafeAttrName = fC
    fe.isSVGTag = rC
    fe.isSet = Eg
    fe.isSpecialBooleanAttr = oC
    fe.isString = Ys
    fe.isSymbol = Ma
    fe.isVoidTag = aC
    fe.looseEqual = Mu
    fe.looseIndexOf = TC
    fe.looseToNumber = k3
    fe.makeMap = Cs
    fe.normalizeClass = ih
    fe.normalizeProps = Q3
    fe.normalizeStyle = sh
    fe.objectToString = th
    fe.parseStringStyle = Cg
    fe.propsToAttrMap = hC
    fe.remove = E3
    fe.slotFlagsText = q3
    fe.stringifyStyle = Y3
    fe.toDisplayString = Ig
    fe.toHandlerKey = w3
    fe.toNumber = D3
    fe.toRawType = A3
    fe.toTypeString = Ur
  })
  var fs = Oe((nD, ah) => {
    'use strict'
    process.env.NODE_ENV === 'production'
      ? (ah.exports = yg())
      : (ah.exports = wg())
  })
  var Mg = Oe((oh) => {
    'use strict'
    Object.defineProperty(oh, '__esModule', { value: !0 })
    oh.default = new Uint16Array(
      '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'
        .split('')
        .map(function (t) {
          return t.charCodeAt(0)
        })
    )
  })
  var Rg = Oe((uh) => {
    'use strict'
    Object.defineProperty(uh, '__esModule', { value: !0 })
    uh.default = new Uint16Array(
      '\u0200aglq	\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022'
        .split('')
        .map(function (t) {
          return t.charCodeAt(0)
        })
    )
  })
  var ch = Oe((Yi) => {
    'use strict'
    var lh
    Object.defineProperty(Yi, '__esModule', { value: !0 })
    Yi.replaceCodePoint = Yi.fromCodePoint = void 0
    var _C = new Map([
      [0, 65533],
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376],
    ])
    Yi.fromCodePoint =
      (lh = String.fromCodePoint) !== null && lh !== void 0
        ? lh
        : function (t) {
            var e = ''
            return (
              t > 65535 &&
                ((t -= 65536),
                (e += String.fromCharCode(((t >>> 10) & 1023) | 55296)),
                (t = 56320 | (t & 1023))),
              (e += String.fromCharCode(t)),
              e
            )
          }
    function Lg(t) {
      var e
      return (t >= 55296 && t <= 57343) || t > 1114111
        ? 65533
        : (e = _C.get(t)) !== null && e !== void 0
        ? e
        : t
    }
    Yi.replaceCodePoint = Lg
    function xC(t) {
      return (0, Yi.fromCodePoint)(Lg(t))
    }
    Yi.default = xC
  })
  var dh = Oe((we) => {
    'use strict'
    var AC =
        (we && we.__createBinding) ||
        (Object.create
          ? function (t, e, s, i) {
              i === void 0 && (i = s)
              var r = Object.getOwnPropertyDescriptor(e, s)
              ;(!r ||
                ('get' in r ? !e.__esModule : r.writable || r.configurable)) &&
                (r = {
                  enumerable: !0,
                  get: function () {
                    return e[s]
                  },
                }),
                Object.defineProperty(t, i, r)
            }
          : function (t, e, s, i) {
              i === void 0 && (i = s), (t[i] = e[s])
            }),
      PC =
        (we && we.__setModuleDefault) ||
        (Object.create
          ? function (t, e) {
              Object.defineProperty(t, 'default', { enumerable: !0, value: e })
            }
          : function (t, e) {
              t.default = e
            }),
      CC =
        (we && we.__importStar) ||
        function (t) {
          if (t && t.__esModule) return t
          var e = {}
          if (t != null)
            for (var s in t)
              s !== 'default' &&
                Object.prototype.hasOwnProperty.call(t, s) &&
                AC(e, t, s)
          return PC(e, t), e
        },
      kg =
        (we && we.__importDefault) ||
        function (t) {
          return t && t.__esModule ? t : { default: t }
        }
    Object.defineProperty(we, '__esModule', { value: !0 })
    we.decodeXML =
      we.decodeHTMLStrict =
      we.decodeHTMLAttribute =
      we.decodeHTML =
      we.determineBranch =
      we.EntityDecoder =
      we.DecodingMode =
      we.BinTrieFlags =
      we.fromCodePoint =
      we.replaceCodePoint =
      we.decodeCodePoint =
      we.xmlDecodeTree =
      we.htmlDecodeTree =
        void 0
    var Dg = kg(Mg())
    we.htmlDecodeTree = Dg.default
    var Fg = kg(Rg())
    we.xmlDecodeTree = Fg.default
    var fh = CC(ch())
    we.decodeCodePoint = fh.default
    var Bg = ch()
    Object.defineProperty(we, 'replaceCodePoint', {
      enumerable: !0,
      get: function () {
        return Bg.replaceCodePoint
      },
    })
    Object.defineProperty(we, 'fromCodePoint', {
      enumerable: !0,
      get: function () {
        return Bg.fromCodePoint
      },
    })
    var Ct
    ;(function (t) {
      ;(t[(t.NUM = 35)] = 'NUM'),
        (t[(t.SEMI = 59)] = 'SEMI'),
        (t[(t.EQUALS = 61)] = 'EQUALS'),
        (t[(t.ZERO = 48)] = 'ZERO'),
        (t[(t.NINE = 57)] = 'NINE'),
        (t[(t.LOWER_A = 97)] = 'LOWER_A'),
        (t[(t.LOWER_F = 102)] = 'LOWER_F'),
        (t[(t.LOWER_X = 120)] = 'LOWER_X'),
        (t[(t.LOWER_Z = 122)] = 'LOWER_Z'),
        (t[(t.UPPER_A = 65)] = 'UPPER_A'),
        (t[(t.UPPER_F = 70)] = 'UPPER_F'),
        (t[(t.UPPER_Z = 90)] = 'UPPER_Z')
    })(Ct || (Ct = {}))
    var vC = 32,
      Hr
    ;(function (t) {
      ;(t[(t.VALUE_LENGTH = 49152)] = 'VALUE_LENGTH'),
        (t[(t.BRANCH_LENGTH = 16256)] = 'BRANCH_LENGTH'),
        (t[(t.JUMP_TABLE = 127)] = 'JUMP_TABLE')
    })((Hr = we.BinTrieFlags || (we.BinTrieFlags = {})))
    function hh(t) {
      return t >= Ct.ZERO && t <= Ct.NINE
    }
    function NC(t) {
      return (
        (t >= Ct.UPPER_A && t <= Ct.UPPER_F) ||
        (t >= Ct.LOWER_A && t <= Ct.LOWER_F)
      )
    }
    function IC(t) {
      return (
        (t >= Ct.UPPER_A && t <= Ct.UPPER_Z) ||
        (t >= Ct.LOWER_A && t <= Ct.LOWER_Z) ||
        hh(t)
      )
    }
    function OC(t) {
      return t === Ct.EQUALS || IC(t)
    }
    var vt
    ;(function (t) {
      ;(t[(t.EntityStart = 0)] = 'EntityStart'),
        (t[(t.NumericStart = 1)] = 'NumericStart'),
        (t[(t.NumericDecimal = 2)] = 'NumericDecimal'),
        (t[(t.NumericHex = 3)] = 'NumericHex'),
        (t[(t.NamedEntity = 4)] = 'NamedEntity')
    })(vt || (vt = {}))
    var Qs
    ;(function (t) {
      ;(t[(t.Legacy = 0)] = 'Legacy'),
        (t[(t.Strict = 1)] = 'Strict'),
        (t[(t.Attribute = 2)] = 'Attribute')
    })((Qs = we.DecodingMode || (we.DecodingMode = {})))
    var Vg = (function () {
      function t(e, s, i) {
        ;(this.decodeTree = e),
          (this.emitCodePoint = s),
          (this.errors = i),
          (this.state = vt.EntityStart),
          (this.consumed = 1),
          (this.result = 0),
          (this.treeIndex = 0),
          (this.excess = 1),
          (this.decodeMode = Qs.Strict)
      }
      return (
        (t.prototype.startEntity = function (e) {
          ;(this.decodeMode = e),
            (this.state = vt.EntityStart),
            (this.result = 0),
            (this.treeIndex = 0),
            (this.excess = 1),
            (this.consumed = 1)
        }),
        (t.prototype.write = function (e, s) {
          switch (this.state) {
            case vt.EntityStart:
              return e.charCodeAt(s) === Ct.NUM
                ? ((this.state = vt.NumericStart),
                  (this.consumed += 1),
                  this.stateNumericStart(e, s + 1))
                : ((this.state = vt.NamedEntity), this.stateNamedEntity(e, s))
            case vt.NumericStart:
              return this.stateNumericStart(e, s)
            case vt.NumericDecimal:
              return this.stateNumericDecimal(e, s)
            case vt.NumericHex:
              return this.stateNumericHex(e, s)
            case vt.NamedEntity:
              return this.stateNamedEntity(e, s)
          }
        }),
        (t.prototype.stateNumericStart = function (e, s) {
          return s >= e.length
            ? -1
            : (e.charCodeAt(s) | vC) === Ct.LOWER_X
            ? ((this.state = vt.NumericHex),
              (this.consumed += 1),
              this.stateNumericHex(e, s + 1))
            : ((this.state = vt.NumericDecimal), this.stateNumericDecimal(e, s))
        }),
        (t.prototype.addToNumericResult = function (e, s, i, r) {
          if (s !== i) {
            var n = i - s
            ;(this.result =
              this.result * Math.pow(r, n) + parseInt(e.substr(s, n), r)),
              (this.consumed += n)
          }
        }),
        (t.prototype.stateNumericHex = function (e, s) {
          for (var i = s; s < e.length; ) {
            var r = e.charCodeAt(s)
            if (hh(r) || NC(r)) s += 1
            else
              return (
                this.addToNumericResult(e, i, s, 16),
                this.emitNumericEntity(r, 3)
              )
          }
          return this.addToNumericResult(e, i, s, 16), -1
        }),
        (t.prototype.stateNumericDecimal = function (e, s) {
          for (var i = s; s < e.length; ) {
            var r = e.charCodeAt(s)
            if (hh(r)) s += 1
            else
              return (
                this.addToNumericResult(e, i, s, 10),
                this.emitNumericEntity(r, 2)
              )
          }
          return this.addToNumericResult(e, i, s, 10), -1
        }),
        (t.prototype.emitNumericEntity = function (e, s) {
          var i
          if (this.consumed <= s)
            return (
              (i = this.errors) === null ||
                i === void 0 ||
                i.absenceOfDigitsInNumericCharacterReference(this.consumed),
              0
            )
          if (e === Ct.SEMI) this.consumed += 1
          else if (this.decodeMode === Qs.Strict) return 0
          return (
            this.emitCodePoint(
              (0, fh.replaceCodePoint)(this.result),
              this.consumed
            ),
            this.errors &&
              (e !== Ct.SEMI &&
                this.errors.missingSemicolonAfterCharacterReference(),
              this.errors.validateNumericCharacterReference(this.result)),
            this.consumed
          )
        }),
        (t.prototype.stateNamedEntity = function (e, s) {
          for (
            var i = this.decodeTree,
              r = i[this.treeIndex],
              n = (r & Hr.VALUE_LENGTH) >> 14;
            s < e.length;
            s++, this.excess++
          ) {
            var a = e.charCodeAt(s)
            if (
              ((this.treeIndex = Hg(i, r, this.treeIndex + Math.max(1, n), a)),
              this.treeIndex < 0)
            )
              return this.result === 0 ||
                (this.decodeMode === Qs.Attribute && (n === 0 || OC(a)))
                ? 0
                : this.emitNotTerminatedNamedEntity()
            if (
              ((r = i[this.treeIndex]),
              (n = (r & Hr.VALUE_LENGTH) >> 14),
              n !== 0)
            ) {
              if (a === Ct.SEMI)
                return this.emitNamedEntityData(
                  this.treeIndex,
                  n,
                  this.consumed + this.excess
                )
              this.decodeMode !== Qs.Strict &&
                ((this.result = this.treeIndex),
                (this.consumed += this.excess),
                (this.excess = 0))
            }
          }
          return -1
        }),
        (t.prototype.emitNotTerminatedNamedEntity = function () {
          var e,
            s = this,
            i = s.result,
            r = s.decodeTree,
            n = (r[i] & Hr.VALUE_LENGTH) >> 14
          return (
            this.emitNamedEntityData(i, n, this.consumed),
            (e = this.errors) === null ||
              e === void 0 ||
              e.missingSemicolonAfterCharacterReference(),
            this.consumed
          )
        }),
        (t.prototype.emitNamedEntityData = function (e, s, i) {
          var r = this.decodeTree
          return (
            this.emitCodePoint(s === 1 ? r[e] & ~Hr.VALUE_LENGTH : r[e + 1], i),
            s === 3 && this.emitCodePoint(r[e + 2], i),
            i
          )
        }),
        (t.prototype.end = function () {
          var e
          switch (this.state) {
            case vt.NamedEntity:
              return this.result !== 0 &&
                (this.decodeMode !== Qs.Attribute ||
                  this.result === this.treeIndex)
                ? this.emitNotTerminatedNamedEntity()
                : 0
            case vt.NumericDecimal:
              return this.emitNumericEntity(0, 2)
            case vt.NumericHex:
              return this.emitNumericEntity(0, 3)
            case vt.NumericStart:
              return (
                (e = this.errors) === null ||
                  e === void 0 ||
                  e.absenceOfDigitsInNumericCharacterReference(this.consumed),
                0
              )
            case vt.EntityStart:
              return 0
          }
        }),
        t
      )
    })()
    we.EntityDecoder = Vg
    function Ug(t) {
      var e = '',
        s = new Vg(t, function (i) {
          return (e += (0, fh.fromCodePoint)(i))
        })
      return function (r, n) {
        for (var a = 0, o = 0; (o = r.indexOf('&', o)) >= 0; ) {
          ;(e += r.slice(a, o)), s.startEntity(n)
          var u = s.write(r, o + 1)
          if (u < 0) {
            a = o + s.end()
            break
          }
          ;(a = o + u), (o = u === 0 ? a + 1 : a)
        }
        var l = e + r.slice(a)
        return (e = ''), l
      }
    }
    function Hg(t, e, s, i) {
      var r = (e & Hr.BRANCH_LENGTH) >> 7,
        n = e & Hr.JUMP_TABLE
      if (r === 0) return n !== 0 && i === n ? s : -1
      if (n) {
        var a = i - n
        return a < 0 || a >= r ? -1 : t[s + a] - 1
      }
      for (var o = s, u = o + r - 1; o <= u; ) {
        var l = (o + u) >>> 1,
          c = t[l]
        if (c < i) o = l + 1
        else if (c > i) u = l - 1
        else return t[l + r]
      }
      return -1
    }
    we.determineBranch = Hg
    var ph = Ug(Dg.default),
      wC = Ug(Fg.default)
    function MC(t, e) {
      return e === void 0 && (e = Qs.Legacy), ph(t, e)
    }
    we.decodeHTML = MC
    function RC(t) {
      return ph(t, Qs.Attribute)
    }
    we.decodeHTMLAttribute = RC
    function LC(t) {
      return ph(t, Qs.Strict)
    }
    we.decodeHTMLStrict = LC
    function kC(t) {
      return wC(t, Qs.Strict)
    }
    we.decodeXML = kC
  })
  var Dh = Oe((Ka) => {
    'use strict'
    Object.defineProperty(Ka, '__esModule', { value: !0 })
    function $g(t, e) {
      if (t == null) return {}
      var s = {},
        i = Object.keys(t),
        r,
        n
      for (n = 0; n < i.length; n++)
        (r = i[n]), !(e.indexOf(r) >= 0) && (s[r] = t[r])
      return s
    }
    var hi = class {
        constructor(e, s, i) {
          ;(this.line = void 0),
            (this.column = void 0),
            (this.index = void 0),
            (this.line = e),
            (this.column = s),
            (this.index = i)
        }
      },
      Ra = class {
        constructor(e, s) {
          ;(this.start = void 0),
            (this.end = void 0),
            (this.filename = void 0),
            (this.identifierName = void 0),
            (this.start = e),
            (this.end = s)
        }
      }
    function zt(t, e) {
      let { line: s, column: i, index: r } = t
      return new hi(s, i + e, r + e)
    }
    var jg = 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
      DC = {
        ImportMetaOutsideModule: {
          message: `import.meta may appear only with 'sourceType: "module"'`,
          code: jg,
        },
        ImportOutsideModule: {
          message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
          code: jg,
        },
      },
      qg = {
        ArrayPattern: 'array destructuring pattern',
        AssignmentExpression: 'assignment expression',
        AssignmentPattern: 'assignment expression',
        ArrowFunctionExpression: 'arrow function expression',
        ConditionalExpression: 'conditional expression',
        CatchClause: 'catch clause',
        ForOfStatement: 'for-of statement',
        ForInStatement: 'for-in statement',
        ForStatement: 'for-loop',
        FormalParameters: 'function parameter list',
        Identifier: 'identifier',
        ImportSpecifier: 'import specifier',
        ImportDefaultSpecifier: 'import default specifier',
        ImportNamespaceSpecifier: 'import namespace specifier',
        ObjectPattern: 'object destructuring pattern',
        ParenthesizedExpression: 'parenthesized expression',
        RestElement: 'rest element',
        UpdateExpression: {
          true: 'prefix operation',
          false: 'postfix operation',
        },
        VariableDeclarator: 'variable declaration',
        YieldExpression: 'yield expression',
      },
      Ru = (t) =>
        t.type === 'UpdateExpression'
          ? qg.UpdateExpression[`${t.prefix}`]
          : qg[t.type],
      FC = {
        AccessorIsGenerator: ({ kind: t }) =>
          `A ${t}ter cannot be a generator.`,
        ArgumentsInClass:
          "'arguments' is only allowed in functions and class methods.",
        AsyncFunctionInSingleStatementContext:
          'Async functions can only be declared at the top level or inside a block.',
        AwaitBindingIdentifier:
          "Can not use 'await' as identifier inside an async function.",
        AwaitBindingIdentifierInStaticBlock:
          "Can not use 'await' as identifier inside a static block.",
        AwaitExpressionFormalParameter:
          "'await' is not allowed in async function parameters.",
        AwaitUsingNotInAsyncContext:
          "'await using' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncContext:
          "'await' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncFunction:
          "'await' is only allowed within async functions.",
        BadGetterArity: "A 'get' accessor must not have any formal parameters.",
        BadSetterArity:
          "A 'set' accessor must have exactly one formal parameter.",
        BadSetterRestParameter:
          "A 'set' accessor function argument must not be a rest parameter.",
        ConstructorClassField:
          "Classes may not have a field named 'constructor'.",
        ConstructorClassPrivateField:
          "Classes may not have a private field named '#constructor'.",
        ConstructorIsAccessor: 'Class constructor may not be an accessor.',
        ConstructorIsAsync: "Constructor can't be an async function.",
        ConstructorIsGenerator: "Constructor can't be a generator.",
        DeclarationMissingInitializer: ({ kind: t }) =>
          `Missing initializer in ${t} declaration.`,
        DecoratorArgumentsOutsideParentheses:
          "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
        DecoratorBeforeExport:
          "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
        DecoratorsBeforeAfterExport:
          "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
        DecoratorConstructor:
          "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass:
          "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
        DecoratorSemicolon: 'Decorators must not be followed by a semicolon.',
        DecoratorStaticBlock: "Decorators can't be used with a static block.",
        DeferImportRequiresNamespace:
          'Only `import defer * as x from "./module"` is valid.',
        DeletePrivateField: 'Deleting a private field is not allowed.',
        DestructureNamedImport:
          'ES2015 named imports do not destructure. Use another statement for destructuring after the import.',
        DuplicateConstructor: 'Duplicate constructor in the same class.',
        DuplicateDefaultExport: 'Only one default export allowed per module.',
        DuplicateExport: ({ exportName: t }) =>
          `\`${t}\` has already been exported. Exported identifiers must be unique.`,
        DuplicateProto: 'Redefinition of __proto__ property.',
        DuplicateRegExpFlags: 'Duplicate regular expression flag.',
        DynamicImportPhaseRequiresImportExpressions: ({ phase: t }) =>
          `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`,
        ElementAfterRest: 'Rest element must be last element.',
        EscapedCharNotAnIdentifier: 'Invalid Unicode escape.',
        ExportBindingIsString: ({
          localName: t,
          exportName: e,
        }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`,
        ExportDefaultFromAsIdentifier:
          "'from' is not allowed as an identifier after 'export default'.",
        ForInOfLoopInitializer: ({ type: t }) =>
          `'${
            t === 'ForInStatement' ? 'for-in' : 'for-of'
          }' loop variable declaration may not have an initializer.`,
        ForInUsing: "For-in loop may not start with 'using' declaration.",
        ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
        ForOfLet:
          "The left-hand side of a for-of loop may not start with 'let'.",
        GeneratorInSingleStatementContext:
          'Generators can only be declared at the top level or inside a block.',
        IllegalBreakContinue: ({ type: t }) =>
          `Unsyntactic ${t === 'BreakStatement' ? 'break' : 'continue'}.`,
        IllegalLanguageModeDirective:
          "Illegal 'use strict' directive in function with non-simple parameter list.",
        IllegalReturn: "'return' outside of function.",
        ImportAttributesUseAssert:
          'The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.',
        ImportBindingIsString: ({
          importName: t,
        }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`,
        ImportCallArgumentTrailingComma:
          'Trailing comma is disallowed inside import(...) arguments.',
        ImportCallArity: ({ maxArgumentCount: t }) =>
          `\`import()\` requires exactly ${
            t === 1 ? 'one argument' : 'one or two arguments'
          }.`,
        ImportCallNotNewExpression: 'Cannot use new with import(...).',
        ImportCallSpreadArgument: '`...` is not allowed in `import()`.',
        ImportJSONBindingNotDefault:
          'A JSON module can only be imported with `default`.',
        ImportReflectionHasAssertion:
          '`import module x` cannot have assertions.',
        ImportReflectionNotBinding:
          'Only `import module x from "./module"` is valid.',
        IncompatibleRegExpUVFlags:
          "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
        InvalidBigIntLiteral: 'Invalid BigIntLiteral.',
        InvalidCodePoint: 'Code point out of bounds.',
        InvalidCoverInitializedName: 'Invalid shorthand property initializer.',
        InvalidDecimal: 'Invalid decimal.',
        InvalidDigit: ({ radix: t }) => `Expected number in radix ${t}.`,
        InvalidEscapeSequence: 'Bad character escape sequence.',
        InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template.',
        InvalidEscapedReservedWord: ({ reservedWord: t }) =>
          `Escape sequence in keyword ${t}.`,
        InvalidIdentifier: ({ identifierName: t }) =>
          `Invalid identifier ${t}.`,
        InvalidLhs: ({ ancestor: t }) => `Invalid left-hand side in ${Ru(t)}.`,
        InvalidLhsBinding: ({ ancestor: t }) =>
          `Binding invalid left-hand side in ${Ru(t)}.`,
        InvalidLhsOptionalChaining: ({ ancestor: t }) =>
          `Invalid optional chaining in the left-hand side of ${Ru(t)}.`,
        InvalidNumber: 'Invalid number.',
        InvalidOrMissingExponent:
          "Floating-point numbers require a valid exponent after the 'e'.",
        InvalidOrUnexpectedToken: ({ unexpected: t }) =>
          `Unexpected character '${t}'.`,
        InvalidParenthesizedAssignment:
          'Invalid parenthesized assignment pattern.',
        InvalidPrivateFieldResolution: ({ identifierName: t }) =>
          `Private name #${t} is not defined.`,
        InvalidPropertyBindingPattern: 'Binding member expression.',
        InvalidRecordProperty:
          'Only properties and spread elements are allowed in record definitions.',
        InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
        LabelRedeclaration: ({ labelName: t }) =>
          `Label '${t}' is already declared.`,
        LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
        MalformedRegExpFlags: 'Invalid regular expression flag.',
        MissingClassName: 'A class name is required.',
        MissingEqInAssignment:
          "Only '=' operator can be used for specifying default value.",
        MissingSemicolon: 'Missing semicolon.',
        MissingPlugin: ({ missingPlugin: t }) =>
          `This experimental syntax requires enabling the parser plugin: ${t
            .map((e) => JSON.stringify(e))
            .join(', ')}.`,
        MissingOneOfPlugins: ({ missingPlugin: t }) =>
          `This experimental syntax requires enabling one of the following parser plugin(s): ${t
            .map((e) => JSON.stringify(e))
            .join(', ')}.`,
        MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX.',
        MixingCoalesceWithLogical:
          'Nullish coalescing operator(??) requires parens when mixing with logical operators.',
        ModuleAttributeDifferentFromType:
          'The only accepted module attribute is `type`.',
        ModuleAttributeInvalidValue:
          'Only string literals are allowed as module attribute values.',
        ModuleAttributesWithDuplicateKeys: ({ key: t }) =>
          `Duplicate key "${t}" is not allowed in module attributes.`,
        ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: t }) =>
          `An export name cannot include a lone surrogate, found '\\u${t.toString(
            16
          )}'.`,
        ModuleExportUndefined: ({ localName: t }) =>
          `Export '${t}' is not defined.`,
        MultipleDefaultsInSwitch: 'Multiple default clauses.',
        NewlineAfterThrow: 'Illegal newline after throw.',
        NoCatchOrFinally: 'Missing catch or finally clause.',
        NumberIdentifier: 'Identifier directly after number.',
        NumericSeparatorInEscapeSequence:
          'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.',
        ObsoleteAwaitStar:
          "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew:
          'Constructors in/after an Optional Chain are not allowed.',
        OptionalChainingNoTemplate:
          'Tagged Template Literals are not allowed in optionalChain.',
        OverrideOnConstructor:
          "'override' modifier cannot appear on a constructor declaration.",
        ParamDupe: 'Argument name clash.',
        PatternHasAccessor: "Object pattern can't contain getter or setter.",
        PatternHasMethod: "Object pattern can't contain methods.",
        PrivateInExpectedIn: ({ identifierName: t }) =>
          `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`,
        PrivateNameRedeclaration: ({ identifierName: t }) =>
          `Duplicate private name #${t}.`,
        RecordExpressionBarIncorrectEndSyntaxType:
          "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionBarIncorrectStartSyntaxType:
          "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionHashIncorrectStartSyntaxType:
          "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        RecordNoProto: "'__proto__' is not allowed in Record expressions.",
        RestTrailingComma: 'Unexpected trailing comma after rest element.',
        SloppyFunction:
          'In non-strict mode code, functions can only be declared at top level or inside a block.',
        SloppyFunctionAnnexB:
          'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.',
        SourcePhaseImportRequiresDefault:
          'Only `import source x from "./module"` is valid.',
        StaticPrototype:
          'Classes may not have static property named prototype.',
        SuperNotAllowed:
          "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super.",
        TrailingDecorator: 'Decorators must be attached to a class element.',
        TupleExpressionBarIncorrectEndSyntaxType:
          "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionBarIncorrectStartSyntaxType:
          "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionHashIncorrectStartSyntaxType:
          "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder.',
        UnexpectedAwaitAfterPipelineBody:
          'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
        UnexpectedDigitAfterHash: 'Unexpected digit after hash token.',
        UnexpectedImportExport:
          "'import' and 'export' may only appear at the top level.",
        UnexpectedKeyword: ({ keyword: t }) => `Unexpected keyword '${t}'.`,
        UnexpectedLeadingDecorator:
          'Leading decorators must be attached to a class declaration.',
        UnexpectedLexicalDeclaration:
          'Lexical declaration cannot appear in a single-statement context.',
        UnexpectedNewTarget:
          '`new.target` can only be used in functions or class properties.',
        UnexpectedNumericSeparator:
          'A numeric separator is only allowed between two digits.',
        UnexpectedPrivateField: 'Unexpected private name.',
        UnexpectedReservedWord: ({ reservedWord: t }) =>
          `Unexpected reserved word '${t}'.`,
        UnexpectedSuper:
          "'super' is only allowed in object methods and classes.",
        UnexpectedToken: ({ expected: t, unexpected: e }) =>
          `Unexpected token${e ? ` '${e}'.` : ''}${
            t ? `, expected "${t}"` : ''
          }`,
        UnexpectedTokenUnaryExponentiation:
          'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.',
        UnexpectedUsingDeclaration:
          'Using declaration cannot appear in the top level when source type is `script`.',
        UnsupportedBind: 'Binding should be performed on object property.',
        UnsupportedDecoratorExport:
          'A decorated export must export a class declaration.',
        UnsupportedDefaultExport:
          'Only expressions, functions or classes are allowed as the `default` export.',
        UnsupportedImport:
          '`import` can only be used in `import()` or `import.meta`.',
        UnsupportedMetaProperty: ({ target: t, onlyValidPropertyName: e }) =>
          `The only valid meta property for ${t} is ${t}.${e}.`,
        UnsupportedParameterDecorator:
          'Decorators cannot be used to decorate parameters.',
        UnsupportedPropertyDecorator:
          'Decorators cannot be used to decorate object literal properties.',
        UnsupportedSuper:
          "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
        UnterminatedComment: 'Unterminated comment.',
        UnterminatedRegExp: 'Unterminated regular expression.',
        UnterminatedString: 'Unterminated string constant.',
        UnterminatedTemplate: 'Unterminated template.',
        UsingDeclarationExport: 'Using declaration cannot be exported.',
        UsingDeclarationHasBindingPattern:
          'Using declaration cannot have destructuring patterns.',
        VarRedeclaration: ({ identifierName: t }) =>
          `Identifier '${t}' has already been declared.`,
        YieldBindingIdentifier:
          "Can not use 'yield' as identifier inside a generator.",
        YieldInParameter:
          'Yield expression is not allowed in formal parameters.',
        ZeroDigitNumericSeparator:
          'Numeric separator can not be used after leading 0.',
      },
      BC = {
        StrictDelete: 'Deleting local variable in strict mode.',
        StrictEvalArguments: ({ referenceName: t }) =>
          `Assigning to '${t}' in strict mode.`,
        StrictEvalArgumentsBinding: ({ bindingName: t }) =>
          `Binding '${t}' in strict mode.`,
        StrictFunction:
          'In strict mode code, functions can only be declared at top level or inside a block.',
        StrictNumericEscape:
          "The only valid numeric escape in strict mode is '\\0'.",
        StrictOctalLiteral:
          'Legacy octal literals are not allowed in strict mode.',
        StrictWith: "'with' in strict mode.",
      },
      VC = new Set([
        'ArrowFunctionExpression',
        'AssignmentExpression',
        'ConditionalExpression',
        'YieldExpression',
      ]),
      UC = {
        PipeBodyIsTighter:
          'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.',
        PipeTopicRequiresHackPipes:
          'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
        PipeTopicUnbound:
          'Topic reference is unbound; it must be inside a pipe body.',
        PipeTopicUnconfiguredToken: ({ token: t }) =>
          `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${t}" }.`,
        PipeTopicUnused:
          'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.',
        PipeUnparenthesizedBody: ({ type: t }) =>
          `Hack-style pipe body cannot be an unparenthesized ${Ru({
            type: t,
          })}; please wrap it in parentheses.`,
        PipelineBodyNoArrow:
          'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
        PipelineBodySequenceExpression:
          'Pipeline body may not be a comma-separated sequence expression.',
        PipelineHeadSequenceExpression:
          'Pipeline head should not be a comma-separated sequence expression.',
        PipelineTopicUnused:
          'Pipeline is in topic style but does not use topic reference.',
        PrimaryTopicNotAllowed:
          'Topic reference was used in a lexical context without topic binding.',
        PrimaryTopicRequiresSmartPipeline:
          'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      },
      HC = ['toMessage'],
      $C = ['message']
    function Kg(t, e, s) {
      Object.defineProperty(t, e, {
        enumerable: !1,
        configurable: !0,
        value: s,
      })
    }
    function jC(t) {
      let { toMessage: e } = t,
        s = $g(t, HC)
      return function i(r, n) {
        let a = new SyntaxError()
        return (
          Object.assign(a, s, { loc: r, pos: r.index }),
          'missingPlugin' in n &&
            Object.assign(a, { missingPlugin: n.missingPlugin }),
          Kg(a, 'clone', function (u = {}) {
            var l
            let { line: c, column: f, index: h } = (l = u.loc) != null ? l : r
            return i(new hi(c, f, h), Object.assign({}, n, u.details))
          }),
          Kg(a, 'details', n),
          Object.defineProperty(a, 'message', {
            configurable: !0,
            get() {
              let o = `${e(n)} (${r.line}:${r.column})`
              return (this.message = o), o
            },
            set(o) {
              Object.defineProperty(this, 'message', { value: o, writable: !0 })
            },
          }),
          a
        )
      }
    }
    function pi(t, e) {
      if (Array.isArray(t)) return (i) => pi(i, t[0])
      let s = {}
      for (let i of Object.keys(t)) {
        let r = t[i],
          n =
            typeof r == 'string'
              ? { message: () => r }
              : typeof r == 'function'
              ? { message: r }
              : r,
          { message: a } = n,
          o = $g(n, $C),
          u = typeof a == 'string' ? () => a : a
        s[i] = jC(
          Object.assign(
            { code: 'BABEL_PARSER_SYNTAX_ERROR', reasonCode: i, toMessage: u },
            e ? { syntaxPlugin: e } : {},
            o
          )
        )
      }
      return s
    }
    var R = Object.assign({}, pi(DC), pi(FC), pi(BC), pi`pipelineOperator`(UC)),
      { defineProperty: qC } = Object,
      Xg = (t, e) => {
        t && qC(t, e, { enumerable: !1, value: t[e] })
      }
    function La(t) {
      return Xg(t.loc.start, 'index'), Xg(t.loc.end, 'index'), t
    }
    var KC = (t) =>
        class extends t {
          parse() {
            let s = La(super.parse())
            return this.options.tokens && (s.tokens = s.tokens.map(La)), s
          }
          parseRegExpLiteral({ pattern: s, flags: i }) {
            let r = null
            try {
              r = new RegExp(s, i)
            } catch (a) {}
            let n = this.estreeParseLiteral(r)
            return (n.regex = { pattern: s, flags: i }), n
          }
          parseBigIntLiteral(s) {
            let i
            try {
              i = BigInt(s)
            } catch (n) {
              i = null
            }
            let r = this.estreeParseLiteral(i)
            return (r.bigint = String(r.value || s)), r
          }
          parseDecimalLiteral(s) {
            let i = null,
              r = this.estreeParseLiteral(i)
            return (r.decimal = String(r.value || s)), r
          }
          estreeParseLiteral(s) {
            return this.parseLiteral(s, 'Literal')
          }
          parseStringLiteral(s) {
            return this.estreeParseLiteral(s)
          }
          parseNumericLiteral(s) {
            return this.estreeParseLiteral(s)
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null)
          }
          parseBooleanLiteral(s) {
            return this.estreeParseLiteral(s)
          }
          directiveToStmt(s) {
            let i = s.value
            delete s.value,
              (i.type = 'Literal'),
              (i.raw = i.extra.raw),
              (i.value = i.extra.expressionValue)
            let r = s
            return (
              (r.type = 'ExpressionStatement'),
              (r.expression = i),
              (r.directive = i.extra.rawValue),
              delete i.extra,
              r
            )
          }
          initFunction(s, i) {
            super.initFunction(s, i), (s.expression = !1)
          }
          checkDeclaration(s) {
            s != null && this.isObjectProperty(s)
              ? this.checkDeclaration(s.value)
              : super.checkDeclaration(s)
          }
          getObjectOrClassMethodParams(s) {
            return s.value.params
          }
          isValidDirective(s) {
            var i
            return (
              s.type === 'ExpressionStatement' &&
              s.expression.type === 'Literal' &&
              typeof s.expression.value == 'string' &&
              !((i = s.expression.extra) != null && i.parenthesized)
            )
          }
          parseBlockBody(s, i, r, n, a) {
            super.parseBlockBody(s, i, r, n, a)
            let o = s.directives.map((u) => this.directiveToStmt(u))
            ;(s.body = o.concat(s.body)), delete s.directives
          }
          pushClassMethod(s, i, r, n, a, o) {
            this.parseMethod(i, r, n, a, o, 'ClassMethod', !0),
              i.typeParameters &&
                ((i.value.typeParameters = i.typeParameters),
                delete i.typeParameters),
              s.body.push(i)
          }
          parsePrivateName() {
            let s = super.parsePrivateName()
            return this.getPluginOption('estree', 'classFeatures')
              ? this.convertPrivateNameToPrivateIdentifier(s)
              : s
          }
          convertPrivateNameToPrivateIdentifier(s) {
            let i = super.getPrivateNameSV(s)
            return (
              (s = s),
              delete s.id,
              (s.name = i),
              (s.type = 'PrivateIdentifier'),
              s
            )
          }
          isPrivateName(s) {
            return this.getPluginOption('estree', 'classFeatures')
              ? s.type === 'PrivateIdentifier'
              : super.isPrivateName(s)
          }
          getPrivateNameSV(s) {
            return this.getPluginOption('estree', 'classFeatures')
              ? s.name
              : super.getPrivateNameSV(s)
          }
          parseLiteral(s, i) {
            let r = super.parseLiteral(s, i)
            return (r.raw = r.extra.raw), delete r.extra, r
          }
          parseFunctionBody(s, i, r = !1) {
            super.parseFunctionBody(s, i, r),
              (s.expression = s.body.type !== 'BlockStatement')
          }
          parseMethod(s, i, r, n, a, o, u = !1) {
            let l = this.startNode()
            return (
              (l.kind = s.kind),
              (l = super.parseMethod(l, i, r, n, a, o, u)),
              (l.type = 'FunctionExpression'),
              delete l.kind,
              (s.value = l),
              o === 'ClassPrivateMethod' && (s.computed = !1),
              this.finishNode(s, 'MethodDefinition')
            )
          }
          nameIsConstructor(s) {
            return s.type === 'Literal'
              ? s.value === 'constructor'
              : super.nameIsConstructor(s)
          }
          parseClassProperty(...s) {
            let i = super.parseClassProperty(...s)
            return (
              this.getPluginOption('estree', 'classFeatures') &&
                (i.type = 'PropertyDefinition'),
              i
            )
          }
          parseClassPrivateProperty(...s) {
            let i = super.parseClassPrivateProperty(...s)
            return (
              this.getPluginOption('estree', 'classFeatures') &&
                ((i.type = 'PropertyDefinition'), (i.computed = !1)),
              i
            )
          }
          parseObjectMethod(s, i, r, n, a) {
            let o = super.parseObjectMethod(s, i, r, n, a)
            return (
              o &&
                ((o.type = 'Property'),
                o.kind === 'method' && (o.kind = 'init'),
                (o.shorthand = !1)),
              o
            )
          }
          parseObjectProperty(s, i, r, n) {
            let a = super.parseObjectProperty(s, i, r, n)
            return a && ((a.kind = 'init'), (a.type = 'Property')), a
          }
          isValidLVal(s, i, r) {
            return s === 'Property' ? 'value' : super.isValidLVal(s, i, r)
          }
          isAssignable(s, i) {
            return s != null && this.isObjectProperty(s)
              ? this.isAssignable(s.value, i)
              : super.isAssignable(s, i)
          }
          toAssignable(s, i = !1) {
            if (s != null && this.isObjectProperty(s)) {
              let { key: r, value: n } = s
              this.isPrivateName(r) &&
                this.classScope.usePrivateName(
                  this.getPrivateNameSV(r),
                  r.loc.start
                ),
                this.toAssignable(n, i)
            } else super.toAssignable(s, i)
          }
          toAssignableObjectExpressionProp(s, i, r) {
            s.type === 'Property' && (s.kind === 'get' || s.kind === 'set')
              ? this.raise(R.PatternHasAccessor, s.key)
              : s.type === 'Property' && s.method
              ? this.raise(R.PatternHasMethod, s.key)
              : super.toAssignableObjectExpressionProp(s, i, r)
          }
          finishCallExpression(s, i) {
            let r = super.finishCallExpression(s, i)
            if (r.callee.type === 'Import') {
              if (
                ((r.type = 'ImportExpression'),
                (r.source = r.arguments[0]),
                this.hasPlugin('importAttributes') ||
                  this.hasPlugin('importAssertions'))
              ) {
                var n, a
                ;(r.options = (n = r.arguments[1]) != null ? n : null),
                  (r.attributes = (a = r.arguments[1]) != null ? a : null)
              }
              delete r.arguments, delete r.callee
            }
            return r
          }
          toReferencedArguments(s) {
            s.type !== 'ImportExpression' && super.toReferencedArguments(s)
          }
          parseExport(s, i) {
            let r = this.state.lastTokStartLoc,
              n = super.parseExport(s, i)
            switch (n.type) {
              case 'ExportAllDeclaration':
                n.exported = null
                break
              case 'ExportNamedDeclaration':
                n.specifiers.length === 1 &&
                  n.specifiers[0].type === 'ExportNamespaceSpecifier' &&
                  ((n.type = 'ExportAllDeclaration'),
                  (n.exported = n.specifiers[0].exported),
                  delete n.specifiers)
              case 'ExportDefaultDeclaration':
                {
                  var a
                  let { declaration: o } = n
                  ;(o == null ? void 0 : o.type) === 'ClassDeclaration' &&
                    ((a = o.decorators) == null ? void 0 : a.length) > 0 &&
                    o.start === n.start &&
                    this.resetStartLocation(n, r)
                }
                break
            }
            return n
          }
          parseSubscript(s, i, r, n) {
            let a = super.parseSubscript(s, i, r, n)
            if (n.optionalChainMember) {
              if (
                ((a.type === 'OptionalMemberExpression' ||
                  a.type === 'OptionalCallExpression') &&
                  (a.type = a.type.substring(8)),
                n.stop)
              ) {
                let o = this.startNodeAtNode(a)
                return (o.expression = a), this.finishNode(o, 'ChainExpression')
              }
            } else
              (a.type === 'MemberExpression' || a.type === 'CallExpression') &&
                (a.optional = !1)
            return a
          }
          isOptionalMemberExpression(s) {
            return s.type === 'ChainExpression'
              ? s.expression.type === 'MemberExpression'
              : super.isOptionalMemberExpression(s)
          }
          hasPropertyAsPrivateName(s) {
            return (
              s.type === 'ChainExpression' && (s = s.expression),
              super.hasPropertyAsPrivateName(s)
            )
          }
          isObjectProperty(s) {
            return s.type === 'Property' && s.kind === 'init' && !s.method
          }
          isObjectMethod(s) {
            return (
              s.type === 'Property' &&
              (s.method || s.kind === 'get' || s.kind === 'set')
            )
          }
          finishNodeAt(s, i, r) {
            return La(super.finishNodeAt(s, i, r))
          }
          resetStartLocation(s, i) {
            super.resetStartLocation(s, i), La(s)
          }
          resetEndLocation(s, i = this.state.lastTokEndLoc) {
            super.resetEndLocation(s, i), La(s)
          }
        },
      Dn = class {
        constructor(e, s) {
          ;(this.token = void 0),
            (this.preserveSpace = void 0),
            (this.token = e),
            (this.preserveSpace = !!s)
        }
      },
      Ke = {
        brace: new Dn('{'),
        j_oTag: new Dn('<tag'),
        j_cTag: new Dn('</tag'),
        j_expr: new Dn('<tag>...</tag>', !0),
      }
    Ke.template = new Dn('`', !0)
    var ve = !0,
      ae = !0,
      mh = !0,
      ka = !0,
      Qi = !0,
      XC = !0,
      gh = class {
        constructor(e, s = {}) {
          ;(this.label = void 0),
            (this.keyword = void 0),
            (this.beforeExpr = void 0),
            (this.startsExpr = void 0),
            (this.rightAssociative = void 0),
            (this.isLoop = void 0),
            (this.isAssign = void 0),
            (this.prefix = void 0),
            (this.postfix = void 0),
            (this.binop = void 0),
            (this.label = e),
            (this.keyword = s.keyword),
            (this.beforeExpr = !!s.beforeExpr),
            (this.startsExpr = !!s.startsExpr),
            (this.rightAssociative = !!s.rightAssociative),
            (this.isLoop = !!s.isLoop),
            (this.isAssign = !!s.isAssign),
            (this.prefix = !!s.prefix),
            (this.postfix = !!s.postfix),
            (this.binop = s.binop != null ? s.binop : null),
            (this.updateContext = null)
        }
      },
      yh = new Map()
    function ke(t, e = {}) {
      e.keyword = t
      let s = ge(t, e)
      return yh.set(t, s), s
    }
    function Jt(t, e) {
      return ge(t, { beforeExpr: ve, binop: e })
    }
    var Da = -1,
      di = [],
      bh = [],
      Eh = [],
      Sh = [],
      Th = [],
      _h = []
    function ge(t, e = {}) {
      var s, i, r, n
      return (
        ++Da,
        bh.push(t),
        Eh.push((s = e.binop) != null ? s : -1),
        Sh.push((i = e.beforeExpr) != null ? i : !1),
        Th.push((r = e.startsExpr) != null ? r : !1),
        _h.push((n = e.prefix) != null ? n : !1),
        di.push(new gh(t, e)),
        Da
      )
    }
    function Ne(t, e = {}) {
      var s, i, r, n
      return (
        ++Da,
        yh.set(t, Da),
        bh.push(t),
        Eh.push((s = e.binop) != null ? s : -1),
        Sh.push((i = e.beforeExpr) != null ? i : !1),
        Th.push((r = e.startsExpr) != null ? r : !1),
        _h.push((n = e.prefix) != null ? n : !1),
        di.push(new gh('name', e)),
        Da
      )
    }
    var GC = {
      bracketL: ge('[', { beforeExpr: ve, startsExpr: ae }),
      bracketHashL: ge('#[', { beforeExpr: ve, startsExpr: ae }),
      bracketBarL: ge('[|', { beforeExpr: ve, startsExpr: ae }),
      bracketR: ge(']'),
      bracketBarR: ge('|]'),
      braceL: ge('{', { beforeExpr: ve, startsExpr: ae }),
      braceBarL: ge('{|', { beforeExpr: ve, startsExpr: ae }),
      braceHashL: ge('#{', { beforeExpr: ve, startsExpr: ae }),
      braceR: ge('}'),
      braceBarR: ge('|}'),
      parenL: ge('(', { beforeExpr: ve, startsExpr: ae }),
      parenR: ge(')'),
      comma: ge(',', { beforeExpr: ve }),
      semi: ge(';', { beforeExpr: ve }),
      colon: ge(':', { beforeExpr: ve }),
      doubleColon: ge('::', { beforeExpr: ve }),
      dot: ge('.'),
      question: ge('?', { beforeExpr: ve }),
      questionDot: ge('?.'),
      arrow: ge('=>', { beforeExpr: ve }),
      template: ge('template'),
      ellipsis: ge('...', { beforeExpr: ve }),
      backQuote: ge('`', { startsExpr: ae }),
      dollarBraceL: ge('${', { beforeExpr: ve, startsExpr: ae }),
      templateTail: ge('...`', { startsExpr: ae }),
      templateNonTail: ge('...${', { beforeExpr: ve, startsExpr: ae }),
      at: ge('@'),
      hash: ge('#', { startsExpr: ae }),
      interpreterDirective: ge('#!...'),
      eq: ge('=', { beforeExpr: ve, isAssign: ka }),
      assign: ge('_=', { beforeExpr: ve, isAssign: ka }),
      slashAssign: ge('_=', { beforeExpr: ve, isAssign: ka }),
      xorAssign: ge('_=', { beforeExpr: ve, isAssign: ka }),
      moduloAssign: ge('_=', { beforeExpr: ve, isAssign: ka }),
      incDec: ge('++/--', { prefix: Qi, postfix: XC, startsExpr: ae }),
      bang: ge('!', { beforeExpr: ve, prefix: Qi, startsExpr: ae }),
      tilde: ge('~', { beforeExpr: ve, prefix: Qi, startsExpr: ae }),
      doubleCaret: ge('^^', { startsExpr: ae }),
      doubleAt: ge('@@', { startsExpr: ae }),
      pipeline: Jt('|>', 0),
      nullishCoalescing: Jt('??', 1),
      logicalOR: Jt('||', 1),
      logicalAND: Jt('&&', 2),
      bitwiseOR: Jt('|', 3),
      bitwiseXOR: Jt('^', 4),
      bitwiseAND: Jt('&', 5),
      equality: Jt('==/!=/===/!==', 6),
      lt: Jt('</>/<=/>=', 7),
      gt: Jt('</>/<=/>=', 7),
      relational: Jt('</>/<=/>=', 7),
      bitShift: Jt('<</>>/>>>', 8),
      bitShiftL: Jt('<</>>/>>>', 8),
      bitShiftR: Jt('<</>>/>>>', 8),
      plusMin: ge('+/-', {
        beforeExpr: ve,
        binop: 9,
        prefix: Qi,
        startsExpr: ae,
      }),
      modulo: ge('%', { binop: 10, startsExpr: ae }),
      star: ge('*', { binop: 10 }),
      slash: Jt('/', 10),
      exponent: ge('**', { beforeExpr: ve, binop: 11, rightAssociative: !0 }),
      _in: ke('in', { beforeExpr: ve, binop: 7 }),
      _instanceof: ke('instanceof', { beforeExpr: ve, binop: 7 }),
      _break: ke('break'),
      _case: ke('case', { beforeExpr: ve }),
      _catch: ke('catch'),
      _continue: ke('continue'),
      _debugger: ke('debugger'),
      _default: ke('default', { beforeExpr: ve }),
      _else: ke('else', { beforeExpr: ve }),
      _finally: ke('finally'),
      _function: ke('function', { startsExpr: ae }),
      _if: ke('if'),
      _return: ke('return', { beforeExpr: ve }),
      _switch: ke('switch'),
      _throw: ke('throw', { beforeExpr: ve, prefix: Qi, startsExpr: ae }),
      _try: ke('try'),
      _var: ke('var'),
      _const: ke('const'),
      _with: ke('with'),
      _new: ke('new', { beforeExpr: ve, startsExpr: ae }),
      _this: ke('this', { startsExpr: ae }),
      _super: ke('super', { startsExpr: ae }),
      _class: ke('class', { startsExpr: ae }),
      _extends: ke('extends', { beforeExpr: ve }),
      _export: ke('export'),
      _import: ke('import', { startsExpr: ae }),
      _null: ke('null', { startsExpr: ae }),
      _true: ke('true', { startsExpr: ae }),
      _false: ke('false', { startsExpr: ae }),
      _typeof: ke('typeof', { beforeExpr: ve, prefix: Qi, startsExpr: ae }),
      _void: ke('void', { beforeExpr: ve, prefix: Qi, startsExpr: ae }),
      _delete: ke('delete', { beforeExpr: ve, prefix: Qi, startsExpr: ae }),
      _do: ke('do', { isLoop: mh, beforeExpr: ve }),
      _for: ke('for', { isLoop: mh }),
      _while: ke('while', { isLoop: mh }),
      _as: Ne('as', { startsExpr: ae }),
      _assert: Ne('assert', { startsExpr: ae }),
      _async: Ne('async', { startsExpr: ae }),
      _await: Ne('await', { startsExpr: ae }),
      _defer: Ne('defer', { startsExpr: ae }),
      _from: Ne('from', { startsExpr: ae }),
      _get: Ne('get', { startsExpr: ae }),
      _let: Ne('let', { startsExpr: ae }),
      _meta: Ne('meta', { startsExpr: ae }),
      _of: Ne('of', { startsExpr: ae }),
      _sent: Ne('sent', { startsExpr: ae }),
      _set: Ne('set', { startsExpr: ae }),
      _source: Ne('source', { startsExpr: ae }),
      _static: Ne('static', { startsExpr: ae }),
      _using: Ne('using', { startsExpr: ae }),
      _yield: Ne('yield', { startsExpr: ae }),
      _asserts: Ne('asserts', { startsExpr: ae }),
      _checks: Ne('checks', { startsExpr: ae }),
      _exports: Ne('exports', { startsExpr: ae }),
      _global: Ne('global', { startsExpr: ae }),
      _implements: Ne('implements', { startsExpr: ae }),
      _intrinsic: Ne('intrinsic', { startsExpr: ae }),
      _infer: Ne('infer', { startsExpr: ae }),
      _is: Ne('is', { startsExpr: ae }),
      _mixins: Ne('mixins', { startsExpr: ae }),
      _proto: Ne('proto', { startsExpr: ae }),
      _require: Ne('require', { startsExpr: ae }),
      _satisfies: Ne('satisfies', { startsExpr: ae }),
      _keyof: Ne('keyof', { startsExpr: ae }),
      _readonly: Ne('readonly', { startsExpr: ae }),
      _unique: Ne('unique', { startsExpr: ae }),
      _abstract: Ne('abstract', { startsExpr: ae }),
      _declare: Ne('declare', { startsExpr: ae }),
      _enum: Ne('enum', { startsExpr: ae }),
      _module: Ne('module', { startsExpr: ae }),
      _namespace: Ne('namespace', { startsExpr: ae }),
      _interface: Ne('interface', { startsExpr: ae }),
      _type: Ne('type', { startsExpr: ae }),
      _opaque: Ne('opaque', { startsExpr: ae }),
      name: ge('name', { startsExpr: ae }),
      string: ge('string', { startsExpr: ae }),
      num: ge('num', { startsExpr: ae }),
      bigint: ge('bigint', { startsExpr: ae }),
      decimal: ge('decimal', { startsExpr: ae }),
      regexp: ge('regexp', { startsExpr: ae }),
      privateName: ge('#name', { startsExpr: ae }),
      eof: ge('eof'),
      jsxName: ge('jsxName'),
      jsxText: ge('jsxText', { beforeExpr: !0 }),
      jsxTagStart: ge('jsxTagStart', { startsExpr: !0 }),
      jsxTagEnd: ge('jsxTagEnd'),
      placeholder: ge('%%', { startsExpr: !0 }),
    }
    function Ve(t) {
      return t >= 93 && t <= 132
    }
    function WC(t) {
      return t <= 92
    }
    function Hs(t) {
      return t >= 58 && t <= 132
    }
    function Gg(t) {
      return t >= 58 && t <= 136
    }
    function zC(t) {
      return Sh[t]
    }
    function xh(t) {
      return Th[t]
    }
    function JC(t) {
      return t >= 29 && t <= 33
    }
    function Wg(t) {
      return t >= 129 && t <= 131
    }
    function YC(t) {
      return t >= 90 && t <= 92
    }
    function Ah(t) {
      return t >= 58 && t <= 92
    }
    function QC(t) {
      return t >= 39 && t <= 59
    }
    function ZC(t) {
      return t === 34
    }
    function ev(t) {
      return _h[t]
    }
    function tv(t) {
      return t >= 121 && t <= 123
    }
    function sv(t) {
      return t >= 124 && t <= 130
    }
    function Zi(t) {
      return bh[t]
    }
    function Lu(t) {
      return Eh[t]
    }
    function iv(t) {
      return t === 57
    }
    function ku(t) {
      return t >= 24 && t <= 25
    }
    function mi(t) {
      return di[t]
    }
    ;(di[8].updateContext = (t) => {
      t.pop()
    }),
      (di[5].updateContext =
        di[7].updateContext =
        di[23].updateContext =
          (t) => {
            t.push(Ke.brace)
          }),
      (di[22].updateContext = (t) => {
        t[t.length - 1] === Ke.template ? t.pop() : t.push(Ke.template)
      }),
      (di[142].updateContext = (t) => {
        t.push(Ke.j_expr, Ke.j_oTag)
      })
    var Ph =
        '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
      zg =
        '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65',
      rv = new RegExp('[' + Ph + ']'),
      nv = new RegExp('[' + Ph + zg + ']')
    Ph = zg = null
    var Jg = [
        0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4,
        48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35,
        5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2,
        1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1,
        4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1,
        65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21,
        11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28,
        11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33,
        24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36,
        17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3,
        21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47,
        21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38,
        6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7,
        3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72,
        264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1,
        2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110,
        18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78,
        18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12,
        65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16,
        0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84,
        2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2,
        6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2,
        30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61,
        147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2,
        14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3,
        2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0,
        2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2,
        2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621,
        2467, 541, 1507, 4938, 6, 4191,
      ],
      av = [
        509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166,
        1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10,
        3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13,
        2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1,
        2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82,
        19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5,
        9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6,
        4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57,
        21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9,
        9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9,
        87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628,
        1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49,
        513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1,
        2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6,
        9, 4759, 9, 787719, 239,
      ]
    function Ch(t, e) {
      let s = 65536
      for (let i = 0, r = e.length; i < r; i += 2) {
        if (((s += e[i]), s > t)) return !1
        if (((s += e[i + 1]), s >= t)) return !0
      }
      return !1
    }
    function gi(t) {
      return t < 65
        ? t === 36
        : t <= 90
        ? !0
        : t < 97
        ? t === 95
        : t <= 122
        ? !0
        : t <= 65535
        ? t >= 170 && rv.test(String.fromCharCode(t))
        : Ch(t, Jg)
    }
    function Fn(t) {
      return t < 48
        ? t === 36
        : t < 58
        ? !0
        : t < 65
        ? !1
        : t <= 90
        ? !0
        : t < 97
        ? t === 95
        : t <= 122
        ? !0
        : t <= 65535
        ? t >= 170 && nv.test(String.fromCharCode(t))
        : Ch(t, Jg) || Ch(t, av)
    }
    var vh = {
        keyword: [
          'break',
          'case',
          'catch',
          'continue',
          'debugger',
          'default',
          'do',
          'else',
          'finally',
          'for',
          'function',
          'if',
          'return',
          'switch',
          'throw',
          'try',
          'var',
          'const',
          'while',
          'with',
          'new',
          'this',
          'super',
          'class',
          'extends',
          'export',
          'import',
          'null',
          'true',
          'false',
          'in',
          'instanceof',
          'typeof',
          'void',
          'delete',
        ],
        strict: [
          'implements',
          'interface',
          'let',
          'package',
          'private',
          'protected',
          'public',
          'static',
          'yield',
        ],
        strictBind: ['eval', 'arguments'],
      },
      ov = new Set(vh.keyword),
      uv = new Set(vh.strict),
      lv = new Set(vh.strictBind)
    function Yg(t, e) {
      return (e && t === 'await') || t === 'enum'
    }
    function Qg(t, e) {
      return Yg(t, e) || uv.has(t)
    }
    function Zg(t) {
      return lv.has(t)
    }
    function e1(t, e) {
      return Qg(t, e) || Zg(t)
    }
    function cv(t) {
      return ov.has(t)
    }
    function fv(t, e, s) {
      return t === 64 && e === 64 && gi(s)
    }
    var hv = new Set([
      'break',
      'case',
      'catch',
      'continue',
      'debugger',
      'default',
      'do',
      'else',
      'finally',
      'for',
      'function',
      'if',
      'return',
      'switch',
      'throw',
      'try',
      'var',
      'const',
      'while',
      'with',
      'new',
      'this',
      'super',
      'class',
      'extends',
      'export',
      'import',
      'null',
      'true',
      'false',
      'in',
      'instanceof',
      'typeof',
      'void',
      'delete',
      'implements',
      'interface',
      'let',
      'package',
      'private',
      'protected',
      'public',
      'static',
      'yield',
      'eval',
      'arguments',
      'enum',
      'await',
    ])
    function pv(t) {
      return hv.has(t)
    }
    var Du = class {
        constructor(e) {
          ;(this.flags = 0),
            (this.names = new Map()),
            (this.firstLexicalName = ''),
            (this.flags = e)
        }
      },
      Fu = class {
        constructor(e, s) {
          ;(this.parser = void 0),
            (this.scopeStack = []),
            (this.inModule = void 0),
            (this.undefinedExports = new Map()),
            (this.parser = e),
            (this.inModule = s)
        }
        get inTopLevel() {
          return (this.currentScope().flags & 1) > 0
        }
        get inFunction() {
          return (this.currentVarScopeFlags() & 2) > 0
        }
        get allowSuper() {
          return (this.currentThisScopeFlags() & 16) > 0
        }
        get allowDirectSuper() {
          return (this.currentThisScopeFlags() & 32) > 0
        }
        get inClass() {
          return (this.currentThisScopeFlags() & 64) > 0
        }
        get inClassAndNotInNonArrowFunction() {
          let e = this.currentThisScopeFlags()
          return (e & 64) > 0 && (e & 2) == 0
        }
        get inStaticBlock() {
          for (let e = this.scopeStack.length - 1; ; e--) {
            let { flags: s } = this.scopeStack[e]
            if (s & 128) return !0
            if (s & (387 | 64)) return !1
          }
        }
        get inNonArrowFunction() {
          return (this.currentThisScopeFlags() & 2) > 0
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope())
        }
        createScope(e) {
          return new Du(e)
        }
        enter(e) {
          this.scopeStack.push(this.createScope(e))
        }
        exit() {
          return this.scopeStack.pop().flags
        }
        treatFunctionsAsVarInScope(e) {
          return !!(
            e.flags & (2 | 128) ||
            (!this.parser.inModule && e.flags & 1)
          )
        }
        declareName(e, s, i) {
          let r = this.currentScope()
          if (s & 8 || s & 16) {
            this.checkRedeclarationInScope(r, e, s, i)
            let n = r.names.get(e) || 0
            s & 16
              ? (n = n | 4)
              : (r.firstLexicalName || (r.firstLexicalName = e), (n = n | 2)),
              r.names.set(e, n),
              s & 8 && this.maybeExportDefined(r, e)
          } else if (s & 4)
            for (
              let n = this.scopeStack.length - 1;
              n >= 0 &&
              ((r = this.scopeStack[n]),
              this.checkRedeclarationInScope(r, e, s, i),
              r.names.set(e, (r.names.get(e) || 0) | 1),
              this.maybeExportDefined(r, e),
              !(r.flags & 387));
              --n
            );
          this.parser.inModule && r.flags & 1 && this.undefinedExports.delete(e)
        }
        maybeExportDefined(e, s) {
          this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(s)
        }
        checkRedeclarationInScope(e, s, i, r) {
          this.isRedeclaredInScope(e, s, i) &&
            this.parser.raise(R.VarRedeclaration, r, { identifierName: s })
        }
        isRedeclaredInScope(e, s, i) {
          if (!(i & 1)) return !1
          if (i & 8) return e.names.has(s)
          let r = e.names.get(s)
          return i & 16
            ? (r & 2) > 0 ||
                (!this.treatFunctionsAsVarInScope(e) && (r & 1) > 0)
            : ((r & 2) > 0 && !(e.flags & 8 && e.firstLexicalName === s)) ||
                (!this.treatFunctionsAsVarInScope(e) && (r & 4) > 0)
        }
        checkLocalExport(e) {
          let { name: s } = e
          this.scopeStack[0].names.has(s) ||
            this.undefinedExports.set(s, e.loc.start)
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1]
        }
        currentVarScopeFlags() {
          for (let e = this.scopeStack.length - 1; ; e--) {
            let { flags: s } = this.scopeStack[e]
            if (s & 387) return s
          }
        }
        currentThisScopeFlags() {
          for (let e = this.scopeStack.length - 1; ; e--) {
            let { flags: s } = this.scopeStack[e]
            if (s & (387 | 64) && !(s & 4)) return s
          }
        }
      },
      t1 = class extends Du {
        constructor(...e) {
          super(...e)
          this.declareFunctions = new Set()
        }
      },
      s1 = class extends Fu {
        createScope(e) {
          return new t1(e)
        }
        declareName(e, s, i) {
          let r = this.currentScope()
          if (s & 2048) {
            this.checkRedeclarationInScope(r, e, s, i),
              this.maybeExportDefined(r, e),
              r.declareFunctions.add(e)
            return
          }
          super.declareName(e, s, i)
        }
        isRedeclaredInScope(e, s, i) {
          if (super.isRedeclaredInScope(e, s, i)) return !0
          if (i & 2048 && !e.declareFunctions.has(s)) {
            let r = e.names.get(s)
            return (r & 4) > 0 || (r & 2) > 0
          }
          return !1
        }
        checkLocalExport(e) {
          this.scopeStack[0].declareFunctions.has(e.name) ||
            super.checkLocalExport(e)
        }
      },
      i1 = class {
        constructor() {
          ;(this.sawUnambiguousESM = !1),
            (this.ambiguousScriptDifferentAst = !1)
        }
        hasPlugin(e) {
          if (typeof e == 'string') return this.plugins.has(e)
          {
            let [s, i] = e
            if (!this.hasPlugin(s)) return !1
            let r = this.plugins.get(s)
            for (let n of Object.keys(i))
              if ((r == null ? void 0 : r[n]) !== i[n]) return !1
            return !0
          }
        }
        getPluginOption(e, s) {
          var i
          return (i = this.plugins.get(e)) == null ? void 0 : i[s]
        }
      }
    function r1(t, e) {
      t.trailingComments === void 0
        ? (t.trailingComments = e)
        : t.trailingComments.unshift(...e)
    }
    function dv(t, e) {
      t.leadingComments === void 0
        ? (t.leadingComments = e)
        : t.leadingComments.unshift(...e)
    }
    function Fa(t, e) {
      t.innerComments === void 0
        ? (t.innerComments = e)
        : t.innerComments.unshift(...e)
    }
    function Ba(t, e, s) {
      let i = null,
        r = e.length
      for (; i === null && r > 0; ) i = e[--r]
      i === null || i.start > s.start ? Fa(t, s.comments) : r1(i, s.comments)
    }
    var n1 = class extends i1 {
        addComment(e) {
          this.filename && (e.loc.filename = this.filename)
          let { commentsLen: s } = this.state
          this.comments.length !== s && (this.comments.length = s),
            this.comments.push(e),
            this.state.commentsLen++
        }
        processComment(e) {
          let { commentStack: s } = this.state,
            i = s.length
          if (i === 0) return
          let r = i - 1,
            n = s[r]
          n.start === e.end && ((n.leadingNode = e), r--)
          let { start: a } = e
          for (; r >= 0; r--) {
            let o = s[r],
              u = o.end
            if (u > a)
              (o.containingNode = e), this.finalizeComment(o), s.splice(r, 1)
            else {
              u === a && (o.trailingNode = e)
              break
            }
          }
        }
        finalizeComment(e) {
          let { comments: s } = e
          if (e.leadingNode !== null || e.trailingNode !== null)
            e.leadingNode !== null && r1(e.leadingNode, s),
              e.trailingNode !== null && dv(e.trailingNode, s)
          else {
            let { containingNode: i, start: r } = e
            if (this.input.charCodeAt(r - 1) === 44)
              switch (i.type) {
                case 'ObjectExpression':
                case 'ObjectPattern':
                case 'RecordExpression':
                  Ba(i, i.properties, e)
                  break
                case 'CallExpression':
                case 'OptionalCallExpression':
                  Ba(i, i.arguments, e)
                  break
                case 'FunctionDeclaration':
                case 'FunctionExpression':
                case 'ArrowFunctionExpression':
                case 'ObjectMethod':
                case 'ClassMethod':
                case 'ClassPrivateMethod':
                  Ba(i, i.params, e)
                  break
                case 'ArrayExpression':
                case 'ArrayPattern':
                case 'TupleExpression':
                  Ba(i, i.elements, e)
                  break
                case 'ExportNamedDeclaration':
                case 'ImportDeclaration':
                  Ba(i, i.specifiers, e)
                  break
                default:
                  Fa(i, s)
              }
            else Fa(i, s)
          }
        }
        finalizeRemainingComments() {
          let { commentStack: e } = this.state
          for (let s = e.length - 1; s >= 0; s--) this.finalizeComment(e[s])
          this.state.commentStack = []
        }
        resetPreviousNodeTrailingComments(e) {
          let { commentStack: s } = this.state,
            { length: i } = s
          if (i === 0) return
          let r = s[i - 1]
          r.leadingNode === e && (r.leadingNode = null)
        }
        resetPreviousIdentifierLeadingComments(e) {
          let { commentStack: s } = this.state,
            { length: i } = s
          i !== 0 &&
            (s[i - 1].trailingNode === e
              ? (s[i - 1].trailingNode = null)
              : i >= 2 &&
                s[i - 2].trailingNode === e &&
                (s[i - 2].trailingNode = null))
        }
        takeSurroundingComments(e, s, i) {
          let { commentStack: r } = this.state,
            n = r.length
          if (n === 0) return
          let a = n - 1
          for (; a >= 0; a--) {
            let o = r[a],
              u = o.end
            if (o.start === i) o.leadingNode = e
            else if (u === s) o.trailingNode = e
            else if (u < s) break
          }
        }
      },
      a1 = /\r\n?|[\n\u2028\u2029]/,
      Bu = new RegExp(a1.source, 'g')
    function Va(t) {
      switch (t) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return !0
        default:
          return !1
      }
    }
    var Nh = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
      Vu = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g,
      o1 = new RegExp(
        '(?=(' +
          Vu.source +
          '))\\1' +
          /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
        'y'
      )
    function mv(t) {
      switch (t) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return !0
        default:
          return !1
      }
    }
    var Uu = class {
        constructor() {
          ;(this.flags = 1024),
            (this.curLine = void 0),
            (this.lineStart = void 0),
            (this.startLoc = void 0),
            (this.endLoc = void 0),
            (this.errors = []),
            (this.potentialArrowAt = -1),
            (this.noArrowAt = []),
            (this.noArrowParamsConversionAt = []),
            (this.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null,
            }),
            (this.labels = []),
            (this.commentsLen = 0),
            (this.commentStack = []),
            (this.pos = 0),
            (this.type = 139),
            (this.value = null),
            (this.start = 0),
            (this.end = 0),
            (this.lastTokEndLoc = null),
            (this.lastTokStartLoc = null),
            (this.context = [Ke.brace]),
            (this.firstInvalidTemplateEscapePos = null),
            (this.strictErrors = new Map()),
            (this.tokensLength = 0)
        }
        get strict() {
          return (this.flags & 1) > 0
        }
        set strict(e) {
          e ? (this.flags |= 1) : (this.flags &= -2)
        }
        init({ strictMode: e, sourceType: s, startLine: i, startColumn: r }) {
          ;(this.strict = e === !1 ? !1 : e === !0 ? !0 : s === 'module'),
            (this.curLine = i),
            (this.lineStart = -r),
            (this.startLoc = this.endLoc = new hi(i, r, 0))
        }
        get maybeInArrowParameters() {
          return (this.flags & 2) > 0
        }
        set maybeInArrowParameters(e) {
          e ? (this.flags |= 2) : (this.flags &= -3)
        }
        get inType() {
          return (this.flags & 4) > 0
        }
        set inType(e) {
          e ? (this.flags |= 4) : (this.flags &= -5)
        }
        get noAnonFunctionType() {
          return (this.flags & 8) > 0
        }
        set noAnonFunctionType(e) {
          e ? (this.flags |= 8) : (this.flags &= -9)
        }
        get hasFlowComment() {
          return (this.flags & 16) > 0
        }
        set hasFlowComment(e) {
          e ? (this.flags |= 16) : (this.flags &= -17)
        }
        get isAmbientContext() {
          return (this.flags & 32) > 0
        }
        set isAmbientContext(e) {
          e ? (this.flags |= 32) : (this.flags &= -33)
        }
        get inAbstractClass() {
          return (this.flags & 64) > 0
        }
        set inAbstractClass(e) {
          e ? (this.flags |= 64) : (this.flags &= -65)
        }
        get inDisallowConditionalTypesContext() {
          return (this.flags & 128) > 0
        }
        set inDisallowConditionalTypesContext(e) {
          e ? (this.flags |= 128) : (this.flags &= -129)
        }
        get soloAwait() {
          return (this.flags & 256) > 0
        }
        set soloAwait(e) {
          e ? (this.flags |= 256) : (this.flags &= -257)
        }
        get inFSharpPipelineDirectBody() {
          return (this.flags & 512) > 0
        }
        set inFSharpPipelineDirectBody(e) {
          e ? (this.flags |= 512) : (this.flags &= -513)
        }
        get canStartJSXElement() {
          return (this.flags & 1024) > 0
        }
        set canStartJSXElement(e) {
          e ? (this.flags |= 1024) : (this.flags &= -1025)
        }
        get containsEsc() {
          return (this.flags & 2048) > 0
        }
        set containsEsc(e) {
          e ? (this.flags |= 2048) : (this.flags &= -2049)
        }
        curPosition() {
          return new hi(this.curLine, this.pos - this.lineStart, this.pos)
        }
        clone() {
          let e = new Uu()
          return (
            (e.flags = this.flags),
            (e.curLine = this.curLine),
            (e.lineStart = this.lineStart),
            (e.startLoc = this.startLoc),
            (e.endLoc = this.endLoc),
            (e.errors = this.errors.slice()),
            (e.potentialArrowAt = this.potentialArrowAt),
            (e.noArrowAt = this.noArrowAt.slice()),
            (e.noArrowParamsConversionAt =
              this.noArrowParamsConversionAt.slice()),
            (e.topicContext = this.topicContext),
            (e.labels = this.labels.slice()),
            (e.commentsLen = this.commentsLen),
            (e.commentStack = this.commentStack.slice()),
            (e.pos = this.pos),
            (e.type = this.type),
            (e.value = this.value),
            (e.start = this.start),
            (e.end = this.end),
            (e.lastTokEndLoc = this.lastTokEndLoc),
            (e.lastTokStartLoc = this.lastTokStartLoc),
            (e.context = this.context.slice()),
            (e.firstInvalidTemplateEscapePos =
              this.firstInvalidTemplateEscapePos),
            (e.strictErrors = this.strictErrors),
            (e.tokensLength = this.tokensLength),
            e
          )
        }
      },
      gv = function (e) {
        return e >= 48 && e <= 57
      },
      u1 = {
        decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: new Set([46, 88, 95, 120]),
      },
      Hu = {
        bin: (t) => t === 48 || t === 49,
        oct: (t) => t >= 48 && t <= 55,
        dec: (t) => t >= 48 && t <= 57,
        hex: (t) =>
          (t >= 48 && t <= 57) || (t >= 65 && t <= 70) || (t >= 97 && t <= 102),
      }
    function l1(t, e, s, i, r, n) {
      let a = s,
        o = i,
        u = r,
        l = '',
        c = null,
        f = s,
        { length: h } = e
      for (;;) {
        if (s >= h) {
          n.unterminated(a, o, u), (l += e.slice(f, s))
          break
        }
        let p = e.charCodeAt(s)
        if (yv(t, p, e, s)) {
          l += e.slice(f, s)
          break
        }
        if (p === 92) {
          l += e.slice(f, s)
          let m = bv(e, s, i, r, t === 'template', n)
          m.ch === null && !c
            ? (c = { pos: s, lineStart: i, curLine: r })
            : (l += m.ch),
            ({ pos: s, lineStart: i, curLine: r } = m),
            (f = s)
        } else
          p === 8232 || p === 8233
            ? (++s, ++r, (i = s))
            : p === 10 || p === 13
            ? t === 'template'
              ? ((l +=
                  e.slice(f, s) +
                  `
`),
                ++s,
                p === 13 && e.charCodeAt(s) === 10 && ++s,
                ++r,
                (f = i = s))
              : n.unterminated(a, o, u)
            : ++s
      }
      return {
        pos: s,
        str: l,
        firstInvalidLoc: c,
        lineStart: i,
        curLine: r,
        containsInvalid: !!c,
      }
    }
    function yv(t, e, s, i) {
      return t === 'template'
        ? e === 96 || (e === 36 && s.charCodeAt(i + 1) === 123)
        : e === (t === 'double' ? 34 : 39)
    }
    function bv(t, e, s, i, r, n) {
      let a = !r
      e++
      let o = (l) => ({ pos: e, ch: l, lineStart: s, curLine: i }),
        u = t.charCodeAt(e++)
      switch (u) {
        case 110:
          return o(`
`)
        case 114:
          return o('\r')
        case 120: {
          let l
          return (
            ({ code: l, pos: e } = Ih(t, e, s, i, 2, !1, a, n)),
            o(l === null ? null : String.fromCharCode(l))
          )
        }
        case 117: {
          let l
          return (
            ({ code: l, pos: e } = f1(t, e, s, i, a, n)),
            o(l === null ? null : String.fromCodePoint(l))
          )
        }
        case 116:
          return o('	')
        case 98:
          return o('\b')
        case 118:
          return o('\v')
        case 102:
          return o('\f')
        case 13:
          t.charCodeAt(e) === 10 && ++e
        case 10:
          ;(s = e), ++i
        case 8232:
        case 8233:
          return o('')
        case 56:
        case 57:
          if (r) return o(null)
          n.strictNumericEscape(e - 1, s, i)
        default:
          if (u >= 48 && u <= 55) {
            let l = e - 1,
              f = /^[0-7]+/.exec(t.slice(l, e + 2))[0],
              h = parseInt(f, 8)
            h > 255 && ((f = f.slice(0, -1)), (h = parseInt(f, 8))),
              (e += f.length - 1)
            let p = t.charCodeAt(e)
            if (f !== '0' || p === 56 || p === 57) {
              if (r) return o(null)
              n.strictNumericEscape(l, s, i)
            }
            return o(String.fromCharCode(h))
          }
          return o(String.fromCharCode(u))
      }
    }
    function Ih(t, e, s, i, r, n, a, o) {
      let u = e,
        l
      return (
        ({ n: l, pos: e } = c1(t, e, s, i, 16, r, n, !1, o, !a)),
        l === null && (a ? o.invalidEscapeSequence(u, s, i) : (e = u - 1)),
        { code: l, pos: e }
      )
    }
    function c1(t, e, s, i, r, n, a, o, u, l) {
      let c = e,
        f = r === 16 ? u1.hex : u1.decBinOct,
        h = r === 16 ? Hu.hex : r === 10 ? Hu.dec : r === 8 ? Hu.oct : Hu.bin,
        p = !1,
        m = 0
      for (let y = 0, x = n == null ? 1 / 0 : n; y < x; ++y) {
        let C = t.charCodeAt(e),
          E
        if (C === 95 && o !== 'bail') {
          let g = t.charCodeAt(e - 1),
            S = t.charCodeAt(e + 1)
          if (o) {
            if (Number.isNaN(S) || !h(S) || f.has(g) || f.has(S)) {
              if (l) return { n: null, pos: e }
              u.unexpectedNumericSeparator(e, s, i)
            }
          } else {
            if (l) return { n: null, pos: e }
            u.numericSeparatorInEscapeSequence(e, s, i)
          }
          ++e
          continue
        }
        if (
          (C >= 97
            ? (E = C - 97 + 10)
            : C >= 65
            ? (E = C - 65 + 10)
            : gv(C)
            ? (E = C - 48)
            : (E = 1 / 0),
          E >= r)
        ) {
          if (E <= 9 && l) return { n: null, pos: e }
          if (E <= 9 && u.invalidDigit(e, s, i, r)) E = 0
          else if (a) (E = 0), (p = !0)
          else break
        }
        ++e, (m = m * r + E)
      }
      return e === c || (n != null && e - c !== n) || p
        ? { n: null, pos: e }
        : { n: m, pos: e }
    }
    function f1(t, e, s, i, r, n) {
      let a = t.charCodeAt(e),
        o
      if (a === 123) {
        if (
          (++e,
          ({ code: o, pos: e } = Ih(
            t,
            e,
            s,
            i,
            t.indexOf('}', e) - e,
            !0,
            r,
            n
          )),
          ++e,
          o !== null && o > 1114111)
        )
          if (r) n.invalidCodePoint(e, s, i)
          else return { code: null, pos: e }
      } else ({ code: o, pos: e } = Ih(t, e, s, i, 4, !1, r, n))
      return { code: o, pos: e }
    }
    function Ua(t, e, s) {
      return new hi(s, t - e, t)
    }
    var Ev = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
      yi = class {
        constructor(e) {
          ;(this.type = e.type),
            (this.value = e.value),
            (this.start = e.start),
            (this.end = e.end),
            (this.loc = new Ra(e.startLoc, e.endLoc))
        }
      },
      h1 = class extends n1 {
        constructor(e, s) {
          super()
          ;(this.isLookahead = void 0),
            (this.tokens = []),
            (this.errorHandlers_readInt = {
              invalidDigit: (i, r, n, a) =>
                this.options.errorRecovery
                  ? (this.raise(R.InvalidDigit, Ua(i, r, n), { radix: a }), !0)
                  : !1,
              numericSeparatorInEscapeSequence: this.errorBuilder(
                R.NumericSeparatorInEscapeSequence
              ),
              unexpectedNumericSeparator: this.errorBuilder(
                R.UnexpectedNumericSeparator
              ),
            }),
            (this.errorHandlers_readCodePoint = Object.assign(
              {},
              this.errorHandlers_readInt,
              {
                invalidEscapeSequence: this.errorBuilder(
                  R.InvalidEscapeSequence
                ),
                invalidCodePoint: this.errorBuilder(R.InvalidCodePoint),
              }
            )),
            (this.errorHandlers_readStringContents_string = Object.assign(
              {},
              this.errorHandlers_readCodePoint,
              {
                strictNumericEscape: (i, r, n) => {
                  this.recordStrictModeErrors(
                    R.StrictNumericEscape,
                    Ua(i, r, n)
                  )
                },
                unterminated: (i, r, n) => {
                  throw this.raise(R.UnterminatedString, Ua(i - 1, r, n))
                },
              }
            )),
            (this.errorHandlers_readStringContents_template = Object.assign(
              {},
              this.errorHandlers_readCodePoint,
              {
                strictNumericEscape: this.errorBuilder(R.StrictNumericEscape),
                unterminated: (i, r, n) => {
                  throw this.raise(R.UnterminatedTemplate, Ua(i, r, n))
                },
              }
            )),
            (this.state = new Uu()),
            this.state.init(e),
            (this.input = s),
            (this.length = s.length),
            (this.comments = []),
            (this.isLookahead = !1)
        }
        pushToken(e) {
          ;(this.tokens.length = this.state.tokensLength),
            this.tokens.push(e),
            ++this.state.tokensLength
        }
        next() {
          this.checkKeywordEscapes(),
            this.options.tokens && this.pushToken(new yi(this.state)),
            (this.state.lastTokEndLoc = this.state.endLoc),
            (this.state.lastTokStartLoc = this.state.startLoc),
            this.nextToken()
        }
        eat(e) {
          return this.match(e) ? (this.next(), !0) : !1
        }
        match(e) {
          return this.state.type === e
        }
        createLookaheadState(e) {
          return {
            pos: e.pos,
            value: null,
            type: e.type,
            start: e.start,
            end: e.end,
            context: [this.curContext()],
            inType: e.inType,
            startLoc: e.startLoc,
            lastTokEndLoc: e.lastTokEndLoc,
            curLine: e.curLine,
            lineStart: e.lineStart,
            curPosition: e.curPosition,
          }
        }
        lookahead() {
          let e = this.state
          ;(this.state = this.createLookaheadState(e)),
            (this.isLookahead = !0),
            this.nextToken(),
            (this.isLookahead = !1)
          let s = this.state
          return (this.state = e), s
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos)
        }
        nextTokenStartSince(e) {
          return (Nh.lastIndex = e), Nh.test(this.input) ? Nh.lastIndex : e
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart())
        }
        nextTokenInLineStart() {
          return this.nextTokenInLineStartSince(this.state.pos)
        }
        nextTokenInLineStartSince(e) {
          return (Vu.lastIndex = e), Vu.test(this.input) ? Vu.lastIndex : e
        }
        lookaheadInLineCharCode() {
          return this.input.charCodeAt(this.nextTokenInLineStart())
        }
        codePointAtPos(e) {
          let s = this.input.charCodeAt(e)
          if ((s & 64512) == 55296 && ++e < this.input.length) {
            let i = this.input.charCodeAt(e)
            ;(i & 64512) == 56320 &&
              (s = 65536 + ((s & 1023) << 10) + (i & 1023))
          }
          return s
        }
        setStrict(e) {
          ;(this.state.strict = e),
            e &&
              (this.state.strictErrors.forEach(([s, i]) => this.raise(s, i)),
              this.state.strictErrors.clear())
        }
        curContext() {
          return this.state.context[this.state.context.length - 1]
        }
        nextToken() {
          if (
            (this.skipSpace(),
            (this.state.start = this.state.pos),
            this.isLookahead ||
              (this.state.startLoc = this.state.curPosition()),
            this.state.pos >= this.length)
          ) {
            this.finishToken(139)
            return
          }
          this.getTokenFromCode(this.codePointAtPos(this.state.pos))
        }
        skipBlockComment(e) {
          let s
          this.isLookahead || (s = this.state.curPosition())
          let i = this.state.pos,
            r = this.input.indexOf(e, i + 2)
          if (r === -1)
            throw this.raise(R.UnterminatedComment, this.state.curPosition())
          for (
            this.state.pos = r + e.length, Bu.lastIndex = i + 2;
            Bu.test(this.input) && Bu.lastIndex <= r;

          )
            ++this.state.curLine, (this.state.lineStart = Bu.lastIndex)
          if (this.isLookahead) return
          let n = {
            type: 'CommentBlock',
            value: this.input.slice(i + 2, r),
            start: i,
            end: r + e.length,
            loc: new Ra(s, this.state.curPosition()),
          }
          return this.options.tokens && this.pushToken(n), n
        }
        skipLineComment(e) {
          let s = this.state.pos,
            i
          this.isLookahead || (i = this.state.curPosition())
          let r = this.input.charCodeAt((this.state.pos += e))
          if (this.state.pos < this.length)
            for (; !Va(r) && ++this.state.pos < this.length; )
              r = this.input.charCodeAt(this.state.pos)
          if (this.isLookahead) return
          let n = this.state.pos,
            a = this.input.slice(s + e, n),
            o = {
              type: 'CommentLine',
              value: a,
              start: s,
              end: n,
              loc: new Ra(i, this.state.curPosition()),
            }
          return this.options.tokens && this.pushToken(o), o
        }
        skipSpace() {
          let e = this.state.pos,
            s = []
          e: for (; this.state.pos < this.length; ) {
            let i = this.input.charCodeAt(this.state.pos)
            switch (i) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos
                break
              case 13:
                this.input.charCodeAt(this.state.pos + 1) === 10 &&
                  ++this.state.pos
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos,
                  ++this.state.curLine,
                  (this.state.lineStart = this.state.pos)
                break
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    let r = this.skipBlockComment('*/')
                    r !== void 0 &&
                      (this.addComment(r),
                      this.options.attachComment && s.push(r))
                    break
                  }
                  case 47: {
                    let r = this.skipLineComment(2)
                    r !== void 0 &&
                      (this.addComment(r),
                      this.options.attachComment && s.push(r))
                    break
                  }
                  default:
                    break e
                }
                break
              default:
                if (mv(i)) ++this.state.pos
                else if (i === 45 && !this.inModule && this.options.annexB) {
                  let r = this.state.pos
                  if (
                    this.input.charCodeAt(r + 1) === 45 &&
                    this.input.charCodeAt(r + 2) === 62 &&
                    (e === 0 || this.state.lineStart > e)
                  ) {
                    let n = this.skipLineComment(3)
                    n !== void 0 &&
                      (this.addComment(n),
                      this.options.attachComment && s.push(n))
                  } else break e
                } else if (i === 60 && !this.inModule && this.options.annexB) {
                  let r = this.state.pos
                  if (
                    this.input.charCodeAt(r + 1) === 33 &&
                    this.input.charCodeAt(r + 2) === 45 &&
                    this.input.charCodeAt(r + 3) === 45
                  ) {
                    let n = this.skipLineComment(4)
                    n !== void 0 &&
                      (this.addComment(n),
                      this.options.attachComment && s.push(n))
                  } else break e
                } else break e
            }
          }
          if (s.length > 0) {
            let i = this.state.pos,
              r = {
                start: e,
                end: i,
                comments: s,
                leadingNode: null,
                trailingNode: null,
                containingNode: null,
              }
            this.state.commentStack.push(r)
          }
        }
        finishToken(e, s) {
          ;(this.state.end = this.state.pos),
            (this.state.endLoc = this.state.curPosition())
          let i = this.state.type
          ;(this.state.type = e),
            (this.state.value = s),
            this.isLookahead || this.updateContext(i)
        }
        replaceToken(e) {
          ;(this.state.type = e), this.updateContext()
        }
        readToken_numberSign() {
          if (this.state.pos === 0 && this.readToken_interpreter()) return
          let e = this.state.pos + 1,
            s = this.codePointAtPos(e)
          if (s >= 48 && s <= 57)
            throw this.raise(
              R.UnexpectedDigitAfterHash,
              this.state.curPosition()
            )
          if (s === 123 || (s === 91 && this.hasPlugin('recordAndTuple'))) {
            if (
              (this.expectPlugin('recordAndTuple'),
              this.getPluginOption('recordAndTuple', 'syntaxType') === 'bar')
            )
              throw this.raise(
                s === 123
                  ? R.RecordExpressionHashIncorrectStartSyntaxType
                  : R.TupleExpressionHashIncorrectStartSyntaxType,
                this.state.curPosition()
              )
            ;(this.state.pos += 2),
              s === 123 ? this.finishToken(7) : this.finishToken(1)
          } else
            gi(s)
              ? (++this.state.pos, this.finishToken(138, this.readWord1(s)))
              : s === 92
              ? (++this.state.pos, this.finishToken(138, this.readWord1()))
              : this.finishOp(27, 1)
        }
        readToken_dot() {
          let e = this.input.charCodeAt(this.state.pos + 1)
          if (e >= 48 && e <= 57) {
            this.readNumber(!0)
            return
          }
          e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46
            ? ((this.state.pos += 3), this.finishToken(21))
            : (++this.state.pos, this.finishToken(16))
        }
        readToken_slash() {
          this.input.charCodeAt(this.state.pos + 1) === 61
            ? this.finishOp(31, 2)
            : this.finishOp(56, 1)
        }
        readToken_interpreter() {
          if (this.state.pos !== 0 || this.length < 2) return !1
          let e = this.input.charCodeAt(this.state.pos + 1)
          if (e !== 33) return !1
          let s = this.state.pos
          for (this.state.pos += 1; !Va(e) && ++this.state.pos < this.length; )
            e = this.input.charCodeAt(this.state.pos)
          let i = this.input.slice(s + 2, this.state.pos)
          return this.finishToken(28, i), !0
        }
        readToken_mult_modulo(e) {
          let s = e === 42 ? 55 : 54,
            i = 1,
            r = this.input.charCodeAt(this.state.pos + 1)
          e === 42 &&
            r === 42 &&
            (i++, (r = this.input.charCodeAt(this.state.pos + 2)), (s = 57)),
            r === 61 && !this.state.inType && (i++, (s = e === 37 ? 33 : 30)),
            this.finishOp(s, i)
        }
        readToken_pipe_amp(e) {
          let s = this.input.charCodeAt(this.state.pos + 1)
          if (s === e) {
            this.input.charCodeAt(this.state.pos + 2) === 61
              ? this.finishOp(30, 3)
              : this.finishOp(e === 124 ? 41 : 42, 2)
            return
          }
          if (e === 124) {
            if (s === 62) {
              this.finishOp(39, 2)
              return
            }
            if (this.hasPlugin('recordAndTuple') && s === 125) {
              if (
                this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
              )
                throw this.raise(
                  R.RecordExpressionBarIncorrectEndSyntaxType,
                  this.state.curPosition()
                )
              ;(this.state.pos += 2), this.finishToken(9)
              return
            }
            if (this.hasPlugin('recordAndTuple') && s === 93) {
              if (
                this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
              )
                throw this.raise(
                  R.TupleExpressionBarIncorrectEndSyntaxType,
                  this.state.curPosition()
                )
              ;(this.state.pos += 2), this.finishToken(4)
              return
            }
          }
          if (s === 61) {
            this.finishOp(30, 2)
            return
          }
          this.finishOp(e === 124 ? 43 : 45, 1)
        }
        readToken_caret() {
          let e = this.input.charCodeAt(this.state.pos + 1)
          e === 61 && !this.state.inType
            ? this.finishOp(32, 2)
            : e === 94 &&
              this.hasPlugin([
                'pipelineOperator',
                { proposal: 'hack', topicToken: '^^' },
              ])
            ? (this.finishOp(37, 2),
              this.input.codePointAt(this.state.pos) === 94 &&
                this.unexpected())
            : this.finishOp(44, 1)
        }
        readToken_atSign() {
          this.input.charCodeAt(this.state.pos + 1) === 64 &&
          this.hasPlugin([
            'pipelineOperator',
            { proposal: 'hack', topicToken: '@@' },
          ])
            ? this.finishOp(38, 2)
            : this.finishOp(26, 1)
        }
        readToken_plus_min(e) {
          let s = this.input.charCodeAt(this.state.pos + 1)
          if (s === e) {
            this.finishOp(34, 2)
            return
          }
          s === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1)
        }
        readToken_lt() {
          let { pos: e } = this.state,
            s = this.input.charCodeAt(e + 1)
          if (s === 60) {
            if (this.input.charCodeAt(e + 2) === 61) {
              this.finishOp(30, 3)
              return
            }
            this.finishOp(51, 2)
            return
          }
          if (s === 61) {
            this.finishOp(49, 2)
            return
          }
          this.finishOp(47, 1)
        }
        readToken_gt() {
          let { pos: e } = this.state,
            s = this.input.charCodeAt(e + 1)
          if (s === 62) {
            let i = this.input.charCodeAt(e + 2) === 62 ? 3 : 2
            if (this.input.charCodeAt(e + i) === 61) {
              this.finishOp(30, i + 1)
              return
            }
            this.finishOp(52, i)
            return
          }
          if (s === 61) {
            this.finishOp(49, 2)
            return
          }
          this.finishOp(48, 1)
        }
        readToken_eq_excl(e) {
          let s = this.input.charCodeAt(this.state.pos + 1)
          if (s === 61) {
            this.finishOp(
              46,
              this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2
            )
            return
          }
          if (e === 61 && s === 62) {
            ;(this.state.pos += 2), this.finishToken(19)
            return
          }
          this.finishOp(e === 61 ? 29 : 35, 1)
        }
        readToken_question() {
          let e = this.input.charCodeAt(this.state.pos + 1),
            s = this.input.charCodeAt(this.state.pos + 2)
          e === 63
            ? s === 61
              ? this.finishOp(30, 3)
              : this.finishOp(40, 2)
            : e === 46 && !(s >= 48 && s <= 57)
            ? ((this.state.pos += 2), this.finishToken(18))
            : (++this.state.pos, this.finishToken(17))
        }
        getTokenFromCode(e) {
          switch (e) {
            case 46:
              this.readToken_dot()
              return
            case 40:
              ++this.state.pos, this.finishToken(10)
              return
            case 41:
              ++this.state.pos, this.finishToken(11)
              return
            case 59:
              ++this.state.pos, this.finishToken(13)
              return
            case 44:
              ++this.state.pos, this.finishToken(12)
              return
            case 91:
              if (
                this.hasPlugin('recordAndTuple') &&
                this.input.charCodeAt(this.state.pos + 1) === 124
              ) {
                if (
                  this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
                )
                  throw this.raise(
                    R.TupleExpressionBarIncorrectStartSyntaxType,
                    this.state.curPosition()
                  )
                ;(this.state.pos += 2), this.finishToken(2)
              } else ++this.state.pos, this.finishToken(0)
              return
            case 93:
              ++this.state.pos, this.finishToken(3)
              return
            case 123:
              if (
                this.hasPlugin('recordAndTuple') &&
                this.input.charCodeAt(this.state.pos + 1) === 124
              ) {
                if (
                  this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
                )
                  throw this.raise(
                    R.RecordExpressionBarIncorrectStartSyntaxType,
                    this.state.curPosition()
                  )
                ;(this.state.pos += 2), this.finishToken(6)
              } else ++this.state.pos, this.finishToken(5)
              return
            case 125:
              ++this.state.pos, this.finishToken(8)
              return
            case 58:
              this.hasPlugin('functionBind') &&
              this.input.charCodeAt(this.state.pos + 1) === 58
                ? this.finishOp(15, 2)
                : (++this.state.pos, this.finishToken(14))
              return
            case 63:
              this.readToken_question()
              return
            case 96:
              this.readTemplateToken()
              return
            case 48: {
              let s = this.input.charCodeAt(this.state.pos + 1)
              if (s === 120 || s === 88) {
                this.readRadixNumber(16)
                return
              }
              if (s === 111 || s === 79) {
                this.readRadixNumber(8)
                return
              }
              if (s === 98 || s === 66) {
                this.readRadixNumber(2)
                return
              }
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              this.readNumber(!1)
              return
            case 34:
            case 39:
              this.readString(e)
              return
            case 47:
              this.readToken_slash()
              return
            case 37:
            case 42:
              this.readToken_mult_modulo(e)
              return
            case 124:
            case 38:
              this.readToken_pipe_amp(e)
              return
            case 94:
              this.readToken_caret()
              return
            case 43:
            case 45:
              this.readToken_plus_min(e)
              return
            case 60:
              this.readToken_lt()
              return
            case 62:
              this.readToken_gt()
              return
            case 61:
            case 33:
              this.readToken_eq_excl(e)
              return
            case 126:
              this.finishOp(36, 1)
              return
            case 64:
              this.readToken_atSign()
              return
            case 35:
              this.readToken_numberSign()
              return
            case 92:
              this.readWord()
              return
            default:
              if (gi(e)) {
                this.readWord(e)
                return
              }
          }
          throw this.raise(
            R.InvalidOrUnexpectedToken,
            this.state.curPosition(),
            { unexpected: String.fromCodePoint(e) }
          )
        }
        finishOp(e, s) {
          let i = this.input.slice(this.state.pos, this.state.pos + s)
          ;(this.state.pos += s), this.finishToken(e, i)
        }
        readRegexp() {
          let e = this.state.startLoc,
            s = this.state.start + 1,
            i,
            r,
            { pos: n } = this.state
          for (; ; ++n) {
            if (n >= this.length)
              throw this.raise(R.UnterminatedRegExp, zt(e, 1))
            let l = this.input.charCodeAt(n)
            if (Va(l)) throw this.raise(R.UnterminatedRegExp, zt(e, 1))
            if (i) i = !1
            else {
              if (l === 91) r = !0
              else if (l === 93 && r) r = !1
              else if (l === 47 && !r) break
              i = l === 92
            }
          }
          let a = this.input.slice(s, n)
          ++n
          let o = '',
            u = () => zt(e, n + 2 - s)
          for (; n < this.length; ) {
            let l = this.codePointAtPos(n),
              c = String.fromCharCode(l)
            if (Ev.has(l))
              l === 118
                ? o.includes('u') &&
                  this.raise(R.IncompatibleRegExpUVFlags, u())
                : l === 117 &&
                  o.includes('v') &&
                  this.raise(R.IncompatibleRegExpUVFlags, u()),
                o.includes(c) && this.raise(R.DuplicateRegExpFlags, u())
            else if (Fn(l) || l === 92) this.raise(R.MalformedRegExpFlags, u())
            else break
            ++n, (o += c)
          }
          ;(this.state.pos = n), this.finishToken(137, { pattern: a, flags: o })
        }
        readInt(e, s, i = !1, r = !0) {
          let { n, pos: a } = c1(
            this.input,
            this.state.pos,
            this.state.lineStart,
            this.state.curLine,
            e,
            s,
            i,
            r,
            this.errorHandlers_readInt,
            !1
          )
          return (this.state.pos = a), n
        }
        readRadixNumber(e) {
          let s = this.state.curPosition(),
            i = !1
          this.state.pos += 2
          let r = this.readInt(e)
          r == null && this.raise(R.InvalidDigit, zt(s, 2), { radix: e })
          let n = this.input.charCodeAt(this.state.pos)
          if (n === 110) ++this.state.pos, (i = !0)
          else if (n === 109) throw this.raise(R.InvalidDecimal, s)
          if (gi(this.codePointAtPos(this.state.pos)))
            throw this.raise(R.NumberIdentifier, this.state.curPosition())
          if (i) {
            let a = this.input
              .slice(s.index, this.state.pos)
              .replace(/[_n]/g, '')
            this.finishToken(135, a)
            return
          }
          this.finishToken(134, r)
        }
        readNumber(e) {
          let s = this.state.pos,
            i = this.state.curPosition(),
            r = !1,
            n = !1,
            a = !1,
            o = !1,
            u = !1
          !e &&
            this.readInt(10) === null &&
            this.raise(R.InvalidNumber, this.state.curPosition())
          let l = this.state.pos - s >= 2 && this.input.charCodeAt(s) === 48
          if (l) {
            let p = this.input.slice(s, this.state.pos)
            if (
              (this.recordStrictModeErrors(R.StrictOctalLiteral, i),
              !this.state.strict)
            ) {
              let m = p.indexOf('_')
              m > 0 && this.raise(R.ZeroDigitNumericSeparator, zt(i, m))
            }
            u = l && !/[89]/.test(p)
          }
          let c = this.input.charCodeAt(this.state.pos)
          if (
            (c === 46 &&
              !u &&
              (++this.state.pos,
              this.readInt(10),
              (r = !0),
              (c = this.input.charCodeAt(this.state.pos))),
            (c === 69 || c === 101) &&
              !u &&
              ((c = this.input.charCodeAt(++this.state.pos)),
              (c === 43 || c === 45) && ++this.state.pos,
              this.readInt(10) === null &&
                this.raise(R.InvalidOrMissingExponent, i),
              (r = !0),
              (o = !0),
              (c = this.input.charCodeAt(this.state.pos))),
            c === 110 &&
              ((r || l) && this.raise(R.InvalidBigIntLiteral, i),
              ++this.state.pos,
              (n = !0)),
            c === 109 &&
              (this.expectPlugin('decimal', this.state.curPosition()),
              (o || l) && this.raise(R.InvalidDecimal, i),
              ++this.state.pos,
              (a = !0)),
            gi(this.codePointAtPos(this.state.pos)))
          )
            throw this.raise(R.NumberIdentifier, this.state.curPosition())
          let f = this.input.slice(s, this.state.pos).replace(/[_mn]/g, '')
          if (n) {
            this.finishToken(135, f)
            return
          }
          if (a) {
            this.finishToken(136, f)
            return
          }
          let h = u ? parseInt(f, 8) : parseFloat(f)
          this.finishToken(134, h)
        }
        readCodePoint(e) {
          let { code: s, pos: i } = f1(
            this.input,
            this.state.pos,
            this.state.lineStart,
            this.state.curLine,
            e,
            this.errorHandlers_readCodePoint
          )
          return (this.state.pos = i), s
        }
        readString(e) {
          let {
            str: s,
            pos: i,
            curLine: r,
            lineStart: n,
          } = l1(
            e === 34 ? 'double' : 'single',
            this.input,
            this.state.pos + 1,
            this.state.lineStart,
            this.state.curLine,
            this.errorHandlers_readStringContents_string
          )
          ;(this.state.pos = i + 1),
            (this.state.lineStart = n),
            (this.state.curLine = r),
            this.finishToken(133, s)
        }
        readTemplateContinuation() {
          this.match(8) || this.unexpected(null, 8),
            this.state.pos--,
            this.readTemplateToken()
        }
        readTemplateToken() {
          let e = this.input[this.state.pos],
            {
              str: s,
              firstInvalidLoc: i,
              pos: r,
              curLine: n,
              lineStart: a,
            } = l1(
              'template',
              this.input,
              this.state.pos + 1,
              this.state.lineStart,
              this.state.curLine,
              this.errorHandlers_readStringContents_template
            )
          ;(this.state.pos = r + 1),
            (this.state.lineStart = a),
            (this.state.curLine = n),
            i &&
              (this.state.firstInvalidTemplateEscapePos = new hi(
                i.curLine,
                i.pos - i.lineStart,
                i.pos
              )),
            this.input.codePointAt(r) === 96
              ? this.finishToken(24, i ? null : e + s + '`')
              : (this.state.pos++,
                this.finishToken(25, i ? null : e + s + '${'))
        }
        recordStrictModeErrors(e, s) {
          let i = s.index
          this.state.strict && !this.state.strictErrors.has(i)
            ? this.raise(e, s)
            : this.state.strictErrors.set(i, [e, s])
        }
        readWord1(e) {
          this.state.containsEsc = !1
          let s = '',
            i = this.state.pos,
            r = this.state.pos
          for (
            e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2);
            this.state.pos < this.length;

          ) {
            let n = this.codePointAtPos(this.state.pos)
            if (Fn(n)) this.state.pos += n <= 65535 ? 1 : 2
            else if (n === 92) {
              ;(this.state.containsEsc = !0),
                (s += this.input.slice(r, this.state.pos))
              let a = this.state.curPosition(),
                o = this.state.pos === i ? gi : Fn
              if (this.input.charCodeAt(++this.state.pos) !== 117) {
                this.raise(R.MissingUnicodeEscape, this.state.curPosition()),
                  (r = this.state.pos - 1)
                continue
              }
              ++this.state.pos
              let u = this.readCodePoint(!0)
              u !== null &&
                (o(u) || this.raise(R.EscapedCharNotAnIdentifier, a),
                (s += String.fromCodePoint(u))),
                (r = this.state.pos)
            } else break
          }
          return s + this.input.slice(r, this.state.pos)
        }
        readWord(e) {
          let s = this.readWord1(e),
            i = yh.get(s)
          i !== void 0 ? this.finishToken(i, Zi(i)) : this.finishToken(132, s)
        }
        checkKeywordEscapes() {
          let { type: e } = this.state
          Ah(e) &&
            this.state.containsEsc &&
            this.raise(R.InvalidEscapedReservedWord, this.state.startLoc, {
              reservedWord: Zi(e),
            })
        }
        raise(e, s, i = {}) {
          let r = s instanceof hi ? s : s.loc.start,
            n = e(r, i)
          if (!this.options.errorRecovery) throw n
          return this.isLookahead || this.state.errors.push(n), n
        }
        raiseOverwrite(e, s, i = {}) {
          let r = s instanceof hi ? s : s.loc.start,
            n = r.index,
            a = this.state.errors
          for (let o = a.length - 1; o >= 0; o--) {
            let u = a[o]
            if (u.loc.index === n) return (a[o] = e(r, i))
            if (u.loc.index < n) break
          }
          return this.raise(e, s, i)
        }
        updateContext(e) {}
        unexpected(e, s) {
          throw this.raise(
            R.UnexpectedToken,
            e != null ? e : this.state.startLoc,
            { expected: s ? Zi(s) : null }
          )
        }
        expectPlugin(e, s) {
          if (this.hasPlugin(e)) return !0
          throw this.raise(
            R.MissingPlugin,
            s != null ? s : this.state.startLoc,
            { missingPlugin: [e] }
          )
        }
        expectOnePlugin(e) {
          if (!e.some((s) => this.hasPlugin(s)))
            throw this.raise(R.MissingOneOfPlugins, this.state.startLoc, {
              missingPlugin: e,
            })
        }
        errorBuilder(e) {
          return (s, i, r) => {
            this.raise(e, Ua(s, i, r))
          }
        }
      },
      p1 = class {
        constructor() {
          ;(this.privateNames = new Set()),
            (this.loneAccessors = new Map()),
            (this.undefinedPrivateNames = new Map())
        }
      },
      d1 = class {
        constructor(e) {
          ;(this.parser = void 0),
            (this.stack = []),
            (this.undefinedPrivateNames = new Map()),
            (this.parser = e)
        }
        current() {
          return this.stack[this.stack.length - 1]
        }
        enter() {
          this.stack.push(new p1())
        }
        exit() {
          let e = this.stack.pop(),
            s = this.current()
          for (let [i, r] of Array.from(e.undefinedPrivateNames))
            s
              ? s.undefinedPrivateNames.has(i) ||
                s.undefinedPrivateNames.set(i, r)
              : this.parser.raise(R.InvalidPrivateFieldResolution, r, {
                  identifierName: i,
                })
        }
        declarePrivateName(e, s, i) {
          let {
              privateNames: r,
              loneAccessors: n,
              undefinedPrivateNames: a,
            } = this.current(),
            o = r.has(e)
          if (s & 3) {
            let u = o && n.get(e)
            if (u) {
              let l = u & 4,
                c = s & 4,
                f = u & 3,
                h = s & 3
              ;(o = f === h || l !== c), o || n.delete(e)
            } else o || n.set(e, s)
          }
          o &&
            this.parser.raise(R.PrivateNameRedeclaration, i, {
              identifierName: e,
            }),
            r.add(e),
            a.delete(e)
        }
        usePrivateName(e, s) {
          let i
          for (i of this.stack) if (i.privateNames.has(e)) return
          i
            ? i.undefinedPrivateNames.set(e, s)
            : this.parser.raise(R.InvalidPrivateFieldResolution, s, {
                identifierName: e,
              })
        }
      },
      Ha = class {
        constructor(e = 0) {
          this.type = e
        }
        canBeArrowParameterDeclaration() {
          return this.type === 2 || this.type === 1
        }
        isCertainlyParameterDeclaration() {
          return this.type === 3
        }
      },
      Oh = class extends Ha {
        constructor(e) {
          super(e)
          this.declarationErrors = new Map()
        }
        recordDeclarationError(e, s) {
          let i = s.index
          this.declarationErrors.set(i, [e, s])
        }
        clearDeclarationError(e) {
          this.declarationErrors.delete(e)
        }
        iterateErrors(e) {
          this.declarationErrors.forEach(e)
        }
      },
      m1 = class {
        constructor(e) {
          ;(this.parser = void 0), (this.stack = [new Ha()]), (this.parser = e)
        }
        enter(e) {
          this.stack.push(e)
        }
        exit() {
          this.stack.pop()
        }
        recordParameterInitializerError(e, s) {
          let i = s.loc.start,
            { stack: r } = this,
            n = r.length - 1,
            a = r[n]
          for (; !a.isCertainlyParameterDeclaration(); ) {
            if (a.canBeArrowParameterDeclaration())
              a.recordDeclarationError(e, i)
            else return
            a = r[--n]
          }
          this.parser.raise(e, i)
        }
        recordArrowParameterBindingError(e, s) {
          let { stack: i } = this,
            r = i[i.length - 1],
            n = s.loc.start
          if (r.isCertainlyParameterDeclaration()) this.parser.raise(e, n)
          else if (r.canBeArrowParameterDeclaration())
            r.recordDeclarationError(e, n)
          else return
        }
        recordAsyncArrowParametersError(e) {
          let { stack: s } = this,
            i = s.length - 1,
            r = s[i]
          for (; r.canBeArrowParameterDeclaration(); )
            r.type === 2 &&
              r.recordDeclarationError(R.AwaitBindingIdentifier, e),
              (r = s[--i])
        }
        validateAsPattern() {
          let { stack: e } = this,
            s = e[e.length - 1]
          !s.canBeArrowParameterDeclaration() ||
            s.iterateErrors(([i, r]) => {
              this.parser.raise(i, r)
              let n = e.length - 2,
                a = e[n]
              for (; a.canBeArrowParameterDeclaration(); )
                a.clearDeclarationError(r.index), (a = e[--n])
            })
        }
      }
    function Sv() {
      return new Ha(3)
    }
    function Tv() {
      return new Oh(1)
    }
    function _v() {
      return new Oh(2)
    }
    function g1() {
      return new Ha()
    }
    var y1 = class {
      constructor() {
        this.stacks = []
      }
      enter(e) {
        this.stacks.push(e)
      }
      exit() {
        this.stacks.pop()
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1]
      }
      get hasAwait() {
        return (this.currentFlags() & 2) > 0
      }
      get hasYield() {
        return (this.currentFlags() & 1) > 0
      }
      get hasReturn() {
        return (this.currentFlags() & 4) > 0
      }
      get hasIn() {
        return (this.currentFlags() & 8) > 0
      }
    }
    function $u(t, e) {
      return (t ? 2 : 0) | (e ? 1 : 0)
    }
    var b1 = class extends h1 {
        addExtra(e, s, i, r = !0) {
          if (!e) return
          let n = (e.extra = e.extra || {})
          r
            ? (n[s] = i)
            : Object.defineProperty(n, s, { enumerable: r, value: i })
        }
        isContextual(e) {
          return this.state.type === e && !this.state.containsEsc
        }
        isUnparsedContextual(e, s) {
          let i = e + s.length
          if (this.input.slice(e, i) === s) {
            let r = this.input.charCodeAt(i)
            return !(Fn(r) || (r & 64512) == 55296)
          }
          return !1
        }
        isLookaheadContextual(e) {
          let s = this.nextTokenStart()
          return this.isUnparsedContextual(s, e)
        }
        eatContextual(e) {
          return this.isContextual(e) ? (this.next(), !0) : !1
        }
        expectContextual(e, s) {
          if (!this.eatContextual(e)) {
            if (s != null) throw this.raise(s, this.state.startLoc)
            this.unexpected(null, e)
          }
        }
        canInsertSemicolon() {
          return (
            this.match(139) || this.match(8) || this.hasPrecedingLineBreak()
          )
        }
        hasPrecedingLineBreak() {
          return a1.test(
            this.input.slice(this.state.lastTokEndLoc.index, this.state.start)
          )
        }
        hasFollowingLineBreak() {
          return (o1.lastIndex = this.state.end), o1.test(this.input)
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon()
        }
        semicolon(e = !0) {
          ;(e ? this.isLineTerminator() : this.eat(13)) ||
            this.raise(R.MissingSemicolon, this.state.lastTokEndLoc)
        }
        expect(e, s) {
          this.eat(e) || this.unexpected(s, e)
        }
        tryParse(e, s = this.state.clone()) {
          let i = { node: null }
          try {
            let r = e((n = null) => {
              throw ((i.node = n), i)
            })
            if (this.state.errors.length > s.errors.length) {
              let n = this.state
              return (
                (this.state = s),
                (this.state.tokensLength = n.tokensLength),
                {
                  node: r,
                  error: n.errors[s.errors.length],
                  thrown: !1,
                  aborted: !1,
                  failState: n,
                }
              )
            }
            return {
              node: r,
              error: null,
              thrown: !1,
              aborted: !1,
              failState: null,
            }
          } catch (r) {
            let n = this.state
            if (((this.state = s), r instanceof SyntaxError))
              return {
                node: null,
                error: r,
                thrown: !0,
                aborted: !1,
                failState: n,
              }
            if (r === i)
              return {
                node: i.node,
                error: null,
                thrown: !1,
                aborted: !0,
                failState: n,
              }
            throw r
          }
        }
        checkExpressionErrors(e, s) {
          if (!e) return !1
          let {
              shorthandAssignLoc: i,
              doubleProtoLoc: r,
              privateKeyLoc: n,
              optionalParametersLoc: a,
            } = e,
            o = !!i || !!r || !!a || !!n
          if (!s) return o
          i != null && this.raise(R.InvalidCoverInitializedName, i),
            r != null && this.raise(R.DuplicateProto, r),
            n != null && this.raise(R.UnexpectedPrivateField, n),
            a != null && this.unexpected(a)
        }
        isLiteralPropertyName() {
          return Gg(this.state.type)
        }
        isPrivateName(e) {
          return e.type === 'PrivateName'
        }
        getPrivateNameSV(e) {
          return e.id.name
        }
        hasPropertyAsPrivateName(e) {
          return (
            (e.type === 'MemberExpression' ||
              e.type === 'OptionalMemberExpression') &&
            this.isPrivateName(e.property)
          )
        }
        isObjectProperty(e) {
          return e.type === 'ObjectProperty'
        }
        isObjectMethod(e) {
          return e.type === 'ObjectMethod'
        }
        initializeScopes(e = this.options.sourceType === 'module') {
          let s = this.state.labels
          this.state.labels = []
          let i = this.exportedIdentifiers
          this.exportedIdentifiers = new Set()
          let r = this.inModule
          this.inModule = e
          let n = this.scope,
            a = this.getScopeHandler()
          this.scope = new a(this, e)
          let o = this.prodParam
          this.prodParam = new y1()
          let u = this.classScope
          this.classScope = new d1(this)
          let l = this.expressionScope
          return (
            (this.expressionScope = new m1(this)),
            () => {
              ;(this.state.labels = s),
                (this.exportedIdentifiers = i),
                (this.inModule = r),
                (this.scope = n),
                (this.prodParam = o),
                (this.classScope = u),
                (this.expressionScope = l)
            }
          )
        }
        enterInitialScopes() {
          let e = 0
          this.inModule && (e |= 2),
            this.scope.enter(1),
            this.prodParam.enter(e)
        }
        checkDestructuringPrivate(e) {
          let { privateKeyLoc: s } = e
          s !== null && this.expectPlugin('destructuringPrivate', s)
        }
      },
      $a = class {
        constructor() {
          ;(this.shorthandAssignLoc = null),
            (this.doubleProtoLoc = null),
            (this.privateKeyLoc = null),
            (this.optionalParametersLoc = null)
        }
      },
      ja = class {
        constructor(e, s, i) {
          ;(this.type = ''),
            (this.start = s),
            (this.end = 0),
            (this.loc = new Ra(i)),
            e != null && e.options.ranges && (this.range = [s, 0]),
            e != null && e.filename && (this.loc.filename = e.filename)
        }
      },
      wh = ja.prototype
    wh.__clone = function () {
      let t = new ja(void 0, this.start, this.loc.start),
        e = Object.keys(this)
      for (let s = 0, i = e.length; s < i; s++) {
        let r = e[s]
        r !== 'leadingComments' &&
          r !== 'trailingComments' &&
          r !== 'innerComments' &&
          (t[r] = this[r])
      }
      return t
    }
    function xv(t) {
      return bi(t)
    }
    function bi(t) {
      let {
          type: e,
          start: s,
          end: i,
          loc: r,
          range: n,
          extra: a,
          name: o,
        } = t,
        u = Object.create(wh)
      return (
        (u.type = e),
        (u.start = s),
        (u.end = i),
        (u.loc = r),
        (u.range = n),
        (u.extra = a),
        (u.name = o),
        e === 'Placeholder' && (u.expectedNode = t.expectedNode),
        u
      )
    }
    function Av(t) {
      let { type: e, start: s, end: i, loc: r, range: n, extra: a } = t
      if (e === 'Placeholder') return xv(t)
      let o = Object.create(wh)
      return (
        (o.type = e),
        (o.start = s),
        (o.end = i),
        (o.loc = r),
        (o.range = n),
        t.raw !== void 0 ? (o.raw = t.raw) : (o.extra = a),
        (o.value = t.value),
        o
      )
    }
    var E1 = class extends b1 {
        startNode() {
          let e = this.state.startLoc
          return new ja(this, e.index, e)
        }
        startNodeAt(e) {
          return new ja(this, e.index, e)
        }
        startNodeAtNode(e) {
          return this.startNodeAt(e.loc.start)
        }
        finishNode(e, s) {
          return this.finishNodeAt(e, s, this.state.lastTokEndLoc)
        }
        finishNodeAt(e, s, i) {
          return (
            (e.type = s),
            (e.end = i.index),
            (e.loc.end = i),
            this.options.ranges && (e.range[1] = i.index),
            this.options.attachComment && this.processComment(e),
            e
          )
        }
        resetStartLocation(e, s) {
          ;(e.start = s.index),
            (e.loc.start = s),
            this.options.ranges && (e.range[0] = s.index)
        }
        resetEndLocation(e, s = this.state.lastTokEndLoc) {
          ;(e.end = s.index),
            (e.loc.end = s),
            this.options.ranges && (e.range[1] = s.index)
        }
        resetStartLocationFromNode(e, s) {
          this.resetStartLocation(e, s.loc.start)
        }
      },
      Pv = new Set([
        '_',
        'any',
        'bool',
        'boolean',
        'empty',
        'extends',
        'false',
        'interface',
        'mixed',
        'null',
        'number',
        'static',
        'string',
        'true',
        'typeof',
        'void',
      ]),
      be = pi`flow`({
        AmbiguousConditionalArrow:
          'Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.',
        AmbiguousDeclareModuleKind:
          'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.',
        AssignReservedType: ({ reservedType: t }) =>
          `Cannot overwrite reserved type ${t}.`,
        DeclareClassElement:
          'The `declare` modifier can only appear on class fields.',
        DeclareClassFieldInitializer:
          'Initializers are not allowed in fields with the `declare` modifier.',
        DuplicateDeclareModuleExports:
          'Duplicate `declare module.exports` statement.',
        EnumBooleanMemberNotInitialized: ({ memberName: t, enumName: e }) =>
          `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`,
        EnumDuplicateMemberName: ({ memberName: t, enumName: e }) =>
          `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`,
        EnumInconsistentMemberValues: ({ enumName: t }) =>
          `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
        EnumInvalidExplicitType: ({ invalidEnumType: t, enumName: e }) =>
          `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`,
        EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: t }) =>
          `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`,
        EnumInvalidMemberInitializerPrimaryType: ({
          enumName: t,
          memberName: e,
          explicitType: s,
        }) =>
          `Enum \`${t}\` has type \`${s}\`, so the initializer of \`${e}\` needs to be a ${s} literal.`,
        EnumInvalidMemberInitializerSymbolType: ({
          enumName: t,
          memberName: e,
        }) =>
          `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`,
        EnumInvalidMemberInitializerUnknownType: ({
          enumName: t,
          memberName: e,
        }) =>
          `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`,
        EnumInvalidMemberName: ({
          enumName: t,
          memberName: e,
          suggestion: s,
        }) =>
          `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${s}\`, in enum \`${t}\`.`,
        EnumNumberMemberNotInitialized: ({ enumName: t, memberName: e }) =>
          `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`,
        EnumStringMemberInconsistentlyInitialized: ({ enumName: t }) =>
          `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`,
        GetterMayNotHaveThisParam: 'A getter cannot have a `this` parameter.',
        ImportReflectionHasImportType:
          'An `import module` declaration can not use `type` or `typeof` keyword.',
        ImportTypeShorthandOnlyInPureImport:
          'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.',
        InexactInsideExact:
          'Explicit inexact syntax cannot appear inside an explicit exact object type.',
        InexactInsideNonObject:
          'Explicit inexact syntax cannot appear in class or interface definitions.',
        InexactVariance: 'Explicit inexact syntax cannot have variance.',
        InvalidNonTypeImportInDeclareModule:
          'Imports within a `declare module` body must always be `import type` or `import typeof`.',
        MissingTypeParamDefault:
          'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.',
        NestedDeclareModule:
          '`declare module` cannot be used inside another `declare module`.',
        NestedFlowComment:
          'Cannot have a flow comment inside another flow comment.',
        PatternIsOptional: Object.assign(
          {
            message:
              'A binding pattern parameter cannot be optional in an implementation signature.',
          },
          { reasonCode: 'OptionalBindingPattern' }
        ),
        SetterMayNotHaveThisParam: 'A setter cannot have a `this` parameter.',
        SpreadVariance: 'Spread properties cannot have variance.',
        ThisParamAnnotationRequired:
          'A type annotation is required for the `this` parameter.',
        ThisParamBannedInConstructor:
          "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
        ThisParamMayNotBeOptional: 'The `this` parameter cannot be optional.',
        ThisParamMustBeFirst:
          'The `this` parameter must be the first function parameter.',
        ThisParamNoDefault:
          'The `this` parameter may not have a default value.',
        TypeBeforeInitializer:
          'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
        TypeCastInPattern:
          'The type cast expression is expected to be wrapped with parenthesis.',
        UnexpectedExplicitInexactInObject:
          'Explicit inexact syntax must appear at the end of an inexact object.',
        UnexpectedReservedType: ({ reservedType: t }) =>
          `Unexpected reserved type ${t}.`,
        UnexpectedReservedUnderscore:
          '`_` is only allowed as a type argument to call or new.',
        UnexpectedSpaceBetweenModuloChecks:
          'Spaces between `%` and `checks` are not allowed here.',
        UnexpectedSpreadType:
          'Spread operator cannot appear in class or interface definitions.',
        UnexpectedSubtractionOperand:
          'Unexpected token, expected "number" or "bigint".',
        UnexpectedTokenAfterTypeParameter:
          'Expected an arrow function after this type parameter declaration.',
        UnexpectedTypeParameterBeforeAsyncArrowFunction:
          'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.',
        UnsupportedDeclareExportKind: ({
          unsupportedExportKind: t,
          suggestion: e,
        }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`,
        UnsupportedStatementInDeclareModule:
          'Only declares and type imports are allowed inside declare module.',
        UnterminatedFlowComment: 'Unterminated flow-comment.',
      })
    function Cv(t) {
      return (
        t.type === 'DeclareExportAllDeclaration' ||
        (t.type === 'DeclareExportDeclaration' &&
          (!t.declaration ||
            (t.declaration.type !== 'TypeAlias' &&
              t.declaration.type !== 'InterfaceDeclaration')))
      )
    }
    function S1(t) {
      return t.importKind === 'type' || t.importKind === 'typeof'
    }
    var vv = {
      const: 'declare export var',
      let: 'declare export var',
      type: 'export type',
      interface: 'export interface',
    }
    function Nv(t, e) {
      let s = [],
        i = []
      for (let r = 0; r < t.length; r++) (e(t[r], r, t) ? s : i).push(t[r])
      return [s, i]
    }
    var Iv = /\*?\s*@((?:no)?flow)\b/,
      Ov = (t) =>
        class extends t {
          constructor(...s) {
            super(...s)
            this.flowPragma = void 0
          }
          getScopeHandler() {
            return s1
          }
          shouldParseTypes() {
            return (
              this.getPluginOption('flow', 'all') || this.flowPragma === 'flow'
            )
          }
          shouldParseEnums() {
            return !!this.getPluginOption('flow', 'enums')
          }
          finishToken(s, i) {
            s !== 133 &&
              s !== 13 &&
              s !== 28 &&
              this.flowPragma === void 0 &&
              (this.flowPragma = null),
              super.finishToken(s, i)
          }
          addComment(s) {
            if (this.flowPragma === void 0) {
              let i = Iv.exec(s.value)
              if (i)
                if (i[1] === 'flow') this.flowPragma = 'flow'
                else if (i[1] === 'noflow') this.flowPragma = 'noflow'
                else throw new Error('Unexpected flow pragma')
            }
            super.addComment(s)
          }
          flowParseTypeInitialiser(s) {
            let i = this.state.inType
            ;(this.state.inType = !0), this.expect(s || 14)
            let r = this.flowParseType()
            return (this.state.inType = i), r
          }
          flowParsePredicate() {
            let s = this.startNode(),
              i = this.state.startLoc
            return (
              this.next(),
              this.expectContextual(110),
              this.state.lastTokStartLoc.index > i.index + 1 &&
                this.raise(be.UnexpectedSpaceBetweenModuloChecks, i),
              this.eat(10)
                ? ((s.value = super.parseExpression()),
                  this.expect(11),
                  this.finishNode(s, 'DeclaredPredicate'))
                : this.finishNode(s, 'InferredPredicate')
            )
          }
          flowParseTypeAndPredicateInitialiser() {
            let s = this.state.inType
            ;(this.state.inType = !0), this.expect(14)
            let i = null,
              r = null
            return (
              this.match(54)
                ? ((this.state.inType = s), (r = this.flowParsePredicate()))
                : ((i = this.flowParseType()),
                  (this.state.inType = s),
                  this.match(54) && (r = this.flowParsePredicate())),
              [i, r]
            )
          }
          flowParseDeclareClass(s) {
            return (
              this.next(),
              this.flowParseInterfaceish(s, !0),
              this.finishNode(s, 'DeclareClass')
            )
          }
          flowParseDeclareFunction(s) {
            this.next()
            let i = (s.id = this.parseIdentifier()),
              r = this.startNode(),
              n = this.startNode()
            this.match(47)
              ? (r.typeParameters = this.flowParseTypeParameterDeclaration())
              : (r.typeParameters = null),
              this.expect(10)
            let a = this.flowParseFunctionTypeParams()
            return (
              (r.params = a.params),
              (r.rest = a.rest),
              (r.this = a._this),
              this.expect(11),
              ([r.returnType, s.predicate] =
                this.flowParseTypeAndPredicateInitialiser()),
              (n.typeAnnotation = this.finishNode(r, 'FunctionTypeAnnotation')),
              (i.typeAnnotation = this.finishNode(n, 'TypeAnnotation')),
              this.resetEndLocation(i),
              this.semicolon(),
              this.scope.declareName(s.id.name, 2048, s.id.loc.start),
              this.finishNode(s, 'DeclareFunction')
            )
          }
          flowParseDeclare(s, i) {
            if (this.match(80)) return this.flowParseDeclareClass(s)
            if (this.match(68)) return this.flowParseDeclareFunction(s)
            if (this.match(74)) return this.flowParseDeclareVariable(s)
            if (this.eatContextual(127))
              return this.match(16)
                ? this.flowParseDeclareModuleExports(s)
                : (i &&
                    this.raise(
                      be.NestedDeclareModule,
                      this.state.lastTokStartLoc
                    ),
                  this.flowParseDeclareModule(s))
            if (this.isContextual(130)) return this.flowParseDeclareTypeAlias(s)
            if (this.isContextual(131))
              return this.flowParseDeclareOpaqueType(s)
            if (this.isContextual(129)) return this.flowParseDeclareInterface(s)
            if (this.match(82))
              return this.flowParseDeclareExportDeclaration(s, i)
            this.unexpected()
          }
          flowParseDeclareVariable(s) {
            return (
              this.next(),
              (s.id = this.flowParseTypeAnnotatableIdentifier(!0)),
              this.scope.declareName(s.id.name, 5, s.id.loc.start),
              this.semicolon(),
              this.finishNode(s, 'DeclareVariable')
            )
          }
          flowParseDeclareModule(s) {
            this.scope.enter(0),
              this.match(133)
                ? (s.id = super.parseExprAtom())
                : (s.id = this.parseIdentifier())
            let i = (s.body = this.startNode()),
              r = (i.body = [])
            for (this.expect(5); !this.match(8); ) {
              let o = this.startNode()
              this.match(83)
                ? (this.next(),
                  !this.isContextual(130) &&
                    !this.match(87) &&
                    this.raise(
                      be.InvalidNonTypeImportInDeclareModule,
                      this.state.lastTokStartLoc
                    ),
                  super.parseImport(o))
                : (this.expectContextual(
                    125,
                    be.UnsupportedStatementInDeclareModule
                  ),
                  (o = this.flowParseDeclare(o, !0))),
                r.push(o)
            }
            this.scope.exit(),
              this.expect(8),
              this.finishNode(i, 'BlockStatement')
            let n = null,
              a = !1
            return (
              r.forEach((o) => {
                Cv(o)
                  ? (n === 'CommonJS' &&
                      this.raise(be.AmbiguousDeclareModuleKind, o),
                    (n = 'ES'))
                  : o.type === 'DeclareModuleExports' &&
                    (a && this.raise(be.DuplicateDeclareModuleExports, o),
                    n === 'ES' && this.raise(be.AmbiguousDeclareModuleKind, o),
                    (n = 'CommonJS'),
                    (a = !0))
              }),
              (s.kind = n || 'CommonJS'),
              this.finishNode(s, 'DeclareModule')
            )
          }
          flowParseDeclareExportDeclaration(s, i) {
            if ((this.expect(82), this.eat(65)))
              return (
                this.match(68) || this.match(80)
                  ? (s.declaration = this.flowParseDeclare(this.startNode()))
                  : ((s.declaration = this.flowParseType()), this.semicolon()),
                (s.default = !0),
                this.finishNode(s, 'DeclareExportDeclaration')
              )
            if (
              this.match(75) ||
              this.isLet() ||
              ((this.isContextual(130) || this.isContextual(129)) && !i)
            ) {
              let r = this.state.value
              throw this.raise(
                be.UnsupportedDeclareExportKind,
                this.state.startLoc,
                { unsupportedExportKind: r, suggestion: vv[r] }
              )
            }
            if (
              this.match(74) ||
              this.match(68) ||
              this.match(80) ||
              this.isContextual(131)
            )
              return (
                (s.declaration = this.flowParseDeclare(this.startNode())),
                (s.default = !1),
                this.finishNode(s, 'DeclareExportDeclaration')
              )
            if (
              this.match(55) ||
              this.match(5) ||
              this.isContextual(129) ||
              this.isContextual(130) ||
              this.isContextual(131)
            )
              return (
                (s = this.parseExport(s, null)),
                s.type === 'ExportNamedDeclaration' &&
                  ((s.type = 'ExportDeclaration'),
                  (s.default = !1),
                  delete s.exportKind),
                (s.type = 'Declare' + s.type),
                s
              )
            this.unexpected()
          }
          flowParseDeclareModuleExports(s) {
            return (
              this.next(),
              this.expectContextual(111),
              (s.typeAnnotation = this.flowParseTypeAnnotation()),
              this.semicolon(),
              this.finishNode(s, 'DeclareModuleExports')
            )
          }
          flowParseDeclareTypeAlias(s) {
            this.next()
            let i = this.flowParseTypeAlias(s)
            return (i.type = 'DeclareTypeAlias'), i
          }
          flowParseDeclareOpaqueType(s) {
            this.next()
            let i = this.flowParseOpaqueType(s, !0)
            return (i.type = 'DeclareOpaqueType'), i
          }
          flowParseDeclareInterface(s) {
            return (
              this.next(),
              this.flowParseInterfaceish(s, !1),
              this.finishNode(s, 'DeclareInterface')
            )
          }
          flowParseInterfaceish(s, i) {
            if (
              ((s.id = this.flowParseRestrictedIdentifier(!i, !0)),
              this.scope.declareName(s.id.name, i ? 17 : 8201, s.id.loc.start),
              this.match(47)
                ? (s.typeParameters = this.flowParseTypeParameterDeclaration())
                : (s.typeParameters = null),
              (s.extends = []),
              this.eat(81))
            )
              do s.extends.push(this.flowParseInterfaceExtends())
              while (!i && this.eat(12))
            if (i) {
              if (
                ((s.implements = []), (s.mixins = []), this.eatContextual(117))
              )
                do s.mixins.push(this.flowParseInterfaceExtends())
                while (this.eat(12))
              if (this.eatContextual(113))
                do s.implements.push(this.flowParseInterfaceExtends())
                while (this.eat(12))
            }
            s.body = this.flowParseObjectType({
              allowStatic: i,
              allowExact: !1,
              allowSpread: !1,
              allowProto: i,
              allowInexact: !1,
            })
          }
          flowParseInterfaceExtends() {
            let s = this.startNode()
            return (
              (s.id = this.flowParseQualifiedTypeIdentifier()),
              this.match(47)
                ? (s.typeParameters =
                    this.flowParseTypeParameterInstantiation())
                : (s.typeParameters = null),
              this.finishNode(s, 'InterfaceExtends')
            )
          }
          flowParseInterface(s) {
            return (
              this.flowParseInterfaceish(s, !1),
              this.finishNode(s, 'InterfaceDeclaration')
            )
          }
          checkNotUnderscore(s) {
            s === '_' &&
              this.raise(be.UnexpectedReservedUnderscore, this.state.startLoc)
          }
          checkReservedType(s, i, r) {
            !Pv.has(s) ||
              this.raise(
                r ? be.AssignReservedType : be.UnexpectedReservedType,
                i,
                { reservedType: s }
              )
          }
          flowParseRestrictedIdentifier(s, i) {
            return (
              this.checkReservedType(this.state.value, this.state.startLoc, i),
              this.parseIdentifier(s)
            )
          }
          flowParseTypeAlias(s) {
            return (
              (s.id = this.flowParseRestrictedIdentifier(!1, !0)),
              this.scope.declareName(s.id.name, 8201, s.id.loc.start),
              this.match(47)
                ? (s.typeParameters = this.flowParseTypeParameterDeclaration())
                : (s.typeParameters = null),
              (s.right = this.flowParseTypeInitialiser(29)),
              this.semicolon(),
              this.finishNode(s, 'TypeAlias')
            )
          }
          flowParseOpaqueType(s, i) {
            return (
              this.expectContextual(130),
              (s.id = this.flowParseRestrictedIdentifier(!0, !0)),
              this.scope.declareName(s.id.name, 8201, s.id.loc.start),
              this.match(47)
                ? (s.typeParameters = this.flowParseTypeParameterDeclaration())
                : (s.typeParameters = null),
              (s.supertype = null),
              this.match(14) &&
                (s.supertype = this.flowParseTypeInitialiser(14)),
              (s.impltype = null),
              i || (s.impltype = this.flowParseTypeInitialiser(29)),
              this.semicolon(),
              this.finishNode(s, 'OpaqueType')
            )
          }
          flowParseTypeParameter(s = !1) {
            let i = this.state.startLoc,
              r = this.startNode(),
              n = this.flowParseVariance(),
              a = this.flowParseTypeAnnotatableIdentifier()
            return (
              (r.name = a.name),
              (r.variance = n),
              (r.bound = a.typeAnnotation),
              this.match(29)
                ? (this.eat(29), (r.default = this.flowParseType()))
                : s && this.raise(be.MissingTypeParamDefault, i),
              this.finishNode(r, 'TypeParameter')
            )
          }
          flowParseTypeParameterDeclaration() {
            let s = this.state.inType,
              i = this.startNode()
            ;(i.params = []),
              (this.state.inType = !0),
              this.match(47) || this.match(142)
                ? this.next()
                : this.unexpected()
            let r = !1
            do {
              let n = this.flowParseTypeParameter(r)
              i.params.push(n),
                n.default && (r = !0),
                this.match(48) || this.expect(12)
            } while (!this.match(48))
            return (
              this.expect(48),
              (this.state.inType = s),
              this.finishNode(i, 'TypeParameterDeclaration')
            )
          }
          flowParseTypeParameterInstantiation() {
            let s = this.startNode(),
              i = this.state.inType
            ;(s.params = []), (this.state.inType = !0), this.expect(47)
            let r = this.state.noAnonFunctionType
            for (this.state.noAnonFunctionType = !1; !this.match(48); )
              s.params.push(this.flowParseType()),
                this.match(48) || this.expect(12)
            return (
              (this.state.noAnonFunctionType = r),
              this.expect(48),
              (this.state.inType = i),
              this.finishNode(s, 'TypeParameterInstantiation')
            )
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            let s = this.startNode(),
              i = this.state.inType
            for (
              s.params = [], this.state.inType = !0, this.expect(47);
              !this.match(48);

            )
              s.params.push(this.flowParseTypeOrImplicitInstantiation()),
                this.match(48) || this.expect(12)
            return (
              this.expect(48),
              (this.state.inType = i),
              this.finishNode(s, 'TypeParameterInstantiation')
            )
          }
          flowParseInterfaceType() {
            let s = this.startNode()
            if ((this.expectContextual(129), (s.extends = []), this.eat(81)))
              do s.extends.push(this.flowParseInterfaceExtends())
              while (this.eat(12))
            return (
              (s.body = this.flowParseObjectType({
                allowStatic: !1,
                allowExact: !1,
                allowSpread: !1,
                allowProto: !1,
                allowInexact: !1,
              })),
              this.finishNode(s, 'InterfaceTypeAnnotation')
            )
          }
          flowParseObjectPropertyKey() {
            return this.match(134) || this.match(133)
              ? super.parseExprAtom()
              : this.parseIdentifier(!0)
          }
          flowParseObjectTypeIndexer(s, i, r) {
            return (
              (s.static = i),
              this.lookahead().type === 14
                ? ((s.id = this.flowParseObjectPropertyKey()),
                  (s.key = this.flowParseTypeInitialiser()))
                : ((s.id = null), (s.key = this.flowParseType())),
              this.expect(3),
              (s.value = this.flowParseTypeInitialiser()),
              (s.variance = r),
              this.finishNode(s, 'ObjectTypeIndexer')
            )
          }
          flowParseObjectTypeInternalSlot(s, i) {
            return (
              (s.static = i),
              (s.id = this.flowParseObjectPropertyKey()),
              this.expect(3),
              this.expect(3),
              this.match(47) || this.match(10)
                ? ((s.method = !0),
                  (s.optional = !1),
                  (s.value = this.flowParseObjectTypeMethodish(
                    this.startNodeAt(s.loc.start)
                  )))
                : ((s.method = !1),
                  this.eat(17) && (s.optional = !0),
                  (s.value = this.flowParseTypeInitialiser())),
              this.finishNode(s, 'ObjectTypeInternalSlot')
            )
          }
          flowParseObjectTypeMethodish(s) {
            for (
              s.params = [],
                s.rest = null,
                s.typeParameters = null,
                s.this = null,
                this.match(47) &&
                  (s.typeParameters = this.flowParseTypeParameterDeclaration()),
                this.expect(10),
                this.match(78) &&
                  ((s.this = this.flowParseFunctionTypeParam(!0)),
                  (s.this.name = null),
                  this.match(11) || this.expect(12));
              !this.match(11) && !this.match(21);

            )
              s.params.push(this.flowParseFunctionTypeParam(!1)),
                this.match(11) || this.expect(12)
            return (
              this.eat(21) && (s.rest = this.flowParseFunctionTypeParam(!1)),
              this.expect(11),
              (s.returnType = this.flowParseTypeInitialiser()),
              this.finishNode(s, 'FunctionTypeAnnotation')
            )
          }
          flowParseObjectTypeCallProperty(s, i) {
            let r = this.startNode()
            return (
              (s.static = i),
              (s.value = this.flowParseObjectTypeMethodish(r)),
              this.finishNode(s, 'ObjectTypeCallProperty')
            )
          }
          flowParseObjectType({
            allowStatic: s,
            allowExact: i,
            allowSpread: r,
            allowProto: n,
            allowInexact: a,
          }) {
            let o = this.state.inType
            this.state.inType = !0
            let u = this.startNode()
            ;(u.callProperties = []),
              (u.properties = []),
              (u.indexers = []),
              (u.internalSlots = [])
            let l,
              c,
              f = !1
            for (
              i && this.match(6)
                ? (this.expect(6), (l = 9), (c = !0))
                : (this.expect(5), (l = 8), (c = !1)),
                u.exact = c;
              !this.match(l);

            ) {
              let p = !1,
                m = null,
                y = null,
                x = this.startNode()
              if (n && this.isContextual(118)) {
                let E = this.lookahead()
                E.type !== 14 &&
                  E.type !== 17 &&
                  (this.next(), (m = this.state.startLoc), (s = !1))
              }
              if (s && this.isContextual(106)) {
                let E = this.lookahead()
                E.type !== 14 && E.type !== 17 && (this.next(), (p = !0))
              }
              let C = this.flowParseVariance()
              if (this.eat(0))
                m != null && this.unexpected(m),
                  this.eat(0)
                    ? (C && this.unexpected(C.loc.start),
                      u.internalSlots.push(
                        this.flowParseObjectTypeInternalSlot(x, p)
                      ))
                    : u.indexers.push(this.flowParseObjectTypeIndexer(x, p, C))
              else if (this.match(10) || this.match(47))
                m != null && this.unexpected(m),
                  C && this.unexpected(C.loc.start),
                  u.callProperties.push(
                    this.flowParseObjectTypeCallProperty(x, p)
                  )
              else {
                let E = 'init'
                if (this.isContextual(99) || this.isContextual(104)) {
                  let S = this.lookahead()
                  Gg(S.type) && ((E = this.state.value), this.next())
                }
                let g = this.flowParseObjectTypeProperty(
                  x,
                  p,
                  m,
                  C,
                  E,
                  r,
                  a != null ? a : !c
                )
                g === null
                  ? ((f = !0), (y = this.state.lastTokStartLoc))
                  : u.properties.push(g)
              }
              this.flowObjectTypeSemicolon(),
                y &&
                  !this.match(8) &&
                  !this.match(9) &&
                  this.raise(be.UnexpectedExplicitInexactInObject, y)
            }
            this.expect(l), r && (u.inexact = f)
            let h = this.finishNode(u, 'ObjectTypeAnnotation')
            return (this.state.inType = o), h
          }
          flowParseObjectTypeProperty(s, i, r, n, a, o, u) {
            if (this.eat(21))
              return this.match(12) ||
                this.match(13) ||
                this.match(8) ||
                this.match(9)
                ? (o
                    ? u ||
                      this.raise(
                        be.InexactInsideExact,
                        this.state.lastTokStartLoc
                      )
                    : this.raise(
                        be.InexactInsideNonObject,
                        this.state.lastTokStartLoc
                      ),
                  n && this.raise(be.InexactVariance, n),
                  null)
                : (o ||
                    this.raise(
                      be.UnexpectedSpreadType,
                      this.state.lastTokStartLoc
                    ),
                  r != null && this.unexpected(r),
                  n && this.raise(be.SpreadVariance, n),
                  (s.argument = this.flowParseType()),
                  this.finishNode(s, 'ObjectTypeSpreadProperty'))
            {
              ;(s.key = this.flowParseObjectPropertyKey()),
                (s.static = i),
                (s.proto = r != null),
                (s.kind = a)
              let l = !1
              return (
                this.match(47) || this.match(10)
                  ? ((s.method = !0),
                    r != null && this.unexpected(r),
                    n && this.unexpected(n.loc.start),
                    (s.value = this.flowParseObjectTypeMethodish(
                      this.startNodeAt(s.loc.start)
                    )),
                    (a === 'get' || a === 'set') &&
                      this.flowCheckGetterSetterParams(s),
                    !o &&
                      s.key.name === 'constructor' &&
                      s.value.this &&
                      this.raise(be.ThisParamBannedInConstructor, s.value.this))
                  : (a !== 'init' && this.unexpected(),
                    (s.method = !1),
                    this.eat(17) && (l = !0),
                    (s.value = this.flowParseTypeInitialiser()),
                    (s.variance = n)),
                (s.optional = l),
                this.finishNode(s, 'ObjectTypeProperty')
              )
            }
          }
          flowCheckGetterSetterParams(s) {
            let i = s.kind === 'get' ? 0 : 1,
              r = s.value.params.length + (s.value.rest ? 1 : 0)
            s.value.this &&
              this.raise(
                s.kind === 'get'
                  ? be.GetterMayNotHaveThisParam
                  : be.SetterMayNotHaveThisParam,
                s.value.this
              ),
              r !== i &&
                this.raise(
                  s.kind === 'get' ? R.BadGetterArity : R.BadSetterArity,
                  s
                ),
              s.kind === 'set' &&
                s.value.rest &&
                this.raise(R.BadSetterRestParameter, s)
          }
          flowObjectTypeSemicolon() {
            !this.eat(13) &&
              !this.eat(12) &&
              !this.match(8) &&
              !this.match(9) &&
              this.unexpected()
          }
          flowParseQualifiedTypeIdentifier(s, i) {
            var r
            ;(r = s) != null || (s = this.state.startLoc)
            let n = i || this.flowParseRestrictedIdentifier(!0)
            for (; this.eat(16); ) {
              let a = this.startNodeAt(s)
              ;(a.qualification = n),
                (a.id = this.flowParseRestrictedIdentifier(!0)),
                (n = this.finishNode(a, 'QualifiedTypeIdentifier'))
            }
            return n
          }
          flowParseGenericType(s, i) {
            let r = this.startNodeAt(s)
            return (
              (r.typeParameters = null),
              (r.id = this.flowParseQualifiedTypeIdentifier(s, i)),
              this.match(47) &&
                (r.typeParameters = this.flowParseTypeParameterInstantiation()),
              this.finishNode(r, 'GenericTypeAnnotation')
            )
          }
          flowParseTypeofType() {
            let s = this.startNode()
            return (
              this.expect(87),
              (s.argument = this.flowParsePrimaryType()),
              this.finishNode(s, 'TypeofTypeAnnotation')
            )
          }
          flowParseTupleType() {
            let s = this.startNode()
            for (
              s.types = [], this.expect(0);
              this.state.pos < this.length &&
              !this.match(3) &&
              (s.types.push(this.flowParseType()), !this.match(3));

            )
              this.expect(12)
            return this.expect(3), this.finishNode(s, 'TupleTypeAnnotation')
          }
          flowParseFunctionTypeParam(s) {
            let i = null,
              r = !1,
              n = null,
              a = this.startNode(),
              o = this.lookahead(),
              u = this.state.type === 78
            return (
              o.type === 14 || o.type === 17
                ? (u && !s && this.raise(be.ThisParamMustBeFirst, a),
                  (i = this.parseIdentifier(u)),
                  this.eat(17) &&
                    ((r = !0),
                    u && this.raise(be.ThisParamMayNotBeOptional, a)),
                  (n = this.flowParseTypeInitialiser()))
                : (n = this.flowParseType()),
              (a.name = i),
              (a.optional = r),
              (a.typeAnnotation = n),
              this.finishNode(a, 'FunctionTypeParam')
            )
          }
          reinterpretTypeAsFunctionTypeParam(s) {
            let i = this.startNodeAt(s.loc.start)
            return (
              (i.name = null),
              (i.optional = !1),
              (i.typeAnnotation = s),
              this.finishNode(i, 'FunctionTypeParam')
            )
          }
          flowParseFunctionTypeParams(s = []) {
            let i = null,
              r = null
            for (
              this.match(78) &&
              ((r = this.flowParseFunctionTypeParam(!0)),
              (r.name = null),
              this.match(11) || this.expect(12));
              !this.match(11) && !this.match(21);

            )
              s.push(this.flowParseFunctionTypeParam(!1)),
                this.match(11) || this.expect(12)
            return (
              this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)),
              { params: s, rest: i, _this: r }
            )
          }
          flowIdentToTypeAnnotation(s, i, r) {
            switch (r.name) {
              case 'any':
                return this.finishNode(i, 'AnyTypeAnnotation')
              case 'bool':
              case 'boolean':
                return this.finishNode(i, 'BooleanTypeAnnotation')
              case 'mixed':
                return this.finishNode(i, 'MixedTypeAnnotation')
              case 'empty':
                return this.finishNode(i, 'EmptyTypeAnnotation')
              case 'number':
                return this.finishNode(i, 'NumberTypeAnnotation')
              case 'string':
                return this.finishNode(i, 'StringTypeAnnotation')
              case 'symbol':
                return this.finishNode(i, 'SymbolTypeAnnotation')
              default:
                return (
                  this.checkNotUnderscore(r.name),
                  this.flowParseGenericType(s, r)
                )
            }
          }
          flowParsePrimaryType() {
            let s = this.state.startLoc,
              i = this.startNode(),
              r,
              n,
              a = !1,
              o = this.state.noAnonFunctionType
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({
                  allowStatic: !1,
                  allowExact: !1,
                  allowSpread: !0,
                  allowProto: !1,
                  allowInexact: !0,
                })
              case 6:
                return this.flowParseObjectType({
                  allowStatic: !1,
                  allowExact: !0,
                  allowSpread: !0,
                  allowProto: !1,
                  allowInexact: !1,
                })
              case 0:
                return (
                  (this.state.noAnonFunctionType = !1),
                  (n = this.flowParseTupleType()),
                  (this.state.noAnonFunctionType = o),
                  n
                )
              case 47: {
                let u = this.startNode()
                return (
                  (u.typeParameters = this.flowParseTypeParameterDeclaration()),
                  this.expect(10),
                  (r = this.flowParseFunctionTypeParams()),
                  (u.params = r.params),
                  (u.rest = r.rest),
                  (u.this = r._this),
                  this.expect(11),
                  this.expect(19),
                  (u.returnType = this.flowParseType()),
                  this.finishNode(u, 'FunctionTypeAnnotation')
                )
              }
              case 10: {
                let u = this.startNode()
                if ((this.next(), !this.match(11) && !this.match(21)))
                  if (Ve(this.state.type) || this.match(78)) {
                    let l = this.lookahead().type
                    a = l !== 17 && l !== 14
                  } else a = !0
                if (a) {
                  if (
                    ((this.state.noAnonFunctionType = !1),
                    (n = this.flowParseType()),
                    (this.state.noAnonFunctionType = o),
                    this.state.noAnonFunctionType ||
                      !(
                        this.match(12) ||
                        (this.match(11) && this.lookahead().type === 19)
                      ))
                  )
                    return this.expect(11), n
                  this.eat(12)
                }
                return (
                  n
                    ? (r = this.flowParseFunctionTypeParams([
                        this.reinterpretTypeAsFunctionTypeParam(n),
                      ]))
                    : (r = this.flowParseFunctionTypeParams()),
                  (u.params = r.params),
                  (u.rest = r.rest),
                  (u.this = r._this),
                  this.expect(11),
                  this.expect(19),
                  (u.returnType = this.flowParseType()),
                  (u.typeParameters = null),
                  this.finishNode(u, 'FunctionTypeAnnotation')
                )
              }
              case 133:
                return this.parseLiteral(
                  this.state.value,
                  'StringLiteralTypeAnnotation'
                )
              case 85:
              case 86:
                return (
                  (i.value = this.match(85)),
                  this.next(),
                  this.finishNode(i, 'BooleanLiteralTypeAnnotation')
                )
              case 53:
                if (this.state.value === '-') {
                  if ((this.next(), this.match(134)))
                    return this.parseLiteralAtNode(
                      -this.state.value,
                      'NumberLiteralTypeAnnotation',
                      i
                    )
                  if (this.match(135))
                    return this.parseLiteralAtNode(
                      -this.state.value,
                      'BigIntLiteralTypeAnnotation',
                      i
                    )
                  throw this.raise(
                    be.UnexpectedSubtractionOperand,
                    this.state.startLoc
                  )
                }
                this.unexpected()
                return
              case 134:
                return this.parseLiteral(
                  this.state.value,
                  'NumberLiteralTypeAnnotation'
                )
              case 135:
                return this.parseLiteral(
                  this.state.value,
                  'BigIntLiteralTypeAnnotation'
                )
              case 88:
                return this.next(), this.finishNode(i, 'VoidTypeAnnotation')
              case 84:
                return (
                  this.next(), this.finishNode(i, 'NullLiteralTypeAnnotation')
                )
              case 78:
                return this.next(), this.finishNode(i, 'ThisTypeAnnotation')
              case 55:
                return this.next(), this.finishNode(i, 'ExistsTypeAnnotation')
              case 87:
                return this.flowParseTypeofType()
              default:
                if (Ah(this.state.type)) {
                  let u = Zi(this.state.type)
                  return this.next(), super.createIdentifier(i, u)
                } else if (Ve(this.state.type))
                  return this.isContextual(129)
                    ? this.flowParseInterfaceType()
                    : this.flowIdentToTypeAnnotation(
                        s,
                        i,
                        this.parseIdentifier()
                      )
            }
            this.unexpected()
          }
          flowParsePostfixType() {
            let s = this.state.startLoc,
              i = this.flowParsePrimaryType(),
              r = !1
            for (
              ;
              (this.match(0) || this.match(18)) && !this.canInsertSemicolon();

            ) {
              let n = this.startNodeAt(s),
                a = this.eat(18)
              ;(r = r || a),
                this.expect(0),
                !a && this.match(3)
                  ? ((n.elementType = i),
                    this.next(),
                    (i = this.finishNode(n, 'ArrayTypeAnnotation')))
                  : ((n.objectType = i),
                    (n.indexType = this.flowParseType()),
                    this.expect(3),
                    r
                      ? ((n.optional = a),
                        (i = this.finishNode(n, 'OptionalIndexedAccessType')))
                      : (i = this.finishNode(n, 'IndexedAccessType')))
            }
            return i
          }
          flowParsePrefixType() {
            let s = this.startNode()
            return this.eat(17)
              ? ((s.typeAnnotation = this.flowParsePrefixType()),
                this.finishNode(s, 'NullableTypeAnnotation'))
              : this.flowParsePostfixType()
          }
          flowParseAnonFunctionWithoutParens() {
            let s = this.flowParsePrefixType()
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              let i = this.startNodeAt(s.loc.start)
              return (
                (i.params = [this.reinterpretTypeAsFunctionTypeParam(s)]),
                (i.rest = null),
                (i.this = null),
                (i.returnType = this.flowParseType()),
                (i.typeParameters = null),
                this.finishNode(i, 'FunctionTypeAnnotation')
              )
            }
            return s
          }
          flowParseIntersectionType() {
            let s = this.startNode()
            this.eat(45)
            let i = this.flowParseAnonFunctionWithoutParens()
            for (s.types = [i]; this.eat(45); )
              s.types.push(this.flowParseAnonFunctionWithoutParens())
            return s.types.length === 1
              ? i
              : this.finishNode(s, 'IntersectionTypeAnnotation')
          }
          flowParseUnionType() {
            let s = this.startNode()
            this.eat(43)
            let i = this.flowParseIntersectionType()
            for (s.types = [i]; this.eat(43); )
              s.types.push(this.flowParseIntersectionType())
            return s.types.length === 1
              ? i
              : this.finishNode(s, 'UnionTypeAnnotation')
          }
          flowParseType() {
            let s = this.state.inType
            this.state.inType = !0
            let i = this.flowParseUnionType()
            return (this.state.inType = s), i
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 132 && this.state.value === '_') {
              let s = this.state.startLoc,
                i = this.parseIdentifier()
              return this.flowParseGenericType(s, i)
            } else return this.flowParseType()
          }
          flowParseTypeAnnotation() {
            let s = this.startNode()
            return (
              (s.typeAnnotation = this.flowParseTypeInitialiser()),
              this.finishNode(s, 'TypeAnnotation')
            )
          }
          flowParseTypeAnnotatableIdentifier(s) {
            let i = s
              ? this.parseIdentifier()
              : this.flowParseRestrictedIdentifier()
            return (
              this.match(14) &&
                ((i.typeAnnotation = this.flowParseTypeAnnotation()),
                this.resetEndLocation(i)),
              i
            )
          }
          typeCastToParameter(s) {
            return (
              (s.expression.typeAnnotation = s.typeAnnotation),
              this.resetEndLocation(s.expression, s.typeAnnotation.loc.end),
              s.expression
            )
          }
          flowParseVariance() {
            let s = null
            return this.match(53)
              ? ((s = this.startNode()),
                this.state.value === '+'
                  ? (s.kind = 'plus')
                  : (s.kind = 'minus'),
                this.next(),
                this.finishNode(s, 'Variance'))
              : s
          }
          parseFunctionBody(s, i, r = !1) {
            if (i) {
              this.forwardNoArrowParamsConversionAt(s, () =>
                super.parseFunctionBody(s, !0, r)
              )
              return
            }
            super.parseFunctionBody(s, !1, r)
          }
          parseFunctionBodyAndFinish(s, i, r = !1) {
            if (this.match(14)) {
              let n = this.startNode()
              ;([n.typeAnnotation, s.predicate] =
                this.flowParseTypeAndPredicateInitialiser()),
                (s.returnType = n.typeAnnotation
                  ? this.finishNode(n, 'TypeAnnotation')
                  : null)
            }
            return super.parseFunctionBodyAndFinish(s, i, r)
          }
          parseStatementLike(s) {
            if (this.state.strict && this.isContextual(129)) {
              let r = this.lookahead()
              if (Hs(r.type)) {
                let n = this.startNode()
                return this.next(), this.flowParseInterface(n)
              }
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              let r = this.startNode()
              return this.next(), this.flowParseEnumDeclaration(r)
            }
            let i = super.parseStatementLike(s)
            return (
              this.flowPragma === void 0 &&
                !this.isValidDirective(i) &&
                (this.flowPragma = null),
              i
            )
          }
          parseExpressionStatement(s, i, r) {
            if (i.type === 'Identifier') {
              if (i.name === 'declare') {
                if (
                  this.match(80) ||
                  Ve(this.state.type) ||
                  this.match(68) ||
                  this.match(74) ||
                  this.match(82)
                )
                  return this.flowParseDeclare(s)
              } else if (Ve(this.state.type)) {
                if (i.name === 'interface') return this.flowParseInterface(s)
                if (i.name === 'type') return this.flowParseTypeAlias(s)
                if (i.name === 'opaque') return this.flowParseOpaqueType(s, !1)
              }
            }
            return super.parseExpressionStatement(s, i, r)
          }
          shouldParseExportDeclaration() {
            let { type: s } = this.state
            return Wg(s) || (this.shouldParseEnums() && s === 126)
              ? !this.state.containsEsc
              : super.shouldParseExportDeclaration()
          }
          isExportDefaultSpecifier() {
            let { type: s } = this.state
            return Wg(s) || (this.shouldParseEnums() && s === 126)
              ? this.state.containsEsc
              : super.isExportDefaultSpecifier()
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(126)) {
              let s = this.startNode()
              return this.next(), this.flowParseEnumDeclaration(s)
            }
            return super.parseExportDefaultExpression()
          }
          parseConditional(s, i, r) {
            if (!this.match(17)) return s
            if (this.state.maybeInArrowParameters) {
              let h = this.lookaheadCharCode()
              if (h === 44 || h === 61 || h === 58 || h === 41)
                return this.setOptionalParametersError(r), s
            }
            this.expect(17)
            let n = this.state.clone(),
              a = this.state.noArrowAt,
              o = this.startNodeAt(i),
              { consequent: u, failed: l } =
                this.tryParseConditionalConsequent(),
              [c, f] = this.getArrowLikeExpressions(u)
            if (l || f.length > 0) {
              let h = [...a]
              if (f.length > 0) {
                ;(this.state = n), (this.state.noArrowAt = h)
                for (let p = 0; p < f.length; p++) h.push(f[p].start)
                ;({ consequent: u, failed: l } =
                  this.tryParseConditionalConsequent()),
                  ([c, f] = this.getArrowLikeExpressions(u))
              }
              l &&
                c.length > 1 &&
                this.raise(be.AmbiguousConditionalArrow, n.startLoc),
                l &&
                  c.length === 1 &&
                  ((this.state = n),
                  h.push(c[0].start),
                  (this.state.noArrowAt = h),
                  ({ consequent: u, failed: l } =
                    this.tryParseConditionalConsequent()))
            }
            return (
              this.getArrowLikeExpressions(u, !0),
              (this.state.noArrowAt = a),
              this.expect(14),
              (o.test = s),
              (o.consequent = u),
              (o.alternate = this.forwardNoArrowParamsConversionAt(o, () =>
                this.parseMaybeAssign(void 0, void 0)
              )),
              this.finishNode(o, 'ConditionalExpression')
            )
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start)
            let s = this.parseMaybeAssignAllowIn(),
              i = !this.match(14)
            return (
              this.state.noArrowParamsConversionAt.pop(),
              { consequent: s, failed: i }
            )
          }
          getArrowLikeExpressions(s, i) {
            let r = [s],
              n = []
            for (; r.length !== 0; ) {
              let a = r.pop()
              a.type === 'ArrowFunctionExpression' &&
              a.body.type !== 'BlockStatement'
                ? (a.typeParameters || !a.returnType
                    ? this.finishArrowValidation(a)
                    : n.push(a),
                  r.push(a.body))
                : a.type === 'ConditionalExpression' &&
                  (r.push(a.consequent), r.push(a.alternate))
            }
            return i
              ? (n.forEach((a) => this.finishArrowValidation(a)), [n, []])
              : Nv(n, (a) => a.params.every((o) => this.isAssignable(o, !0)))
          }
          finishArrowValidation(s) {
            var i
            this.toAssignableList(
              s.params,
              (i = s.extra) == null ? void 0 : i.trailingCommaLoc,
              !1
            ),
              this.scope.enter(2 | 4),
              super.checkParams(s, !1, !0),
              this.scope.exit()
          }
          forwardNoArrowParamsConversionAt(s, i) {
            let r
            return (
              this.state.noArrowParamsConversionAt.includes(s.start)
                ? (this.state.noArrowParamsConversionAt.push(this.state.start),
                  (r = i()),
                  this.state.noArrowParamsConversionAt.pop())
                : (r = i()),
              r
            )
          }
          parseParenItem(s, i) {
            let r = super.parseParenItem(s, i)
            if (
              (this.eat(17) && ((r.optional = !0), this.resetEndLocation(s)),
              this.match(14))
            ) {
              let n = this.startNodeAt(i)
              return (
                (n.expression = r),
                (n.typeAnnotation = this.flowParseTypeAnnotation()),
                this.finishNode(n, 'TypeCastExpression')
              )
            }
            return r
          }
          assertModuleNodeAllowed(s) {
            ;(s.type === 'ImportDeclaration' &&
              (s.importKind === 'type' || s.importKind === 'typeof')) ||
              (s.type === 'ExportNamedDeclaration' &&
                s.exportKind === 'type') ||
              (s.type === 'ExportAllDeclaration' && s.exportKind === 'type') ||
              super.assertModuleNodeAllowed(s)
          }
          parseExportDeclaration(s) {
            if (this.isContextual(130)) {
              s.exportKind = 'type'
              let i = this.startNode()
              return (
                this.next(),
                this.match(5)
                  ? ((s.specifiers = this.parseExportSpecifiers(!0)),
                    super.parseExportFrom(s),
                    null)
                  : this.flowParseTypeAlias(i)
              )
            } else if (this.isContextual(131)) {
              s.exportKind = 'type'
              let i = this.startNode()
              return this.next(), this.flowParseOpaqueType(i, !1)
            } else if (this.isContextual(129)) {
              s.exportKind = 'type'
              let i = this.startNode()
              return this.next(), this.flowParseInterface(i)
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              s.exportKind = 'value'
              let i = this.startNode()
              return this.next(), this.flowParseEnumDeclaration(i)
            } else return super.parseExportDeclaration(s)
          }
          eatExportStar(s) {
            return super.eatExportStar(s)
              ? !0
              : this.isContextual(130) && this.lookahead().type === 55
              ? ((s.exportKind = 'type'), this.next(), this.next(), !0)
              : !1
          }
          maybeParseExportNamespaceSpecifier(s) {
            let { startLoc: i } = this.state,
              r = super.maybeParseExportNamespaceSpecifier(s)
            return r && s.exportKind === 'type' && this.unexpected(i), r
          }
          parseClassId(s, i, r) {
            super.parseClassId(s, i, r),
              this.match(47) &&
                (s.typeParameters = this.flowParseTypeParameterDeclaration())
          }
          parseClassMember(s, i, r) {
            let { startLoc: n } = this.state
            if (this.isContextual(125)) {
              if (super.parseClassMemberFromModifier(s, i)) return
              i.declare = !0
            }
            super.parseClassMember(s, i, r),
              i.declare &&
                (i.type !== 'ClassProperty' &&
                i.type !== 'ClassPrivateProperty' &&
                i.type !== 'PropertyDefinition'
                  ? this.raise(be.DeclareClassElement, n)
                  : i.value &&
                    this.raise(be.DeclareClassFieldInitializer, i.value))
          }
          isIterator(s) {
            return s === 'iterator' || s === 'asyncIterator'
          }
          readIterator() {
            let s = super.readWord1(),
              i = '@@' + s
            ;(!this.isIterator(s) || !this.state.inType) &&
              this.raise(R.InvalidIdentifier, this.state.curPosition(), {
                identifierName: i,
              }),
              this.finishToken(132, i)
          }
          getTokenFromCode(s) {
            let i = this.input.charCodeAt(this.state.pos + 1)
            s === 123 && i === 124
              ? this.finishOp(6, 2)
              : this.state.inType && (s === 62 || s === 60)
              ? this.finishOp(s === 62 ? 48 : 47, 1)
              : this.state.inType && s === 63
              ? i === 46
                ? this.finishOp(18, 2)
                : this.finishOp(17, 1)
              : fv(s, i, this.input.charCodeAt(this.state.pos + 2))
              ? ((this.state.pos += 2), this.readIterator())
              : super.getTokenFromCode(s)
          }
          isAssignable(s, i) {
            return s.type === 'TypeCastExpression'
              ? this.isAssignable(s.expression, i)
              : super.isAssignable(s, i)
          }
          toAssignable(s, i = !1) {
            !i &&
              s.type === 'AssignmentExpression' &&
              s.left.type === 'TypeCastExpression' &&
              (s.left = this.typeCastToParameter(s.left)),
              super.toAssignable(s, i)
          }
          toAssignableList(s, i, r) {
            for (let n = 0; n < s.length; n++) {
              let a = s[n]
              ;(a == null ? void 0 : a.type) === 'TypeCastExpression' &&
                (s[n] = this.typeCastToParameter(a))
            }
            super.toAssignableList(s, i, r)
          }
          toReferencedList(s, i) {
            for (let n = 0; n < s.length; n++) {
              var r
              let a = s[n]
              a &&
                a.type === 'TypeCastExpression' &&
                !((r = a.extra) != null && r.parenthesized) &&
                (s.length > 1 || !i) &&
                this.raise(be.TypeCastInPattern, a.typeAnnotation)
            }
            return s
          }
          parseArrayLike(s, i, r, n) {
            let a = super.parseArrayLike(s, i, r, n)
            return (
              i &&
                !this.state.maybeInArrowParameters &&
                this.toReferencedList(a.elements),
              a
            )
          }
          isValidLVal(s, i, r) {
            return s === 'TypeCastExpression' || super.isValidLVal(s, i, r)
          }
          parseClassProperty(s) {
            return (
              this.match(14) &&
                (s.typeAnnotation = this.flowParseTypeAnnotation()),
              super.parseClassProperty(s)
            )
          }
          parseClassPrivateProperty(s) {
            return (
              this.match(14) &&
                (s.typeAnnotation = this.flowParseTypeAnnotation()),
              super.parseClassPrivateProperty(s)
            )
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod()
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty()
          }
          isNonstaticConstructor(s) {
            return !this.match(14) && super.isNonstaticConstructor(s)
          }
          pushClassMethod(s, i, r, n, a, o) {
            if (
              (i.variance && this.unexpected(i.variance.loc.start),
              delete i.variance,
              this.match(47) &&
                (i.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.pushClassMethod(s, i, r, n, a, o),
              i.params && a)
            ) {
              let u = i.params
              u.length > 0 &&
                this.isThisParam(u[0]) &&
                this.raise(be.ThisParamBannedInConstructor, i)
            } else if (i.type === 'MethodDefinition' && a && i.value.params) {
              let u = i.value.params
              u.length > 0 &&
                this.isThisParam(u[0]) &&
                this.raise(be.ThisParamBannedInConstructor, i)
            }
          }
          pushClassPrivateMethod(s, i, r, n) {
            i.variance && this.unexpected(i.variance.loc.start),
              delete i.variance,
              this.match(47) &&
                (i.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.pushClassPrivateMethod(s, i, r, n)
          }
          parseClassSuper(s) {
            if (
              (super.parseClassSuper(s),
              s.superClass &&
                this.match(47) &&
                (s.superTypeParameters =
                  this.flowParseTypeParameterInstantiation()),
              this.isContextual(113))
            ) {
              this.next()
              let i = (s.implements = [])
              do {
                let r = this.startNode()
                ;(r.id = this.flowParseRestrictedIdentifier(!0)),
                  this.match(47)
                    ? (r.typeParameters =
                        this.flowParseTypeParameterInstantiation())
                    : (r.typeParameters = null),
                  i.push(this.finishNode(r, 'ClassImplements'))
              } while (this.eat(12))
            }
          }
          checkGetterSetterParams(s) {
            super.checkGetterSetterParams(s)
            let i = this.getObjectOrClassMethodParams(s)
            if (i.length > 0) {
              let r = i[0]
              this.isThisParam(r) && s.kind === 'get'
                ? this.raise(be.GetterMayNotHaveThisParam, r)
                : this.isThisParam(r) &&
                  this.raise(be.SetterMayNotHaveThisParam, r)
            }
          }
          parsePropertyNamePrefixOperator(s) {
            s.variance = this.flowParseVariance()
          }
          parseObjPropValue(s, i, r, n, a, o, u) {
            s.variance && this.unexpected(s.variance.loc.start),
              delete s.variance
            let l
            this.match(47) &&
              !o &&
              ((l = this.flowParseTypeParameterDeclaration()),
              this.match(10) || this.unexpected())
            let c = super.parseObjPropValue(s, i, r, n, a, o, u)
            return l && ((c.value || c).typeParameters = l), c
          }
          parseAssignableListItemTypes(s) {
            return (
              this.eat(17) &&
                (s.type !== 'Identifier' && this.raise(be.PatternIsOptional, s),
                this.isThisParam(s) &&
                  this.raise(be.ThisParamMayNotBeOptional, s),
                (s.optional = !0)),
              this.match(14)
                ? (s.typeAnnotation = this.flowParseTypeAnnotation())
                : this.isThisParam(s) &&
                  this.raise(be.ThisParamAnnotationRequired, s),
              this.match(29) &&
                this.isThisParam(s) &&
                this.raise(be.ThisParamNoDefault, s),
              this.resetEndLocation(s),
              s
            )
          }
          parseMaybeDefault(s, i) {
            let r = super.parseMaybeDefault(s, i)
            return (
              r.type === 'AssignmentPattern' &&
                r.typeAnnotation &&
                r.right.start < r.typeAnnotation.start &&
                this.raise(be.TypeBeforeInitializer, r.typeAnnotation),
              r
            )
          }
          checkImportReflection(s) {
            super.checkImportReflection(s),
              s.module &&
                s.importKind !== 'value' &&
                this.raise(
                  be.ImportReflectionHasImportType,
                  s.specifiers[0].loc.start
                )
          }
          parseImportSpecifierLocal(s, i, r) {
            ;(i.local = S1(s)
              ? this.flowParseRestrictedIdentifier(!0, !0)
              : this.parseIdentifier()),
              s.specifiers.push(this.finishImportSpecifier(i, r))
          }
          isPotentialImportPhase(s) {
            if (super.isPotentialImportPhase(s)) return !0
            if (this.isContextual(130)) {
              if (!s) return !0
              let i = this.lookaheadCharCode()
              return i === 123 || i === 42
            }
            return !s && this.isContextual(87)
          }
          applyImportPhase(s, i, r, n) {
            if ((super.applyImportPhase(s, i, r, n), i)) {
              if (!r && this.match(65)) return
              s.exportKind = r === 'type' ? r : 'value'
            } else
              r === 'type' && this.match(55) && this.unexpected(),
                (s.importKind = r === 'type' || r === 'typeof' ? r : 'value')
          }
          parseImportSpecifier(s, i, r, n, a) {
            let o = s.imported,
              u = null
            o.type === 'Identifier' &&
              (o.name === 'type'
                ? (u = 'type')
                : o.name === 'typeof' && (u = 'typeof'))
            let l = !1
            if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
              let f = this.parseIdentifier(!0)
              u !== null && !Hs(this.state.type)
                ? ((s.imported = f), (s.importKind = u), (s.local = bi(f)))
                : ((s.imported = o),
                  (s.importKind = null),
                  (s.local = this.parseIdentifier()))
            } else {
              if (u !== null && Hs(this.state.type))
                (s.imported = this.parseIdentifier(!0)), (s.importKind = u)
              else {
                if (i)
                  throw this.raise(R.ImportBindingIsString, s, {
                    importName: o.value,
                  })
                ;(s.imported = o), (s.importKind = null)
              }
              this.eatContextual(93)
                ? (s.local = this.parseIdentifier())
                : ((l = !0), (s.local = bi(s.imported)))
            }
            let c = S1(s)
            return (
              r && c && this.raise(be.ImportTypeShorthandOnlyInPureImport, s),
              (r || c) &&
                this.checkReservedType(s.local.name, s.local.loc.start, !0),
              l &&
                !r &&
                !c &&
                this.checkReservedWord(s.local.name, s.loc.start, !0, !0),
              this.finishImportSpecifier(s, 'ImportSpecifier')
            )
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 78:
                return this.parseIdentifier(!0)
              default:
                return super.parseBindingAtom()
            }
          }
          parseFunctionParams(s, i) {
            let r = s.kind
            r !== 'get' &&
              r !== 'set' &&
              this.match(47) &&
              (s.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.parseFunctionParams(s, i)
          }
          parseVarId(s, i) {
            super.parseVarId(s, i),
              this.match(14) &&
                ((s.id.typeAnnotation = this.flowParseTypeAnnotation()),
                this.resetEndLocation(s.id))
          }
          parseAsyncArrowFromCallExpression(s, i) {
            if (this.match(14)) {
              let r = this.state.noAnonFunctionType
              ;(this.state.noAnonFunctionType = !0),
                (s.returnType = this.flowParseTypeAnnotation()),
                (this.state.noAnonFunctionType = r)
            }
            return super.parseAsyncArrowFromCallExpression(s, i)
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow()
          }
          parseMaybeAssign(s, i) {
            var r
            let n = null,
              a
            if (this.hasPlugin('jsx') && (this.match(142) || this.match(47))) {
              if (
                ((n = this.state.clone()),
                (a = this.tryParse(() => super.parseMaybeAssign(s, i), n)),
                !a.error)
              )
                return a.node
              let { context: l } = this.state,
                c = l[l.length - 1]
              ;(c === Ke.j_oTag || c === Ke.j_expr) && l.pop()
            }
            if (((r = a) != null && r.error) || this.match(47)) {
              var o, u
              n = n || this.state.clone()
              let l,
                c = this.tryParse((h) => {
                  var p
                  l = this.flowParseTypeParameterDeclaration()
                  let m = this.forwardNoArrowParamsConversionAt(l, () => {
                    let x = super.parseMaybeAssign(s, i)
                    return this.resetStartLocationFromNode(x, l), x
                  })
                  ;(p = m.extra) != null && p.parenthesized && h()
                  let y = this.maybeUnwrapTypeCastExpression(m)
                  return (
                    y.type !== 'ArrowFunctionExpression' && h(),
                    (y.typeParameters = l),
                    this.resetStartLocationFromNode(y, l),
                    m
                  )
                }, n),
                f = null
              if (
                c.node &&
                this.maybeUnwrapTypeCastExpression(c.node).type ===
                  'ArrowFunctionExpression'
              ) {
                if (!c.error && !c.aborted)
                  return (
                    c.node.async &&
                      this.raise(
                        be.UnexpectedTypeParameterBeforeAsyncArrowFunction,
                        l
                      ),
                    c.node
                  )
                f = c.node
              }
              if ((o = a) != null && o.node)
                return (this.state = a.failState), a.node
              if (f) return (this.state = c.failState), f
              throw (u = a) != null && u.thrown
                ? a.error
                : c.thrown
                ? c.error
                : this.raise(be.UnexpectedTokenAfterTypeParameter, l)
            }
            return super.parseMaybeAssign(s, i)
          }
          parseArrow(s) {
            if (this.match(14)) {
              let i = this.tryParse(() => {
                let r = this.state.noAnonFunctionType
                this.state.noAnonFunctionType = !0
                let n = this.startNode()
                return (
                  ([n.typeAnnotation, s.predicate] =
                    this.flowParseTypeAndPredicateInitialiser()),
                  (this.state.noAnonFunctionType = r),
                  this.canInsertSemicolon() && this.unexpected(),
                  this.match(19) || this.unexpected(),
                  n
                )
              })
              if (i.thrown) return null
              i.error && (this.state = i.failState),
                (s.returnType = i.node.typeAnnotation
                  ? this.finishNode(i.node, 'TypeAnnotation')
                  : null)
            }
            return super.parseArrow(s)
          }
          shouldParseArrow(s) {
            return this.match(14) || super.shouldParseArrow(s)
          }
          setArrowFunctionParameters(s, i) {
            this.state.noArrowParamsConversionAt.includes(s.start)
              ? (s.params = i)
              : super.setArrowFunctionParameters(s, i)
          }
          checkParams(s, i, r, n = !0) {
            if (
              !(r && this.state.noArrowParamsConversionAt.includes(s.start))
            ) {
              for (let a = 0; a < s.params.length; a++)
                this.isThisParam(s.params[a]) &&
                  a > 0 &&
                  this.raise(be.ThisParamMustBeFirst, s.params[a])
              super.checkParams(s, i, r, n)
            }
          }
          parseParenAndDistinguishExpression(s) {
            return super.parseParenAndDistinguishExpression(
              s && !this.state.noArrowAt.includes(this.state.start)
            )
          }
          parseSubscripts(s, i, r) {
            if (
              s.type === 'Identifier' &&
              s.name === 'async' &&
              this.state.noArrowAt.includes(i.index)
            ) {
              this.next()
              let n = this.startNodeAt(i)
              ;(n.callee = s),
                (n.arguments = super.parseCallExpressionArguments(11, !1)),
                (s = this.finishNode(n, 'CallExpression'))
            } else if (
              s.type === 'Identifier' &&
              s.name === 'async' &&
              this.match(47)
            ) {
              let n = this.state.clone(),
                a = this.tryParse(
                  (u) => this.parseAsyncArrowWithTypeParameters(i) || u(),
                  n
                )
              if (!a.error && !a.aborted) return a.node
              let o = this.tryParse(() => super.parseSubscripts(s, i, r), n)
              if (o.node && !o.error) return o.node
              if (a.node) return (this.state = a.failState), a.node
              if (o.node) return (this.state = o.failState), o.node
              throw a.error || o.error
            }
            return super.parseSubscripts(s, i, r)
          }
          parseSubscript(s, i, r, n) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (((n.optionalChainMember = !0), r)) return (n.stop = !0), s
              this.next()
              let a = this.startNodeAt(i)
              return (
                (a.callee = s),
                (a.typeArguments = this.flowParseTypeParameterInstantiation()),
                this.expect(10),
                (a.arguments = this.parseCallExpressionArguments(11, !1)),
                (a.optional = !0),
                this.finishCallExpression(a, !0)
              )
            } else if (!r && this.shouldParseTypes() && this.match(47)) {
              let a = this.startNodeAt(i)
              a.callee = s
              let o = this.tryParse(
                () => (
                  (a.typeArguments =
                    this.flowParseTypeParameterInstantiationCallOrNew()),
                  this.expect(10),
                  (a.arguments = super.parseCallExpressionArguments(11, !1)),
                  n.optionalChainMember && (a.optional = !1),
                  this.finishCallExpression(a, n.optionalChainMember)
                )
              )
              if (o.node) return o.error && (this.state = o.failState), o.node
            }
            return super.parseSubscript(s, i, r, n)
          }
          parseNewCallee(s) {
            super.parseNewCallee(s)
            let i = null
            this.shouldParseTypes() &&
              this.match(47) &&
              (i = this.tryParse(() =>
                this.flowParseTypeParameterInstantiationCallOrNew()
              ).node),
              (s.typeArguments = i)
          }
          parseAsyncArrowWithTypeParameters(s) {
            let i = this.startNodeAt(s)
            if ((this.parseFunctionParams(i, !1), !!this.parseArrow(i)))
              return super.parseArrowExpression(i, void 0, !0)
          }
          readToken_mult_modulo(s) {
            let i = this.input.charCodeAt(this.state.pos + 1)
            if (s === 42 && i === 47 && this.state.hasFlowComment) {
              ;(this.state.hasFlowComment = !1),
                (this.state.pos += 2),
                this.nextToken()
              return
            }
            super.readToken_mult_modulo(s)
          }
          readToken_pipe_amp(s) {
            let i = this.input.charCodeAt(this.state.pos + 1)
            if (s === 124 && i === 125) {
              this.finishOp(9, 2)
              return
            }
            super.readToken_pipe_amp(s)
          }
          parseTopLevel(s, i) {
            let r = super.parseTopLevel(s, i)
            return (
              this.state.hasFlowComment &&
                this.raise(
                  be.UnterminatedFlowComment,
                  this.state.curPosition()
                ),
              r
            )
          }
          skipBlockComment() {
            if (this.hasPlugin('flowComments') && this.skipFlowComment()) {
              if (this.state.hasFlowComment)
                throw this.raise(be.NestedFlowComment, this.state.startLoc)
              this.hasFlowCommentCompletion()
              let s = this.skipFlowComment()
              s && ((this.state.pos += s), (this.state.hasFlowComment = !0))
              return
            }
            return super.skipBlockComment(
              this.state.hasFlowComment ? '*-/' : '*/'
            )
          }
          skipFlowComment() {
            let { pos: s } = this.state,
              i = 2
            for (; [32, 9].includes(this.input.charCodeAt(s + i)); ) i++
            let r = this.input.charCodeAt(i + s),
              n = this.input.charCodeAt(i + s + 1)
            return r === 58 && n === 58
              ? i + 2
              : this.input.slice(i + s, i + s + 12) === 'flow-include'
              ? i + 12
              : r === 58 && n !== 58
              ? i
              : !1
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf('*/', this.state.pos) === -1)
              throw this.raise(R.UnterminatedComment, this.state.curPosition())
          }
          flowEnumErrorBooleanMemberNotInitialized(
            s,
            { enumName: i, memberName: r }
          ) {
            this.raise(be.EnumBooleanMemberNotInitialized, s, {
              memberName: r,
              enumName: i,
            })
          }
          flowEnumErrorInvalidMemberInitializer(s, i) {
            return this.raise(
              i.explicitType
                ? i.explicitType === 'symbol'
                  ? be.EnumInvalidMemberInitializerSymbolType
                  : be.EnumInvalidMemberInitializerPrimaryType
                : be.EnumInvalidMemberInitializerUnknownType,
              s,
              i
            )
          }
          flowEnumErrorNumberMemberNotInitialized(s, i) {
            this.raise(be.EnumNumberMemberNotInitialized, s, i)
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(s, i) {
            this.raise(be.EnumStringMemberInconsistentlyInitialized, s, i)
          }
          flowEnumMemberInit() {
            let s = this.state.startLoc,
              i = () => this.match(12) || this.match(8)
            switch (this.state.type) {
              case 134: {
                let r = this.parseNumericLiteral(this.state.value)
                return i()
                  ? { type: 'number', loc: r.loc.start, value: r }
                  : { type: 'invalid', loc: s }
              }
              case 133: {
                let r = this.parseStringLiteral(this.state.value)
                return i()
                  ? { type: 'string', loc: r.loc.start, value: r }
                  : { type: 'invalid', loc: s }
              }
              case 85:
              case 86: {
                let r = this.parseBooleanLiteral(this.match(85))
                return i()
                  ? { type: 'boolean', loc: r.loc.start, value: r }
                  : { type: 'invalid', loc: s }
              }
              default:
                return { type: 'invalid', loc: s }
            }
          }
          flowEnumMemberRaw() {
            let s = this.state.startLoc,
              i = this.parseIdentifier(!0),
              r = this.eat(29)
                ? this.flowEnumMemberInit()
                : { type: 'none', loc: s }
            return { id: i, init: r }
          }
          flowEnumCheckExplicitTypeMismatch(s, i, r) {
            let { explicitType: n } = i
            n !== null &&
              n !== r &&
              this.flowEnumErrorInvalidMemberInitializer(s, i)
          }
          flowEnumMembers({ enumName: s, explicitType: i }) {
            let r = new Set(),
              n = {
                booleanMembers: [],
                numberMembers: [],
                stringMembers: [],
                defaultedMembers: [],
              },
              a = !1
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                a = !0
                break
              }
              let o = this.startNode(),
                { id: u, init: l } = this.flowEnumMemberRaw(),
                c = u.name
              if (c === '') continue
              ;/^[a-z]/.test(c) &&
                this.raise(be.EnumInvalidMemberName, u, {
                  memberName: c,
                  suggestion: c[0].toUpperCase() + c.slice(1),
                  enumName: s,
                }),
                r.has(c) &&
                  this.raise(be.EnumDuplicateMemberName, u, {
                    memberName: c,
                    enumName: s,
                  }),
                r.add(c)
              let f = { enumName: s, explicitType: i, memberName: c }
              switch (((o.id = u), l.type)) {
                case 'boolean': {
                  this.flowEnumCheckExplicitTypeMismatch(l.loc, f, 'boolean'),
                    (o.init = l.value),
                    n.booleanMembers.push(
                      this.finishNode(o, 'EnumBooleanMember')
                    )
                  break
                }
                case 'number': {
                  this.flowEnumCheckExplicitTypeMismatch(l.loc, f, 'number'),
                    (o.init = l.value),
                    n.numberMembers.push(this.finishNode(o, 'EnumNumberMember'))
                  break
                }
                case 'string': {
                  this.flowEnumCheckExplicitTypeMismatch(l.loc, f, 'string'),
                    (o.init = l.value),
                    n.stringMembers.push(this.finishNode(o, 'EnumStringMember'))
                  break
                }
                case 'invalid':
                  throw this.flowEnumErrorInvalidMemberInitializer(l.loc, f)
                case 'none':
                  switch (i) {
                    case 'boolean':
                      this.flowEnumErrorBooleanMemberNotInitialized(l.loc, f)
                      break
                    case 'number':
                      this.flowEnumErrorNumberMemberNotInitialized(l.loc, f)
                      break
                    default:
                      n.defaultedMembers.push(
                        this.finishNode(o, 'EnumDefaultedMember')
                      )
                  }
              }
              this.match(8) || this.expect(12)
            }
            return { members: n, hasUnknownMembers: a }
          }
          flowEnumStringMembers(s, i, { enumName: r }) {
            if (s.length === 0) return i
            if (i.length === 0) return s
            if (i.length > s.length) {
              for (let n of s)
                this.flowEnumErrorStringMemberInconsistentlyInitialized(n, {
                  enumName: r,
                })
              return i
            } else {
              for (let n of i)
                this.flowEnumErrorStringMemberInconsistentlyInitialized(n, {
                  enumName: r,
                })
              return s
            }
          }
          flowEnumParseExplicitType({ enumName: s }) {
            if (!this.eatContextual(102)) return null
            if (!Ve(this.state.type))
              throw this.raise(
                be.EnumInvalidExplicitTypeUnknownSupplied,
                this.state.startLoc,
                { enumName: s }
              )
            let { value: i } = this.state
            return (
              this.next(),
              i !== 'boolean' &&
                i !== 'number' &&
                i !== 'string' &&
                i !== 'symbol' &&
                this.raise(be.EnumInvalidExplicitType, this.state.startLoc, {
                  enumName: s,
                  invalidEnumType: i,
                }),
              i
            )
          }
          flowEnumBody(s, i) {
            let r = i.name,
              n = i.loc.start,
              a = this.flowEnumParseExplicitType({ enumName: r })
            this.expect(5)
            let { members: o, hasUnknownMembers: u } = this.flowEnumMembers({
              enumName: r,
              explicitType: a,
            })
            switch (((s.hasUnknownMembers = u), a)) {
              case 'boolean':
                return (
                  (s.explicitType = !0),
                  (s.members = o.booleanMembers),
                  this.expect(8),
                  this.finishNode(s, 'EnumBooleanBody')
                )
              case 'number':
                return (
                  (s.explicitType = !0),
                  (s.members = o.numberMembers),
                  this.expect(8),
                  this.finishNode(s, 'EnumNumberBody')
                )
              case 'string':
                return (
                  (s.explicitType = !0),
                  (s.members = this.flowEnumStringMembers(
                    o.stringMembers,
                    o.defaultedMembers,
                    { enumName: r }
                  )),
                  this.expect(8),
                  this.finishNode(s, 'EnumStringBody')
                )
              case 'symbol':
                return (
                  (s.members = o.defaultedMembers),
                  this.expect(8),
                  this.finishNode(s, 'EnumSymbolBody')
                )
              default: {
                let l = () => (
                  (s.members = []),
                  this.expect(8),
                  this.finishNode(s, 'EnumStringBody')
                )
                s.explicitType = !1
                let c = o.booleanMembers.length,
                  f = o.numberMembers.length,
                  h = o.stringMembers.length,
                  p = o.defaultedMembers.length
                if (!c && !f && !h && !p) return l()
                if (!c && !f)
                  return (
                    (s.members = this.flowEnumStringMembers(
                      o.stringMembers,
                      o.defaultedMembers,
                      { enumName: r }
                    )),
                    this.expect(8),
                    this.finishNode(s, 'EnumStringBody')
                  )
                if (!f && !h && c >= p) {
                  for (let m of o.defaultedMembers)
                    this.flowEnumErrorBooleanMemberNotInitialized(m.loc.start, {
                      enumName: r,
                      memberName: m.id.name,
                    })
                  return (
                    (s.members = o.booleanMembers),
                    this.expect(8),
                    this.finishNode(s, 'EnumBooleanBody')
                  )
                } else if (!c && !h && f >= p) {
                  for (let m of o.defaultedMembers)
                    this.flowEnumErrorNumberMemberNotInitialized(m.loc.start, {
                      enumName: r,
                      memberName: m.id.name,
                    })
                  return (
                    (s.members = o.numberMembers),
                    this.expect(8),
                    this.finishNode(s, 'EnumNumberBody')
                  )
                } else
                  return (
                    this.raise(be.EnumInconsistentMemberValues, n, {
                      enumName: r,
                    }),
                    l()
                  )
              }
            }
          }
          flowParseEnumDeclaration(s) {
            let i = this.parseIdentifier()
            return (
              (s.id = i),
              (s.body = this.flowEnumBody(this.startNode(), i)),
              this.finishNode(s, 'EnumDeclaration')
            )
          }
          isLookaheadToken_lt() {
            let s = this.nextTokenStart()
            if (this.input.charCodeAt(s) === 60) {
              let i = this.input.charCodeAt(s + 1)
              return i !== 60 && i !== 61
            }
            return !1
          }
          maybeUnwrapTypeCastExpression(s) {
            return s.type === 'TypeCastExpression' ? s.expression : s
          }
        },
      wv = {
        __proto__: null,
        quot: '"',
        amp: '&',
        apos: "'",
        lt: '<',
        gt: '>',
        nbsp: '\xA0',
        iexcl: '\xA1',
        cent: '\xA2',
        pound: '\xA3',
        curren: '\xA4',
        yen: '\xA5',
        brvbar: '\xA6',
        sect: '\xA7',
        uml: '\xA8',
        copy: '\xA9',
        ordf: '\xAA',
        laquo: '\xAB',
        not: '\xAC',
        shy: '\xAD',
        reg: '\xAE',
        macr: '\xAF',
        deg: '\xB0',
        plusmn: '\xB1',
        sup2: '\xB2',
        sup3: '\xB3',
        acute: '\xB4',
        micro: '\xB5',
        para: '\xB6',
        middot: '\xB7',
        cedil: '\xB8',
        sup1: '\xB9',
        ordm: '\xBA',
        raquo: '\xBB',
        frac14: '\xBC',
        frac12: '\xBD',
        frac34: '\xBE',
        iquest: '\xBF',
        Agrave: '\xC0',
        Aacute: '\xC1',
        Acirc: '\xC2',
        Atilde: '\xC3',
        Auml: '\xC4',
        Aring: '\xC5',
        AElig: '\xC6',
        Ccedil: '\xC7',
        Egrave: '\xC8',
        Eacute: '\xC9',
        Ecirc: '\xCA',
        Euml: '\xCB',
        Igrave: '\xCC',
        Iacute: '\xCD',
        Icirc: '\xCE',
        Iuml: '\xCF',
        ETH: '\xD0',
        Ntilde: '\xD1',
        Ograve: '\xD2',
        Oacute: '\xD3',
        Ocirc: '\xD4',
        Otilde: '\xD5',
        Ouml: '\xD6',
        times: '\xD7',
        Oslash: '\xD8',
        Ugrave: '\xD9',
        Uacute: '\xDA',
        Ucirc: '\xDB',
        Uuml: '\xDC',
        Yacute: '\xDD',
        THORN: '\xDE',
        szlig: '\xDF',
        agrave: '\xE0',
        aacute: '\xE1',
        acirc: '\xE2',
        atilde: '\xE3',
        auml: '\xE4',
        aring: '\xE5',
        aelig: '\xE6',
        ccedil: '\xE7',
        egrave: '\xE8',
        eacute: '\xE9',
        ecirc: '\xEA',
        euml: '\xEB',
        igrave: '\xEC',
        iacute: '\xED',
        icirc: '\xEE',
        iuml: '\xEF',
        eth: '\xF0',
        ntilde: '\xF1',
        ograve: '\xF2',
        oacute: '\xF3',
        ocirc: '\xF4',
        otilde: '\xF5',
        ouml: '\xF6',
        divide: '\xF7',
        oslash: '\xF8',
        ugrave: '\xF9',
        uacute: '\xFA',
        ucirc: '\xFB',
        uuml: '\xFC',
        yacute: '\xFD',
        thorn: '\xFE',
        yuml: '\xFF',
        OElig: '\u0152',
        oelig: '\u0153',
        Scaron: '\u0160',
        scaron: '\u0161',
        Yuml: '\u0178',
        fnof: '\u0192',
        circ: '\u02C6',
        tilde: '\u02DC',
        Alpha: '\u0391',
        Beta: '\u0392',
        Gamma: '\u0393',
        Delta: '\u0394',
        Epsilon: '\u0395',
        Zeta: '\u0396',
        Eta: '\u0397',
        Theta: '\u0398',
        Iota: '\u0399',
        Kappa: '\u039A',
        Lambda: '\u039B',
        Mu: '\u039C',
        Nu: '\u039D',
        Xi: '\u039E',
        Omicron: '\u039F',
        Pi: '\u03A0',
        Rho: '\u03A1',
        Sigma: '\u03A3',
        Tau: '\u03A4',
        Upsilon: '\u03A5',
        Phi: '\u03A6',
        Chi: '\u03A7',
        Psi: '\u03A8',
        Omega: '\u03A9',
        alpha: '\u03B1',
        beta: '\u03B2',
        gamma: '\u03B3',
        delta: '\u03B4',
        epsilon: '\u03B5',
        zeta: '\u03B6',
        eta: '\u03B7',
        theta: '\u03B8',
        iota: '\u03B9',
        kappa: '\u03BA',
        lambda: '\u03BB',
        mu: '\u03BC',
        nu: '\u03BD',
        xi: '\u03BE',
        omicron: '\u03BF',
        pi: '\u03C0',
        rho: '\u03C1',
        sigmaf: '\u03C2',
        sigma: '\u03C3',
        tau: '\u03C4',
        upsilon: '\u03C5',
        phi: '\u03C6',
        chi: '\u03C7',
        psi: '\u03C8',
        omega: '\u03C9',
        thetasym: '\u03D1',
        upsih: '\u03D2',
        piv: '\u03D6',
        ensp: '\u2002',
        emsp: '\u2003',
        thinsp: '\u2009',
        zwnj: '\u200C',
        zwj: '\u200D',
        lrm: '\u200E',
        rlm: '\u200F',
        ndash: '\u2013',
        mdash: '\u2014',
        lsquo: '\u2018',
        rsquo: '\u2019',
        sbquo: '\u201A',
        ldquo: '\u201C',
        rdquo: '\u201D',
        bdquo: '\u201E',
        dagger: '\u2020',
        Dagger: '\u2021',
        bull: '\u2022',
        hellip: '\u2026',
        permil: '\u2030',
        prime: '\u2032',
        Prime: '\u2033',
        lsaquo: '\u2039',
        rsaquo: '\u203A',
        oline: '\u203E',
        frasl: '\u2044',
        euro: '\u20AC',
        image: '\u2111',
        weierp: '\u2118',
        real: '\u211C',
        trade: '\u2122',
        alefsym: '\u2135',
        larr: '\u2190',
        uarr: '\u2191',
        rarr: '\u2192',
        darr: '\u2193',
        harr: '\u2194',
        crarr: '\u21B5',
        lArr: '\u21D0',
        uArr: '\u21D1',
        rArr: '\u21D2',
        dArr: '\u21D3',
        hArr: '\u21D4',
        forall: '\u2200',
        part: '\u2202',
        exist: '\u2203',
        empty: '\u2205',
        nabla: '\u2207',
        isin: '\u2208',
        notin: '\u2209',
        ni: '\u220B',
        prod: '\u220F',
        sum: '\u2211',
        minus: '\u2212',
        lowast: '\u2217',
        radic: '\u221A',
        prop: '\u221D',
        infin: '\u221E',
        ang: '\u2220',
        and: '\u2227',
        or: '\u2228',
        cap: '\u2229',
        cup: '\u222A',
        int: '\u222B',
        there4: '\u2234',
        sim: '\u223C',
        cong: '\u2245',
        asymp: '\u2248',
        ne: '\u2260',
        equiv: '\u2261',
        le: '\u2264',
        ge: '\u2265',
        sub: '\u2282',
        sup: '\u2283',
        nsub: '\u2284',
        sube: '\u2286',
        supe: '\u2287',
        oplus: '\u2295',
        otimes: '\u2297',
        perp: '\u22A5',
        sdot: '\u22C5',
        lceil: '\u2308',
        rceil: '\u2309',
        lfloor: '\u230A',
        rfloor: '\u230B',
        lang: '\u2329',
        rang: '\u232A',
        loz: '\u25CA',
        spades: '\u2660',
        clubs: '\u2663',
        hearts: '\u2665',
        diams: '\u2666',
      },
      $r = pi`jsx`({
        AttributeIsEmpty:
          'JSX attributes must only be assigned a non-empty expression.',
        MissingClosingTagElement: ({ openingTagName: t }) =>
          `Expected corresponding JSX closing tag for <${t}>.`,
        MissingClosingTagFragment:
          'Expected corresponding JSX closing tag for <>.',
        UnexpectedSequenceExpression:
          'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?',
        UnexpectedToken: ({ unexpected: t, HTMLEntity: e }) =>
          `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`,
        UnsupportedJsxValue:
          'JSX value should be either an expression or a quoted JSX text.',
        UnterminatedJsxContent: 'Unterminated JSX contents.',
        UnwrappedAdjacentJSXElements:
          'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?',
      })
    function er(t) {
      return t
        ? t.type === 'JSXOpeningFragment' || t.type === 'JSXClosingFragment'
        : !1
    }
    function Bn(t) {
      if (t.type === 'JSXIdentifier') return t.name
      if (t.type === 'JSXNamespacedName')
        return t.namespace.name + ':' + t.name.name
      if (t.type === 'JSXMemberExpression')
        return Bn(t.object) + '.' + Bn(t.property)
      throw new Error('Node had unexpected type: ' + t.type)
    }
    var Mv = (t) =>
        class extends t {
          jsxReadToken() {
            let s = '',
              i = this.state.pos
            for (;;) {
              if (this.state.pos >= this.length)
                throw this.raise($r.UnterminatedJsxContent, this.state.startLoc)
              let r = this.input.charCodeAt(this.state.pos)
              switch (r) {
                case 60:
                case 123:
                  if (this.state.pos === this.state.start) {
                    r === 60 && this.state.canStartJSXElement
                      ? (++this.state.pos, this.finishToken(142))
                      : super.getTokenFromCode(r)
                    return
                  }
                  ;(s += this.input.slice(i, this.state.pos)),
                    this.finishToken(141, s)
                  return
                case 38:
                  ;(s += this.input.slice(i, this.state.pos)),
                    (s += this.jsxReadEntity()),
                    (i = this.state.pos)
                  break
                case 62:
                case 125:
                default:
                  Va(r)
                    ? ((s += this.input.slice(i, this.state.pos)),
                      (s += this.jsxReadNewLine(!0)),
                      (i = this.state.pos))
                    : ++this.state.pos
              }
            }
          }
          jsxReadNewLine(s) {
            let i = this.input.charCodeAt(this.state.pos),
              r
            return (
              ++this.state.pos,
              i === 13 && this.input.charCodeAt(this.state.pos) === 10
                ? (++this.state.pos,
                  (r = s
                    ? `
`
                    : `\r
`))
                : (r = String.fromCharCode(i)),
              ++this.state.curLine,
              (this.state.lineStart = this.state.pos),
              r
            )
          }
          jsxReadString(s) {
            let i = '',
              r = ++this.state.pos
            for (;;) {
              if (this.state.pos >= this.length)
                throw this.raise(R.UnterminatedString, this.state.startLoc)
              let n = this.input.charCodeAt(this.state.pos)
              if (n === s) break
              n === 38
                ? ((i += this.input.slice(r, this.state.pos)),
                  (i += this.jsxReadEntity()),
                  (r = this.state.pos))
                : Va(n)
                ? ((i += this.input.slice(r, this.state.pos)),
                  (i += this.jsxReadNewLine(!1)),
                  (r = this.state.pos))
                : ++this.state.pos
            }
            ;(i += this.input.slice(r, this.state.pos++)),
              this.finishToken(133, i)
          }
          jsxReadEntity() {
            let s = ++this.state.pos
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos
              let i = 10
              this.codePointAtPos(this.state.pos) === 120 &&
                ((i = 16), ++this.state.pos)
              let r = this.readInt(i, void 0, !1, 'bail')
              if (r !== null && this.codePointAtPos(this.state.pos) === 59)
                return ++this.state.pos, String.fromCodePoint(r)
            } else {
              let i = 0,
                r = !1
              for (
                ;
                i++ < 10 &&
                this.state.pos < this.length &&
                !(r = this.codePointAtPos(this.state.pos) === 59);

              )
                ++this.state.pos
              if (r) {
                let n = this.input.slice(s, this.state.pos),
                  a = wv[n]
                if ((++this.state.pos, a)) return a
              }
            }
            return (this.state.pos = s), '&'
          }
          jsxReadWord() {
            let s,
              i = this.state.pos
            do s = this.input.charCodeAt(++this.state.pos)
            while (Fn(s) || s === 45)
            this.finishToken(140, this.input.slice(i, this.state.pos))
          }
          jsxParseIdentifier() {
            let s = this.startNode()
            return (
              this.match(140)
                ? (s.name = this.state.value)
                : Ah(this.state.type)
                ? (s.name = Zi(this.state.type))
                : this.unexpected(),
              this.next(),
              this.finishNode(s, 'JSXIdentifier')
            )
          }
          jsxParseNamespacedName() {
            let s = this.state.startLoc,
              i = this.jsxParseIdentifier()
            if (!this.eat(14)) return i
            let r = this.startNodeAt(s)
            return (
              (r.namespace = i),
              (r.name = this.jsxParseIdentifier()),
              this.finishNode(r, 'JSXNamespacedName')
            )
          }
          jsxParseElementName() {
            let s = this.state.startLoc,
              i = this.jsxParseNamespacedName()
            if (i.type === 'JSXNamespacedName') return i
            for (; this.eat(16); ) {
              let r = this.startNodeAt(s)
              ;(r.object = i),
                (r.property = this.jsxParseIdentifier()),
                (i = this.finishNode(r, 'JSXMemberExpression'))
            }
            return i
          }
          jsxParseAttributeValue() {
            let s
            switch (this.state.type) {
              case 5:
                return (
                  (s = this.startNode()),
                  this.setContext(Ke.brace),
                  this.next(),
                  (s = this.jsxParseExpressionContainer(s, Ke.j_oTag)),
                  s.expression.type === 'JSXEmptyExpression' &&
                    this.raise($r.AttributeIsEmpty, s),
                  s
                )
              case 142:
              case 133:
                return this.parseExprAtom()
              default:
                throw this.raise($r.UnsupportedJsxValue, this.state.startLoc)
            }
          }
          jsxParseEmptyExpression() {
            let s = this.startNodeAt(this.state.lastTokEndLoc)
            return this.finishNodeAt(
              s,
              'JSXEmptyExpression',
              this.state.startLoc
            )
          }
          jsxParseSpreadChild(s) {
            return (
              this.next(),
              (s.expression = this.parseExpression()),
              this.setContext(Ke.j_expr),
              (this.state.canStartJSXElement = !0),
              this.expect(8),
              this.finishNode(s, 'JSXSpreadChild')
            )
          }
          jsxParseExpressionContainer(s, i) {
            if (this.match(8)) s.expression = this.jsxParseEmptyExpression()
            else {
              let r = this.parseExpression()
              s.expression = r
            }
            return (
              this.setContext(i),
              (this.state.canStartJSXElement = !0),
              this.expect(8),
              this.finishNode(s, 'JSXExpressionContainer')
            )
          }
          jsxParseAttribute() {
            let s = this.startNode()
            return this.match(5)
              ? (this.setContext(Ke.brace),
                this.next(),
                this.expect(21),
                (s.argument = this.parseMaybeAssignAllowIn()),
                this.setContext(Ke.j_oTag),
                (this.state.canStartJSXElement = !0),
                this.expect(8),
                this.finishNode(s, 'JSXSpreadAttribute'))
              : ((s.name = this.jsxParseNamespacedName()),
                (s.value = this.eat(29) ? this.jsxParseAttributeValue() : null),
                this.finishNode(s, 'JSXAttribute'))
          }
          jsxParseOpeningElementAt(s) {
            let i = this.startNodeAt(s)
            return this.eat(143)
              ? this.finishNode(i, 'JSXOpeningFragment')
              : ((i.name = this.jsxParseElementName()),
                this.jsxParseOpeningElementAfterName(i))
          }
          jsxParseOpeningElementAfterName(s) {
            let i = []
            for (; !this.match(56) && !this.match(143); )
              i.push(this.jsxParseAttribute())
            return (
              (s.attributes = i),
              (s.selfClosing = this.eat(56)),
              this.expect(143),
              this.finishNode(s, 'JSXOpeningElement')
            )
          }
          jsxParseClosingElementAt(s) {
            let i = this.startNodeAt(s)
            return this.eat(143)
              ? this.finishNode(i, 'JSXClosingFragment')
              : ((i.name = this.jsxParseElementName()),
                this.expect(143),
                this.finishNode(i, 'JSXClosingElement'))
          }
          jsxParseElementAt(s) {
            let i = this.startNodeAt(s),
              r = [],
              n = this.jsxParseOpeningElementAt(s),
              a = null
            if (!n.selfClosing) {
              e: for (;;)
                switch (this.state.type) {
                  case 142:
                    if (
                      ((s = this.state.startLoc), this.next(), this.eat(56))
                    ) {
                      a = this.jsxParseClosingElementAt(s)
                      break e
                    }
                    r.push(this.jsxParseElementAt(s))
                    break
                  case 141:
                    r.push(this.parseLiteral(this.state.value, 'JSXText'))
                    break
                  case 5: {
                    let o = this.startNode()
                    this.setContext(Ke.brace),
                      this.next(),
                      this.match(21)
                        ? r.push(this.jsxParseSpreadChild(o))
                        : r.push(this.jsxParseExpressionContainer(o, Ke.j_expr))
                    break
                  }
                  default:
                    this.unexpected()
                }
              er(n) && !er(a) && a !== null
                ? this.raise($r.MissingClosingTagFragment, a)
                : !er(n) && er(a)
                ? this.raise($r.MissingClosingTagElement, a, {
                    openingTagName: Bn(n.name),
                  })
                : !er(n) &&
                  !er(a) &&
                  Bn(a.name) !== Bn(n.name) &&
                  this.raise($r.MissingClosingTagElement, a, {
                    openingTagName: Bn(n.name),
                  })
            }
            if (
              (er(n)
                ? ((i.openingFragment = n), (i.closingFragment = a))
                : ((i.openingElement = n), (i.closingElement = a)),
              (i.children = r),
              this.match(47))
            )
              throw this.raise(
                $r.UnwrappedAdjacentJSXElements,
                this.state.startLoc
              )
            return er(n)
              ? this.finishNode(i, 'JSXFragment')
              : this.finishNode(i, 'JSXElement')
          }
          jsxParseElement() {
            let s = this.state.startLoc
            return this.next(), this.jsxParseElementAt(s)
          }
          setContext(s) {
            let { context: i } = this.state
            i[i.length - 1] = s
          }
          parseExprAtom(s) {
            return this.match(142)
              ? this.jsxParseElement()
              : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33
              ? (this.replaceToken(142), this.jsxParseElement())
              : super.parseExprAtom(s)
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace()
          }
          getTokenFromCode(s) {
            let i = this.curContext()
            if (i === Ke.j_expr) {
              this.jsxReadToken()
              return
            }
            if (i === Ke.j_oTag || i === Ke.j_cTag) {
              if (gi(s)) {
                this.jsxReadWord()
                return
              }
              if (s === 62) {
                ++this.state.pos, this.finishToken(143)
                return
              }
              if ((s === 34 || s === 39) && i === Ke.j_oTag) {
                this.jsxReadString(s)
                return
              }
            }
            if (
              s === 60 &&
              this.state.canStartJSXElement &&
              this.input.charCodeAt(this.state.pos + 1) !== 33
            ) {
              ++this.state.pos, this.finishToken(142)
              return
            }
            super.getTokenFromCode(s)
          }
          updateContext(s) {
            let { context: i, type: r } = this.state
            if (r === 56 && s === 142)
              i.splice(-2, 2, Ke.j_cTag), (this.state.canStartJSXElement = !1)
            else if (r === 142) i.push(Ke.j_oTag)
            else if (r === 143) {
              let n = i[i.length - 1]
              ;(n === Ke.j_oTag && s === 56) || n === Ke.j_cTag
                ? (i.pop(),
                  (this.state.canStartJSXElement =
                    i[i.length - 1] === Ke.j_expr))
                : (this.setContext(Ke.j_expr),
                  (this.state.canStartJSXElement = !0))
            } else this.state.canStartJSXElement = zC(r)
          }
        },
      T1 = class extends Du {
        constructor(...e) {
          super(...e)
          this.tsNames = new Map()
        }
      },
      _1 = class extends Fu {
        constructor(...e) {
          super(...e)
          this.importsStack = []
        }
        createScope(e) {
          return this.importsStack.push(new Set()), new T1(e)
        }
        enter(e) {
          e === 256 && this.importsStack.push(new Set()), super.enter(e)
        }
        exit() {
          let e = super.exit()
          return e === 256 && this.importsStack.pop(), e
        }
        hasImport(e, s) {
          let i = this.importsStack.length
          if (this.importsStack[i - 1].has(e)) return !0
          if (!s && i > 1) {
            for (let r = 0; r < i - 1; r++)
              if (this.importsStack[r].has(e)) return !0
          }
          return !1
        }
        declareName(e, s, i) {
          if (s & 4096) {
            this.hasImport(e, !0) &&
              this.parser.raise(R.VarRedeclaration, i, { identifierName: e }),
              this.importsStack[this.importsStack.length - 1].add(e)
            return
          }
          let r = this.currentScope(),
            n = r.tsNames.get(e) || 0
          if (s & 1024) {
            this.maybeExportDefined(r, e), r.tsNames.set(e, n | 16)
            return
          }
          super.declareName(e, s, i),
            s & 2 &&
              (s & 1 ||
                (this.checkRedeclarationInScope(r, e, s, i),
                this.maybeExportDefined(r, e)),
              (n = n | 1)),
            s & 256 && (n = n | 2),
            s & 512 && (n = n | 4),
            s & 128 && (n = n | 8),
            n && r.tsNames.set(e, n)
        }
        isRedeclaredInScope(e, s, i) {
          let r = e.tsNames.get(s)
          if ((r & 2) > 0) {
            if (i & 256) {
              let n = !!(i & 512),
                a = (r & 4) > 0
              return n !== a
            }
            return !0
          }
          return i & 128 && (r & 8) > 0
            ? e.names.get(s) & 2
              ? !!(i & 1)
              : !1
            : i & 2 && (r & 1) > 0
            ? !0
            : super.isRedeclaredInScope(e, s, i)
        }
        checkLocalExport(e) {
          let { name: s } = e
          if (this.hasImport(s)) return
          let i = this.scopeStack.length
          for (let r = i - 1; r >= 0; r--) {
            let a = this.scopeStack[r].tsNames.get(s)
            if ((a & 1) > 0 || (a & 16) > 0) return
          }
          super.checkLocalExport(e)
        }
      },
      Rv = (t, e) => hasOwnProperty.call(t, e) && t[e],
      x1 = (t) => (t.type === 'ParenthesizedExpression' ? x1(t.expression) : t),
      A1 = class extends E1 {
        toAssignable(e, s = !1) {
          var i, r
          let n
          switch (
            ((e.type === 'ParenthesizedExpression' ||
              ((i = e.extra) != null && i.parenthesized)) &&
              ((n = x1(e)),
              s
                ? n.type === 'Identifier'
                  ? this.expressionScope.recordArrowParameterBindingError(
                      R.InvalidParenthesizedAssignment,
                      e
                    )
                  : n.type !== 'MemberExpression' &&
                    !this.isOptionalMemberExpression(n) &&
                    this.raise(R.InvalidParenthesizedAssignment, e)
                : this.raise(R.InvalidParenthesizedAssignment, e)),
            e.type)
          ) {
            case 'Identifier':
            case 'ObjectPattern':
            case 'ArrayPattern':
            case 'AssignmentPattern':
            case 'RestElement':
              break
            case 'ObjectExpression':
              e.type = 'ObjectPattern'
              for (let o = 0, u = e.properties.length, l = u - 1; o < u; o++) {
                var a
                let c = e.properties[o],
                  f = o === l
                this.toAssignableObjectExpressionProp(c, f, s),
                  f &&
                    c.type === 'RestElement' &&
                    (a = e.extra) != null &&
                    a.trailingCommaLoc &&
                    this.raise(R.RestTrailingComma, e.extra.trailingCommaLoc)
              }
              break
            case 'ObjectProperty': {
              let { key: o, value: u } = e
              this.isPrivateName(o) &&
                this.classScope.usePrivateName(
                  this.getPrivateNameSV(o),
                  o.loc.start
                ),
                this.toAssignable(u, s)
              break
            }
            case 'SpreadElement':
              throw new Error(
                "Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller."
              )
            case 'ArrayExpression':
              ;(e.type = 'ArrayPattern'),
                this.toAssignableList(
                  e.elements,
                  (r = e.extra) == null ? void 0 : r.trailingCommaLoc,
                  s
                )
              break
            case 'AssignmentExpression':
              e.operator !== '=' &&
                this.raise(R.MissingEqInAssignment, e.left.loc.end),
                (e.type = 'AssignmentPattern'),
                delete e.operator,
                this.toAssignable(e.left, s)
              break
            case 'ParenthesizedExpression':
              this.toAssignable(n, s)
              break
          }
        }
        toAssignableObjectExpressionProp(e, s, i) {
          if (e.type === 'ObjectMethod')
            this.raise(
              e.kind === 'get' || e.kind === 'set'
                ? R.PatternHasAccessor
                : R.PatternHasMethod,
              e.key
            )
          else if (e.type === 'SpreadElement') {
            e.type = 'RestElement'
            let r = e.argument
            this.checkToRestConversion(r, !1),
              this.toAssignable(r, i),
              s || this.raise(R.RestTrailingComma, e)
          } else this.toAssignable(e, i)
        }
        toAssignableList(e, s, i) {
          let r = e.length - 1
          for (let n = 0; n <= r; n++) {
            let a = e[n]
            if (!!a) {
              if (a.type === 'SpreadElement') {
                a.type = 'RestElement'
                let o = a.argument
                this.checkToRestConversion(o, !0), this.toAssignable(o, i)
              } else this.toAssignable(a, i)
              a.type === 'RestElement' &&
                (n < r
                  ? this.raise(R.RestTrailingComma, a)
                  : s && this.raise(R.RestTrailingComma, s))
            }
          }
        }
        isAssignable(e, s) {
          switch (e.type) {
            case 'Identifier':
            case 'ObjectPattern':
            case 'ArrayPattern':
            case 'AssignmentPattern':
            case 'RestElement':
              return !0
            case 'ObjectExpression': {
              let i = e.properties.length - 1
              return e.properties.every(
                (r, n) =>
                  r.type !== 'ObjectMethod' &&
                  (n === i || r.type !== 'SpreadElement') &&
                  this.isAssignable(r)
              )
            }
            case 'ObjectProperty':
              return this.isAssignable(e.value)
            case 'SpreadElement':
              return this.isAssignable(e.argument)
            case 'ArrayExpression':
              return e.elements.every((i) => i === null || this.isAssignable(i))
            case 'AssignmentExpression':
              return e.operator === '='
            case 'ParenthesizedExpression':
              return this.isAssignable(e.expression)
            case 'MemberExpression':
            case 'OptionalMemberExpression':
              return !s
            default:
              return !1
          }
        }
        toReferencedList(e, s) {
          return e
        }
        toReferencedListDeep(e, s) {
          this.toReferencedList(e, s)
          for (let i of e)
            (i == null ? void 0 : i.type) === 'ArrayExpression' &&
              this.toReferencedListDeep(i.elements)
        }
        parseSpread(e) {
          let s = this.startNode()
          return (
            this.next(),
            (s.argument = this.parseMaybeAssignAllowIn(e, void 0)),
            this.finishNode(s, 'SpreadElement')
          )
        }
        parseRestBinding() {
          let e = this.startNode()
          return (
            this.next(),
            (e.argument = this.parseBindingAtom()),
            this.finishNode(e, 'RestElement')
          )
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 0: {
              let e = this.startNode()
              return (
                this.next(),
                (e.elements = this.parseBindingList(3, 93, 1)),
                this.finishNode(e, 'ArrayPattern')
              )
            }
            case 5:
              return this.parseObjectLike(8, !0)
          }
          return this.parseIdentifier()
        }
        parseBindingList(e, s, i) {
          let r = i & 1,
            n = [],
            a = !0
          for (; !this.eat(e); )
            if ((a ? (a = !1) : this.expect(12), r && this.match(12)))
              n.push(null)
            else {
              if (this.eat(e)) break
              if (this.match(21)) {
                if (
                  (n.push(
                    this.parseAssignableListItemTypes(
                      this.parseRestBinding(),
                      i
                    )
                  ),
                  !this.checkCommaAfterRest(s))
                ) {
                  this.expect(e)
                  break
                }
              } else {
                let o = []
                for (
                  this.match(26) &&
                  this.hasPlugin('decorators') &&
                  this.raise(
                    R.UnsupportedParameterDecorator,
                    this.state.startLoc
                  );
                  this.match(26);

                )
                  o.push(this.parseDecorator())
                n.push(this.parseAssignableListItem(i, o))
              }
            }
          return n
        }
        parseBindingRestProperty(e) {
          return (
            this.next(),
            (e.argument = this.parseIdentifier()),
            this.checkCommaAfterRest(125),
            this.finishNode(e, 'RestElement')
          )
        }
        parseBindingProperty() {
          let { type: e, startLoc: s } = this.state
          if (e === 21) return this.parseBindingRestProperty(this.startNode())
          let i = this.startNode()
          return (
            e === 138
              ? (this.expectPlugin('destructuringPrivate', s),
                this.classScope.usePrivateName(this.state.value, s),
                (i.key = this.parsePrivateName()))
              : this.parsePropertyName(i),
            (i.method = !1),
            this.parseObjPropValue(i, s, !1, !1, !0, !1)
          )
        }
        parseAssignableListItem(e, s) {
          let i = this.parseMaybeDefault()
          this.parseAssignableListItemTypes(i, e)
          let r = this.parseMaybeDefault(i.loc.start, i)
          return s.length && (i.decorators = s), r
        }
        parseAssignableListItemTypes(e, s) {
          return e
        }
        parseMaybeDefault(e, s) {
          var i, r
          if (
            ((i = e) != null || (e = this.state.startLoc),
            (s = (r = s) != null ? r : this.parseBindingAtom()),
            !this.eat(29))
          )
            return s
          let n = this.startNodeAt(e)
          return (
            (n.left = s),
            (n.right = this.parseMaybeAssignAllowIn()),
            this.finishNode(n, 'AssignmentPattern')
          )
        }
        isValidLVal(e, s, i) {
          return Rv(
            {
              AssignmentPattern: 'left',
              RestElement: 'argument',
              ObjectProperty: 'value',
              ParenthesizedExpression: 'expression',
              ArrayPattern: 'elements',
              ObjectPattern: 'properties',
            },
            e
          )
        }
        isOptionalMemberExpression(e) {
          return e.type === 'OptionalMemberExpression'
        }
        checkLVal(
          e,
          {
            in: s,
            binding: i = 64,
            checkClashes: r = !1,
            strictModeChanged: n = !1,
            hasParenthesizedAncestor: a = !1,
          }
        ) {
          var o
          let u = e.type
          if (this.isObjectMethod(e)) return
          let l = this.isOptionalMemberExpression(e)
          if (l || u === 'MemberExpression') {
            l &&
              (this.expectPlugin('optionalChainingAssign', e.loc.start),
              s.type !== 'AssignmentExpression' &&
                this.raise(R.InvalidLhsOptionalChaining, e, { ancestor: s })),
              i !== 64 && this.raise(R.InvalidPropertyBindingPattern, e)
            return
          }
          if (u === 'Identifier') {
            this.checkIdentifier(e, i, n)
            let { name: m } = e
            r && (r.has(m) ? this.raise(R.ParamDupe, e) : r.add(m))
            return
          }
          let c = this.isValidLVal(
            u,
            !(a || ((o = e.extra) != null && o.parenthesized)) &&
              s.type === 'AssignmentExpression',
            i
          )
          if (c === !0) return
          if (c === !1) {
            let m = i === 64 ? R.InvalidLhs : R.InvalidLhsBinding
            this.raise(m, e, { ancestor: s })
            return
          }
          let [f, h] = Array.isArray(c)
              ? c
              : [c, u === 'ParenthesizedExpression'],
            p = u === 'ArrayPattern' || u === 'ObjectPattern' ? { type: u } : s
          for (let m of [].concat(e[f]))
            m &&
              this.checkLVal(m, {
                in: p,
                binding: i,
                checkClashes: r,
                strictModeChanged: n,
                hasParenthesizedAncestor: h,
              })
        }
        checkIdentifier(e, s, i = !1) {
          this.state.strict &&
            (i ? e1(e.name, this.inModule) : Zg(e.name)) &&
            (s === 64
              ? this.raise(R.StrictEvalArguments, e, { referenceName: e.name })
              : this.raise(R.StrictEvalArgumentsBinding, e, {
                  bindingName: e.name,
                })),
            s & 8192 &&
              e.name === 'let' &&
              this.raise(R.LetInLexicalBinding, e),
            s & 64 || this.declareNameFromIdentifier(e, s)
        }
        declareNameFromIdentifier(e, s) {
          this.scope.declareName(e.name, s, e.loc.start)
        }
        checkToRestConversion(e, s) {
          switch (e.type) {
            case 'ParenthesizedExpression':
              this.checkToRestConversion(e.expression, s)
              break
            case 'Identifier':
            case 'MemberExpression':
              break
            case 'ArrayExpression':
            case 'ObjectExpression':
              if (s) break
            default:
              this.raise(R.InvalidRestAssignmentPattern, e)
          }
        }
        checkCommaAfterRest(e) {
          return this.match(12)
            ? (this.raise(
                this.lookaheadCharCode() === e
                  ? R.RestTrailingComma
                  : R.ElementAfterRest,
                this.state.startLoc
              ),
              !0)
            : !1
        }
      },
      Lv = (t, e) => hasOwnProperty.call(t, e) && t[e]
    function kv(t) {
      if (t == null) throw new Error(`Unexpected ${t} value.`)
      return t
    }
    function P1(t) {
      if (!t) throw new Error('Assert fail')
    }
    var pe = pi`typescript`({
      AbstractMethodHasImplementation: ({ methodName: t }) =>
        `Method '${t}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({ propertyName: t }) =>
        `Property '${t}' cannot have an initializer because it is marked abstract.`,
      AccesorCannotDeclareThisParameter:
        "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccesorCannotHaveTypeParameters:
        'An accessor cannot have type parameters.',
      AccessorCannotBeOptional:
        "An 'accessor' property cannot be declared optional.",
      ClassMethodHasDeclare:
        "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly:
        "Class methods cannot have the 'readonly' modifier.",
      ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference:
        "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters:
        'Type parameters cannot appear on a constructor declaration.',
      DeclareAccessor: ({ kind: t }) => `'declare' is not allowed in ${t}ters.`,
      DeclareClassFieldHasInitializer:
        'Initializers are not allowed in ambient contexts.',
      DeclareFunctionHasImplementation:
        'An implementation cannot be declared in ambient contexts.',
      DuplicateAccessibilityModifier: ({ modifier: t }) =>
        'Accessibility modifier already seen.',
      DuplicateModifier: ({ modifier: t }) => `Duplicate modifier: '${t}'.`,
      EmptyHeritageClauseType: ({ token: t }) => `'${t}' list cannot be empty.`,
      EmptyTypeArguments: 'Type argument list cannot be empty.',
      EmptyTypeParameters: 'Type parameter list cannot be empty.',
      ExpectedAmbientAfterExportDeclare:
        "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType:
        'An `import module` declaration can not use `type` modifier',
      IncompatibleModifiers: ({ modifiers: t }) =>
        `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`,
      IndexSignatureHasAbstract:
        "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({ modifier: t }) =>
        `Index signatures cannot have an accessibility modifier ('${t}').`,
      IndexSignatureHasDeclare:
        "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride:
        "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic:
        "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext:
        'Initializers are not allowed in ambient contexts.',
      InvalidModifierOnTypeMember: ({ modifier: t }) =>
        `'${t}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({ modifier: t }) =>
        `'${t}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({ modifier: t }) =>
        `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifiersOrder: ({ orderedModifiers: t }) =>
        `'${t[0]}' modifier must precede '${t[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression:
        'Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.',
      InvalidTupleMemberLabel:
        'Tuple members must be labeled with a simple identifier.',
      MissingInterfaceName:
        "'interface' declarations must be followed by an identifier.",
      NonAbstractClassHasAbstractMethod:
        'Abstract methods can only appear within an abstract class.',
      NonClassMethodPropertyHasAbstractModifer:
        "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired:
        'A required element cannot follow an optional element.',
      OverrideNotInSubClass:
        "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional:
        'A binding pattern parameter cannot be optional in an implementation signature.',
      PrivateElementHasAbstract:
        "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({ modifier: t }) =>
        `Private elements cannot have an accessibility modifier ('${t}').`,
      ReadonlyForMethodSignature:
        "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam:
        'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.',
      ReservedTypeAssertion:
        'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.',
      SetAccesorCannotHaveOptionalParameter:
        "A 'set' accessor cannot have an optional parameter.",
      SetAccesorCannotHaveRestParameter:
        "A 'set' accessor cannot have rest parameter.",
      SetAccesorCannotHaveReturnType:
        "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: t }) =>
        `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`,
      StaticBlockCannotHaveModifier:
        'Static class blocks cannot have any modifier.',
      TupleOptionalAfterType:
        'A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).',
      TypeAnnotationAfterAssign:
        'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
      TypeImportCannotSpecifyDefaultAndNamed:
        'A type-only import can specify a default import or named bindings, but not both.',
      TypeModifierIsUsedInTypeExports:
        "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports:
        "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier:
        'A parameter property is only allowed in a constructor implementation.',
      UnexpectedReadonly:
        "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: 'Did not expect a type annotation here.',
      UnexpectedTypeCastInParameter:
        'Unexpected type cast in parameter position.',
      UnsupportedImportTypeArgument:
        'Argument in a type import must be a string literal.',
      UnsupportedParameterPropertyKind:
        'A parameter property may not be declared using a binding pattern.',
      UnsupportedSignatureParameterKind: ({ type: t }) =>
        `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`,
    })
    function Dv(t) {
      switch (t) {
        case 'any':
          return 'TSAnyKeyword'
        case 'boolean':
          return 'TSBooleanKeyword'
        case 'bigint':
          return 'TSBigIntKeyword'
        case 'never':
          return 'TSNeverKeyword'
        case 'number':
          return 'TSNumberKeyword'
        case 'object':
          return 'TSObjectKeyword'
        case 'string':
          return 'TSStringKeyword'
        case 'symbol':
          return 'TSSymbolKeyword'
        case 'undefined':
          return 'TSUndefinedKeyword'
        case 'unknown':
          return 'TSUnknownKeyword'
        default:
          return
      }
    }
    function C1(t) {
      return t === 'private' || t === 'public' || t === 'protected'
    }
    function Fv(t) {
      return t === 'in' || t === 'out'
    }
    var Bv = (t) =>
      class extends t {
        constructor(...s) {
          super(...s)
          ;(this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
            allowedModifiers: ['in', 'out'],
            disallowedModifiers: [
              'const',
              'public',
              'private',
              'protected',
              'readonly',
              'declare',
              'abstract',
              'override',
            ],
            errorTemplate: pe.InvalidModifierOnTypeParameter,
          })),
            (this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
              allowedModifiers: ['const'],
              disallowedModifiers: ['in', 'out'],
              errorTemplate: pe.InvalidModifierOnTypeParameterPositions,
            })),
            (this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(
              this,
              {
                allowedModifiers: ['in', 'out', 'const'],
                disallowedModifiers: [
                  'public',
                  'private',
                  'protected',
                  'readonly',
                  'declare',
                  'abstract',
                  'override',
                ],
                errorTemplate: pe.InvalidModifierOnTypeParameter,
              }
            ))
        }
        getScopeHandler() {
          return _1
        }
        tsIsIdentifier() {
          return Ve(this.state.type)
        }
        tsTokenCanFollowModifier() {
          return (
            (this.match(0) ||
              this.match(5) ||
              this.match(55) ||
              this.match(21) ||
              this.match(138) ||
              this.isLiteralPropertyName()) &&
            !this.hasPrecedingLineBreak()
          )
        }
        tsNextTokenCanFollowModifier() {
          return this.next(), this.tsTokenCanFollowModifier()
        }
        tsParseModifier(s, i) {
          if (
            !Ve(this.state.type) &&
            this.state.type !== 58 &&
            this.state.type !== 75
          )
            return
          let r = this.state.value
          if (s.includes(r)) {
            if (i && this.tsIsStartOfStaticBlocks()) return
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
              return r
          }
        }
        tsParseModifiers(
          {
            allowedModifiers: s,
            disallowedModifiers: i,
            stopOnStartOfClassStaticBlock: r,
            errorTemplate: n = pe.InvalidModifierOnTypeMember,
          },
          a
        ) {
          let o = (l, c, f, h) => {
              c === f &&
                a[h] &&
                this.raise(pe.InvalidModifiersOrder, l, {
                  orderedModifiers: [f, h],
                })
            },
            u = (l, c, f, h) => {
              ;((a[f] && c === h) || (a[h] && c === f)) &&
                this.raise(pe.IncompatibleModifiers, l, { modifiers: [f, h] })
            }
          for (;;) {
            let { startLoc: l } = this.state,
              c = this.tsParseModifier(s.concat(i != null ? i : []), r)
            if (!c) break
            C1(c)
              ? a.accessibility
                ? this.raise(pe.DuplicateAccessibilityModifier, l, {
                    modifier: c,
                  })
                : (o(l, c, c, 'override'),
                  o(l, c, c, 'static'),
                  o(l, c, c, 'readonly'),
                  (a.accessibility = c))
              : Fv(c)
              ? (a[c] && this.raise(pe.DuplicateModifier, l, { modifier: c }),
                (a[c] = !0),
                o(l, c, 'in', 'out'))
              : (hasOwnProperty.call(a, c)
                  ? this.raise(pe.DuplicateModifier, l, { modifier: c })
                  : (o(l, c, 'static', 'readonly'),
                    o(l, c, 'static', 'override'),
                    o(l, c, 'override', 'readonly'),
                    o(l, c, 'abstract', 'override'),
                    u(l, c, 'declare', 'override'),
                    u(l, c, 'static', 'abstract')),
                (a[c] = !0)),
              i != null && i.includes(c) && this.raise(n, l, { modifier: c })
          }
        }
        tsIsListTerminator(s) {
          switch (s) {
            case 'EnumMembers':
            case 'TypeMembers':
              return this.match(8)
            case 'HeritageClauseElement':
              return this.match(5)
            case 'TupleElementTypes':
              return this.match(3)
            case 'TypeParametersOrArguments':
              return this.match(48)
          }
        }
        tsParseList(s, i) {
          let r = []
          for (; !this.tsIsListTerminator(s); ) r.push(i())
          return r
        }
        tsParseDelimitedList(s, i, r) {
          return kv(this.tsParseDelimitedListWorker(s, i, !0, r))
        }
        tsParseDelimitedListWorker(s, i, r, n) {
          let a = [],
            o = -1
          for (; !this.tsIsListTerminator(s); ) {
            o = -1
            let u = i()
            if (u == null) return
            if ((a.push(u), this.eat(12))) {
              o = this.state.lastTokStartLoc.index
              continue
            }
            if (this.tsIsListTerminator(s)) break
            r && this.expect(12)
            return
          }
          return n && (n.value = o), a
        }
        tsParseBracketedList(s, i, r, n, a) {
          n || (r ? this.expect(0) : this.expect(47))
          let o = this.tsParseDelimitedList(s, i, a)
          return r ? this.expect(3) : this.expect(48), o
        }
        tsParseImportType() {
          let s = this.startNode()
          return (
            this.expect(83),
            this.expect(10),
            this.match(133) ||
              this.raise(pe.UnsupportedImportTypeArgument, this.state.startLoc),
            (s.argument = super.parseExprAtom()),
            (this.hasPlugin('importAttributes') ||
              this.hasPlugin('importAssertions')) &&
              (s.options = null),
            this.eat(12) &&
              (this.expectImportAttributesPlugin(),
              this.match(11) ||
                ((s.options = super.parseMaybeAssignAllowIn()), this.eat(12))),
            this.expect(11),
            this.eat(16) && (s.qualifier = this.tsParseEntityName()),
            this.match(47) && (s.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(s, 'TSImportType')
          )
        }
        tsParseEntityName(s = !0) {
          let i = this.parseIdentifier(s)
          for (; this.eat(16); ) {
            let r = this.startNodeAtNode(i)
            ;(r.left = i),
              (r.right = this.parseIdentifier(s)),
              (i = this.finishNode(r, 'TSQualifiedName'))
          }
          return i
        }
        tsParseTypeReference() {
          let s = this.startNode()
          return (
            (s.typeName = this.tsParseEntityName()),
            !this.hasPrecedingLineBreak() &&
              this.match(47) &&
              (s.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(s, 'TSTypeReference')
          )
        }
        tsParseThisTypePredicate(s) {
          this.next()
          let i = this.startNodeAtNode(s)
          return (
            (i.parameterName = s),
            (i.typeAnnotation = this.tsParseTypeAnnotation(!1)),
            (i.asserts = !1),
            this.finishNode(i, 'TSTypePredicate')
          )
        }
        tsParseThisTypeNode() {
          let s = this.startNode()
          return this.next(), this.finishNode(s, 'TSThisType')
        }
        tsParseTypeQuery() {
          let s = this.startNode()
          return (
            this.expect(87),
            this.match(83)
              ? (s.exprName = this.tsParseImportType())
              : (s.exprName = this.tsParseEntityName()),
            !this.hasPrecedingLineBreak() &&
              this.match(47) &&
              (s.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(s, 'TSTypeQuery')
          )
        }
        tsParseTypeParameter(s) {
          let i = this.startNode()
          return (
            s(i),
            (i.name = this.tsParseTypeParameterName()),
            (i.constraint = this.tsEatThenParseType(81)),
            (i.default = this.tsEatThenParseType(29)),
            this.finishNode(i, 'TSTypeParameter')
          )
        }
        tsTryParseTypeParameters(s) {
          if (this.match(47)) return this.tsParseTypeParameters(s)
        }
        tsParseTypeParameters(s) {
          let i = this.startNode()
          this.match(47) || this.match(142) ? this.next() : this.unexpected()
          let r = { value: -1 }
          return (
            (i.params = this.tsParseBracketedList(
              'TypeParametersOrArguments',
              this.tsParseTypeParameter.bind(this, s),
              !1,
              !0,
              r
            )),
            i.params.length === 0 && this.raise(pe.EmptyTypeParameters, i),
            r.value !== -1 && this.addExtra(i, 'trailingComma', r.value),
            this.finishNode(i, 'TSTypeParameterDeclaration')
          )
        }
        tsFillSignature(s, i) {
          let r = s === 19,
            n = 'parameters',
            a = 'typeAnnotation'
          ;(i.typeParameters = this.tsTryParseTypeParameters(
            this.tsParseConstModifier
          )),
            this.expect(10),
            (i[n] = this.tsParseBindingListForSignature()),
            r
              ? (i[a] = this.tsParseTypeOrTypePredicateAnnotation(s))
              : this.match(s) &&
                (i[a] = this.tsParseTypeOrTypePredicateAnnotation(s))
        }
        tsParseBindingListForSignature() {
          let s = super.parseBindingList(11, 41, 2)
          for (let i of s) {
            let { type: r } = i
            ;(r === 'AssignmentPattern' || r === 'TSParameterProperty') &&
              this.raise(pe.UnsupportedSignatureParameterKind, i, { type: r })
          }
          return s
        }
        tsParseTypeMemberSemicolon() {
          !this.eat(12) && !this.isLineTerminator() && this.expect(13)
        }
        tsParseSignatureMember(s, i) {
          return (
            this.tsFillSignature(14, i),
            this.tsParseTypeMemberSemicolon(),
            this.finishNode(i, s)
          )
        }
        tsIsUnambiguouslyIndexSignature() {
          return (
            this.next(),
            Ve(this.state.type) ? (this.next(), this.match(14)) : !1
          )
        }
        tsTryParseIndexSignature(s) {
          if (
            !(
              this.match(0) &&
              this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))
            )
          )
            return
          this.expect(0)
          let i = this.parseIdentifier()
          ;(i.typeAnnotation = this.tsParseTypeAnnotation()),
            this.resetEndLocation(i),
            this.expect(3),
            (s.parameters = [i])
          let r = this.tsTryParseTypeAnnotation()
          return (
            r && (s.typeAnnotation = r),
            this.tsParseTypeMemberSemicolon(),
            this.finishNode(s, 'TSIndexSignature')
          )
        }
        tsParsePropertyOrMethodSignature(s, i) {
          this.eat(17) && (s.optional = !0)
          let r = s
          if (this.match(10) || this.match(47)) {
            i && this.raise(pe.ReadonlyForMethodSignature, s)
            let n = r
            n.kind &&
              this.match(47) &&
              this.raise(
                pe.AccesorCannotHaveTypeParameters,
                this.state.curPosition()
              ),
              this.tsFillSignature(14, n),
              this.tsParseTypeMemberSemicolon()
            let a = 'parameters',
              o = 'typeAnnotation'
            if (n.kind === 'get')
              n[a].length > 0 &&
                (this.raise(R.BadGetterArity, this.state.curPosition()),
                this.isThisParam(n[a][0]) &&
                  this.raise(
                    pe.AccesorCannotDeclareThisParameter,
                    this.state.curPosition()
                  ))
            else if (n.kind === 'set') {
              if (n[a].length !== 1)
                this.raise(R.BadSetterArity, this.state.curPosition())
              else {
                let u = n[a][0]
                this.isThisParam(u) &&
                  this.raise(
                    pe.AccesorCannotDeclareThisParameter,
                    this.state.curPosition()
                  ),
                  u.type === 'Identifier' &&
                    u.optional &&
                    this.raise(
                      pe.SetAccesorCannotHaveOptionalParameter,
                      this.state.curPosition()
                    ),
                  u.type === 'RestElement' &&
                    this.raise(
                      pe.SetAccesorCannotHaveRestParameter,
                      this.state.curPosition()
                    )
              }
              n[o] && this.raise(pe.SetAccesorCannotHaveReturnType, n[o])
            } else n.kind = 'method'
            return this.finishNode(n, 'TSMethodSignature')
          } else {
            let n = r
            i && (n.readonly = !0)
            let a = this.tsTryParseTypeAnnotation()
            return (
              a && (n.typeAnnotation = a),
              this.tsParseTypeMemberSemicolon(),
              this.finishNode(n, 'TSPropertySignature')
            )
          }
        }
        tsParseTypeMember() {
          let s = this.startNode()
          if (this.match(10) || this.match(47))
            return this.tsParseSignatureMember('TSCallSignatureDeclaration', s)
          if (this.match(77)) {
            let r = this.startNode()
            return (
              this.next(),
              this.match(10) || this.match(47)
                ? this.tsParseSignatureMember(
                    'TSConstructSignatureDeclaration',
                    s
                  )
                : ((s.key = this.createIdentifier(r, 'new')),
                  this.tsParsePropertyOrMethodSignature(s, !1))
            )
          }
          this.tsParseModifiers(
            {
              allowedModifiers: ['readonly'],
              disallowedModifiers: [
                'declare',
                'abstract',
                'private',
                'protected',
                'public',
                'static',
                'override',
              ],
            },
            s
          )
          let i = this.tsTryParseIndexSignature(s)
          return (
            i ||
            (super.parsePropertyName(s),
            !s.computed &&
              s.key.type === 'Identifier' &&
              (s.key.name === 'get' || s.key.name === 'set') &&
              this.tsTokenCanFollowModifier() &&
              ((s.kind = s.key.name), super.parsePropertyName(s)),
            this.tsParsePropertyOrMethodSignature(s, !!s.readonly))
          )
        }
        tsParseTypeLiteral() {
          let s = this.startNode()
          return (
            (s.members = this.tsParseObjectTypeMembers()),
            this.finishNode(s, 'TSTypeLiteral')
          )
        }
        tsParseObjectTypeMembers() {
          this.expect(5)
          let s = this.tsParseList(
            'TypeMembers',
            this.tsParseTypeMember.bind(this)
          )
          return this.expect(8), s
        }
        tsIsStartOfMappedType() {
          return (
            this.next(),
            this.eat(53)
              ? this.isContextual(122)
              : (this.isContextual(122) && this.next(),
                !this.match(0) || (this.next(), !this.tsIsIdentifier())
                  ? !1
                  : (this.next(), this.match(58)))
          )
        }
        tsParseMappedTypeParameter() {
          let s = this.startNode()
          return (
            (s.name = this.tsParseTypeParameterName()),
            (s.constraint = this.tsExpectThenParseType(58)),
            this.finishNode(s, 'TSTypeParameter')
          )
        }
        tsParseMappedType() {
          let s = this.startNode()
          return (
            this.expect(5),
            this.match(53)
              ? ((s.readonly = this.state.value),
                this.next(),
                this.expectContextual(122))
              : this.eatContextual(122) && (s.readonly = !0),
            this.expect(0),
            (s.typeParameter = this.tsParseMappedTypeParameter()),
            (s.nameType = this.eatContextual(93) ? this.tsParseType() : null),
            this.expect(3),
            this.match(53)
              ? ((s.optional = this.state.value), this.next(), this.expect(17))
              : this.eat(17) && (s.optional = !0),
            (s.typeAnnotation = this.tsTryParseType()),
            this.semicolon(),
            this.expect(8),
            this.finishNode(s, 'TSMappedType')
          )
        }
        tsParseTupleType() {
          let s = this.startNode()
          s.elementTypes = this.tsParseBracketedList(
            'TupleElementTypes',
            this.tsParseTupleElementType.bind(this),
            !0,
            !1
          )
          let i = !1
          return (
            s.elementTypes.forEach((r) => {
              let { type: n } = r
              i &&
                n !== 'TSRestType' &&
                n !== 'TSOptionalType' &&
                !(n === 'TSNamedTupleMember' && r.optional) &&
                this.raise(pe.OptionalTypeBeforeRequired, r),
                i ||
                  (i =
                    (n === 'TSNamedTupleMember' && r.optional) ||
                    n === 'TSOptionalType')
            }),
            this.finishNode(s, 'TSTupleType')
          )
        }
        tsParseTupleElementType() {
          let { startLoc: s } = this.state,
            i = this.eat(21),
            r,
            n,
            a,
            o,
            l = Hs(this.state.type) ? this.lookaheadCharCode() : null
          if (l === 58)
            (r = !0),
              (a = !1),
              (n = this.parseIdentifier(!0)),
              this.expect(14),
              (o = this.tsParseType())
          else if (l === 63) {
            a = !0
            let c = this.state.startLoc,
              f = this.state.value,
              h = this.tsParseNonArrayType()
            this.lookaheadCharCode() === 58
              ? ((r = !0),
                (n = this.createIdentifier(this.startNodeAt(c), f)),
                this.expect(17),
                this.expect(14),
                (o = this.tsParseType()))
              : ((r = !1), (o = h), this.expect(17))
          } else
            (o = this.tsParseType()), (a = this.eat(17)), (r = this.eat(14))
          if (r) {
            let c
            n
              ? ((c = this.startNodeAtNode(n)),
                (c.optional = a),
                (c.label = n),
                (c.elementType = o),
                this.eat(17) &&
                  ((c.optional = !0),
                  this.raise(
                    pe.TupleOptionalAfterType,
                    this.state.lastTokStartLoc
                  )))
              : ((c = this.startNodeAtNode(o)),
                (c.optional = a),
                this.raise(pe.InvalidTupleMemberLabel, o),
                (c.label = o),
                (c.elementType = this.tsParseType())),
              (o = this.finishNode(c, 'TSNamedTupleMember'))
          } else if (a) {
            let c = this.startNodeAtNode(o)
            ;(c.typeAnnotation = o), (o = this.finishNode(c, 'TSOptionalType'))
          }
          if (i) {
            let c = this.startNodeAt(s)
            ;(c.typeAnnotation = o), (o = this.finishNode(c, 'TSRestType'))
          }
          return o
        }
        tsParseParenthesizedType() {
          let s = this.startNode()
          return (
            this.expect(10),
            (s.typeAnnotation = this.tsParseType()),
            this.expect(11),
            this.finishNode(s, 'TSParenthesizedType')
          )
        }
        tsParseFunctionOrConstructorType(s, i) {
          let r = this.startNode()
          return (
            s === 'TSConstructorType' &&
              ((r.abstract = !!i), i && this.next(), this.next()),
            this.tsInAllowConditionalTypesContext(() =>
              this.tsFillSignature(19, r)
            ),
            this.finishNode(r, s)
          )
        }
        tsParseLiteralTypeNode() {
          let s = this.startNode()
          switch (this.state.type) {
            case 134:
            case 135:
            case 133:
            case 85:
            case 86:
              s.literal = super.parseExprAtom()
              break
            default:
              this.unexpected()
          }
          return this.finishNode(s, 'TSLiteralType')
        }
        tsParseTemplateLiteralType() {
          let s = this.startNode()
          return (
            (s.literal = super.parseTemplate(!1)),
            this.finishNode(s, 'TSLiteralType')
          )
        }
        parseTemplateSubstitution() {
          return this.state.inType
            ? this.tsParseType()
            : super.parseTemplateSubstitution()
        }
        tsParseThisTypeOrThisTypePredicate() {
          let s = this.tsParseThisTypeNode()
          return this.isContextual(116) && !this.hasPrecedingLineBreak()
            ? this.tsParseThisTypePredicate(s)
            : s
        }
        tsParseNonArrayType() {
          switch (this.state.type) {
            case 133:
            case 134:
            case 135:
            case 85:
            case 86:
              return this.tsParseLiteralTypeNode()
            case 53:
              if (this.state.value === '-') {
                let s = this.startNode(),
                  i = this.lookahead()
                return (
                  i.type !== 134 && i.type !== 135 && this.unexpected(),
                  (s.literal = this.parseMaybeUnary()),
                  this.finishNode(s, 'TSLiteralType')
                )
              }
              break
            case 78:
              return this.tsParseThisTypeOrThisTypePredicate()
            case 87:
              return this.tsParseTypeQuery()
            case 83:
              return this.tsParseImportType()
            case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
                ? this.tsParseMappedType()
                : this.tsParseTypeLiteral()
            case 0:
              return this.tsParseTupleType()
            case 10:
              return this.tsParseParenthesizedType()
            case 25:
            case 24:
              return this.tsParseTemplateLiteralType()
            default: {
              let { type: s } = this.state
              if (Ve(s) || s === 88 || s === 84) {
                let i =
                  s === 88
                    ? 'TSVoidKeyword'
                    : s === 84
                    ? 'TSNullKeyword'
                    : Dv(this.state.value)
                if (i !== void 0 && this.lookaheadCharCode() !== 46) {
                  let r = this.startNode()
                  return this.next(), this.finishNode(r, i)
                }
                return this.tsParseTypeReference()
              }
            }
          }
          this.unexpected()
        }
        tsParseArrayTypeOrHigher() {
          let s = this.tsParseNonArrayType()
          for (; !this.hasPrecedingLineBreak() && this.eat(0); )
            if (this.match(3)) {
              let i = this.startNodeAtNode(s)
              ;(i.elementType = s),
                this.expect(3),
                (s = this.finishNode(i, 'TSArrayType'))
            } else {
              let i = this.startNodeAtNode(s)
              ;(i.objectType = s),
                (i.indexType = this.tsParseType()),
                this.expect(3),
                (s = this.finishNode(i, 'TSIndexedAccessType'))
            }
          return s
        }
        tsParseTypeOperator() {
          let s = this.startNode(),
            i = this.state.value
          return (
            this.next(),
            (s.operator = i),
            (s.typeAnnotation = this.tsParseTypeOperatorOrHigher()),
            i === 'readonly' && this.tsCheckTypeAnnotationForReadOnly(s),
            this.finishNode(s, 'TSTypeOperator')
          )
        }
        tsCheckTypeAnnotationForReadOnly(s) {
          switch (s.typeAnnotation.type) {
            case 'TSTupleType':
            case 'TSArrayType':
              return
            default:
              this.raise(pe.UnexpectedReadonly, s)
          }
        }
        tsParseInferType() {
          let s = this.startNode()
          this.expectContextual(115)
          let i = this.startNode()
          return (
            (i.name = this.tsParseTypeParameterName()),
            (i.constraint = this.tsTryParse(() =>
              this.tsParseConstraintForInferType()
            )),
            (s.typeParameter = this.finishNode(i, 'TSTypeParameter')),
            this.finishNode(s, 'TSInferType')
          )
        }
        tsParseConstraintForInferType() {
          if (this.eat(81)) {
            let s = this.tsInDisallowConditionalTypesContext(() =>
              this.tsParseType()
            )
            if (this.state.inDisallowConditionalTypesContext || !this.match(17))
              return s
          }
        }
        tsParseTypeOperatorOrHigher() {
          return tv(this.state.type) && !this.state.containsEsc
            ? this.tsParseTypeOperator()
            : this.isContextual(115)
            ? this.tsParseInferType()
            : this.tsInAllowConditionalTypesContext(() =>
                this.tsParseArrayTypeOrHigher()
              )
        }
        tsParseUnionOrIntersectionType(s, i, r) {
          let n = this.startNode(),
            a = this.eat(r),
            o = []
          do o.push(i())
          while (this.eat(r))
          return o.length === 1 && !a
            ? o[0]
            : ((n.types = o), this.finishNode(n, s))
        }
        tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType(
            'TSIntersectionType',
            this.tsParseTypeOperatorOrHigher.bind(this),
            45
          )
        }
        tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType(
            'TSUnionType',
            this.tsParseIntersectionTypeOrHigher.bind(this),
            43
          )
        }
        tsIsStartOfFunctionType() {
          return this.match(47)
            ? !0
            : this.match(10) &&
                this.tsLookAhead(
                  this.tsIsUnambiguouslyStartOfFunctionType.bind(this)
                )
        }
        tsSkipParameterStart() {
          if (Ve(this.state.type) || this.match(78)) return this.next(), !0
          if (this.match(5)) {
            let { errors: s } = this.state,
              i = s.length
            try {
              return this.parseObjectLike(8, !0), s.length === i
            } catch (r) {
              return !1
            }
          }
          if (this.match(0)) {
            this.next()
            let { errors: s } = this.state,
              i = s.length
            try {
              return super.parseBindingList(3, 93, 1), s.length === i
            } catch (r) {
              return !1
            }
          }
          return !1
        }
        tsIsUnambiguouslyStartOfFunctionType() {
          return (
            this.next(),
            !!(
              this.match(11) ||
              this.match(21) ||
              (this.tsSkipParameterStart() &&
                (this.match(14) ||
                  this.match(12) ||
                  this.match(17) ||
                  this.match(29) ||
                  (this.match(11) && (this.next(), this.match(19)))))
            )
          )
        }
        tsParseTypeOrTypePredicateAnnotation(s) {
          return this.tsInType(() => {
            let i = this.startNode()
            this.expect(s)
            let r = this.startNode(),
              n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this))
            if (n && this.match(78)) {
              let u = this.tsParseThisTypeOrThisTypePredicate()
              return (
                u.type === 'TSThisType'
                  ? ((r.parameterName = u),
                    (r.asserts = !0),
                    (r.typeAnnotation = null),
                    (u = this.finishNode(r, 'TSTypePredicate')))
                  : (this.resetStartLocationFromNode(u, r), (u.asserts = !0)),
                (i.typeAnnotation = u),
                this.finishNode(i, 'TSTypeAnnotation')
              )
            }
            let a =
              this.tsIsIdentifier() &&
              this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this))
            if (!a)
              return n
                ? ((r.parameterName = this.parseIdentifier()),
                  (r.asserts = n),
                  (r.typeAnnotation = null),
                  (i.typeAnnotation = this.finishNode(r, 'TSTypePredicate')),
                  this.finishNode(i, 'TSTypeAnnotation'))
                : this.tsParseTypeAnnotation(!1, i)
            let o = this.tsParseTypeAnnotation(!1)
            return (
              (r.parameterName = a),
              (r.typeAnnotation = o),
              (r.asserts = n),
              (i.typeAnnotation = this.finishNode(r, 'TSTypePredicate')),
              this.finishNode(i, 'TSTypeAnnotation')
            )
          })
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
          if (this.match(14))
            return this.tsParseTypeOrTypePredicateAnnotation(14)
        }
        tsTryParseTypeAnnotation() {
          if (this.match(14)) return this.tsParseTypeAnnotation()
        }
        tsTryParseType() {
          return this.tsEatThenParseType(14)
        }
        tsParseTypePredicatePrefix() {
          let s = this.parseIdentifier()
          if (this.isContextual(116) && !this.hasPrecedingLineBreak())
            return this.next(), s
        }
        tsParseTypePredicateAsserts() {
          if (this.state.type !== 109) return !1
          let s = this.state.containsEsc
          return (
            this.next(),
            !Ve(this.state.type) && !this.match(78)
              ? !1
              : (s &&
                  this.raise(
                    R.InvalidEscapedReservedWord,
                    this.state.lastTokStartLoc,
                    { reservedWord: 'asserts' }
                  ),
                !0)
          )
        }
        tsParseTypeAnnotation(s = !0, i = this.startNode()) {
          return (
            this.tsInType(() => {
              s && this.expect(14), (i.typeAnnotation = this.tsParseType())
            }),
            this.finishNode(i, 'TSTypeAnnotation')
          )
        }
        tsParseType() {
          P1(this.state.inType)
          let s = this.tsParseNonConditionalType()
          if (
            this.state.inDisallowConditionalTypesContext ||
            this.hasPrecedingLineBreak() ||
            !this.eat(81)
          )
            return s
          let i = this.startNodeAtNode(s)
          return (
            (i.checkType = s),
            (i.extendsType = this.tsInDisallowConditionalTypesContext(() =>
              this.tsParseNonConditionalType()
            )),
            this.expect(17),
            (i.trueType = this.tsInAllowConditionalTypesContext(() =>
              this.tsParseType()
            )),
            this.expect(14),
            (i.falseType = this.tsInAllowConditionalTypesContext(() =>
              this.tsParseType()
            )),
            this.finishNode(i, 'TSConditionalType')
          )
        }
        isAbstractConstructorSignature() {
          return this.isContextual(124) && this.lookahead().type === 77
        }
        tsParseNonConditionalType() {
          return this.tsIsStartOfFunctionType()
            ? this.tsParseFunctionOrConstructorType('TSFunctionType')
            : this.match(77)
            ? this.tsParseFunctionOrConstructorType('TSConstructorType')
            : this.isAbstractConstructorSignature()
            ? this.tsParseFunctionOrConstructorType('TSConstructorType', !0)
            : this.tsParseUnionTypeOrHigher()
        }
        tsParseTypeAssertion() {
          this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') &&
            this.raise(pe.ReservedTypeAssertion, this.state.startLoc)
          let s = this.startNode()
          return (
            (s.typeAnnotation = this.tsInType(
              () => (
                this.next(),
                this.match(75)
                  ? this.tsParseTypeReference()
                  : this.tsParseType()
              )
            )),
            this.expect(48),
            (s.expression = this.parseMaybeUnary()),
            this.finishNode(s, 'TSTypeAssertion')
          )
        }
        tsParseHeritageClause(s) {
          let i = this.state.startLoc,
            r = this.tsParseDelimitedList('HeritageClauseElement', () => {
              let n = this.startNode()
              return (
                (n.expression = this.tsParseEntityName()),
                this.match(47) &&
                  (n.typeParameters = this.tsParseTypeArguments()),
                this.finishNode(n, 'TSExpressionWithTypeArguments')
              )
            })
          return (
            r.length || this.raise(pe.EmptyHeritageClauseType, i, { token: s }),
            r
          )
        }
        tsParseInterfaceDeclaration(s, i = {}) {
          if (this.hasFollowingLineBreak()) return null
          this.expectContextual(129),
            i.declare && (s.declare = !0),
            Ve(this.state.type)
              ? ((s.id = this.parseIdentifier()),
                this.checkIdentifier(s.id, 130))
              : ((s.id = null),
                this.raise(pe.MissingInterfaceName, this.state.startLoc)),
            (s.typeParameters = this.tsTryParseTypeParameters(
              this.tsParseInOutConstModifiers
            )),
            this.eat(81) && (s.extends = this.tsParseHeritageClause('extends'))
          let r = this.startNode()
          return (
            (r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))),
            (s.body = this.finishNode(r, 'TSInterfaceBody')),
            this.finishNode(s, 'TSInterfaceDeclaration')
          )
        }
        tsParseTypeAliasDeclaration(s) {
          return (
            (s.id = this.parseIdentifier()),
            this.checkIdentifier(s.id, 2),
            (s.typeAnnotation = this.tsInType(() => {
              if (
                ((s.typeParameters = this.tsTryParseTypeParameters(
                  this.tsParseInOutModifiers
                )),
                this.expect(29),
                this.isContextual(114) && this.lookahead().type !== 16)
              ) {
                let i = this.startNode()
                return this.next(), this.finishNode(i, 'TSIntrinsicKeyword')
              }
              return this.tsParseType()
            })),
            this.semicolon(),
            this.finishNode(s, 'TSTypeAliasDeclaration')
          )
        }
        tsInNoContext(s) {
          let i = this.state.context
          this.state.context = [i[0]]
          try {
            return s()
          } finally {
            this.state.context = i
          }
        }
        tsInType(s) {
          let i = this.state.inType
          this.state.inType = !0
          try {
            return s()
          } finally {
            this.state.inType = i
          }
        }
        tsInDisallowConditionalTypesContext(s) {
          let i = this.state.inDisallowConditionalTypesContext
          this.state.inDisallowConditionalTypesContext = !0
          try {
            return s()
          } finally {
            this.state.inDisallowConditionalTypesContext = i
          }
        }
        tsInAllowConditionalTypesContext(s) {
          let i = this.state.inDisallowConditionalTypesContext
          this.state.inDisallowConditionalTypesContext = !1
          try {
            return s()
          } finally {
            this.state.inDisallowConditionalTypesContext = i
          }
        }
        tsEatThenParseType(s) {
          if (this.match(s)) return this.tsNextThenParseType()
        }
        tsExpectThenParseType(s) {
          return this.tsInType(() => (this.expect(s), this.tsParseType()))
        }
        tsNextThenParseType() {
          return this.tsInType(() => (this.next(), this.tsParseType()))
        }
        tsParseEnumMember() {
          let s = this.startNode()
          return (
            (s.id = this.match(133)
              ? super.parseStringLiteral(this.state.value)
              : this.parseIdentifier(!0)),
            this.eat(29) && (s.initializer = super.parseMaybeAssignAllowIn()),
            this.finishNode(s, 'TSEnumMember')
          )
        }
        tsParseEnumDeclaration(s, i = {}) {
          return (
            i.const && (s.const = !0),
            i.declare && (s.declare = !0),
            this.expectContextual(126),
            (s.id = this.parseIdentifier()),
            this.checkIdentifier(s.id, s.const ? 8971 : 8459),
            this.expect(5),
            (s.members = this.tsParseDelimitedList(
              'EnumMembers',
              this.tsParseEnumMember.bind(this)
            )),
            this.expect(8),
            this.finishNode(s, 'TSEnumDeclaration')
          )
        }
        tsParseModuleBlock() {
          let s = this.startNode()
          return (
            this.scope.enter(0),
            this.expect(5),
            super.parseBlockOrModuleBlockBody((s.body = []), void 0, !0, 8),
            this.scope.exit(),
            this.finishNode(s, 'TSModuleBlock')
          )
        }
        tsParseModuleOrNamespaceDeclaration(s, i = !1) {
          if (
            ((s.id = this.parseIdentifier()),
            i || this.checkIdentifier(s.id, 1024),
            this.eat(16))
          ) {
            let r = this.startNode()
            this.tsParseModuleOrNamespaceDeclaration(r, !0), (s.body = r)
          } else
            this.scope.enter(256),
              this.prodParam.enter(0),
              (s.body = this.tsParseModuleBlock()),
              this.prodParam.exit(),
              this.scope.exit()
          return this.finishNode(s, 'TSModuleDeclaration')
        }
        tsParseAmbientExternalModuleDeclaration(s) {
          return (
            this.isContextual(112)
              ? ((s.global = !0), (s.id = this.parseIdentifier()))
              : this.match(133)
              ? (s.id = super.parseStringLiteral(this.state.value))
              : this.unexpected(),
            this.match(5)
              ? (this.scope.enter(256),
                this.prodParam.enter(0),
                (s.body = this.tsParseModuleBlock()),
                this.prodParam.exit(),
                this.scope.exit())
              : this.semicolon(),
            this.finishNode(s, 'TSModuleDeclaration')
          )
        }
        tsParseImportEqualsDeclaration(s, i, r) {
          ;(s.isExport = r || !1),
            (s.id = i || this.parseIdentifier()),
            this.checkIdentifier(s.id, 4096),
            this.expect(29)
          let n = this.tsParseModuleReference()
          return (
            s.importKind === 'type' &&
              n.type !== 'TSExternalModuleReference' &&
              this.raise(pe.ImportAliasHasImportType, n),
            (s.moduleReference = n),
            this.semicolon(),
            this.finishNode(s, 'TSImportEqualsDeclaration')
          )
        }
        tsIsExternalModuleReference() {
          return this.isContextual(119) && this.lookaheadCharCode() === 40
        }
        tsParseModuleReference() {
          return this.tsIsExternalModuleReference()
            ? this.tsParseExternalModuleReference()
            : this.tsParseEntityName(!1)
        }
        tsParseExternalModuleReference() {
          let s = this.startNode()
          return (
            this.expectContextual(119),
            this.expect(10),
            this.match(133) || this.unexpected(),
            (s.expression = super.parseExprAtom()),
            this.expect(11),
            (this.sawUnambiguousESM = !0),
            this.finishNode(s, 'TSExternalModuleReference')
          )
        }
        tsLookAhead(s) {
          let i = this.state.clone(),
            r = s()
          return (this.state = i), r
        }
        tsTryParseAndCatch(s) {
          let i = this.tryParse((r) => s() || r())
          if (!(i.aborted || !i.node))
            return i.error && (this.state = i.failState), i.node
        }
        tsTryParse(s) {
          let i = this.state.clone(),
            r = s()
          if (r !== void 0 && r !== !1) return r
          this.state = i
        }
        tsTryParseDeclare(s) {
          if (this.isLineTerminator()) return
          let i = this.state.type,
            r
          return (
            this.isContextual(100) && ((i = 74), (r = 'let')),
            this.tsInAmbientContext(() => {
              switch (i) {
                case 68:
                  return (
                    (s.declare = !0), super.parseFunctionStatement(s, !1, !1)
                  )
                case 80:
                  return (s.declare = !0), this.parseClass(s, !0, !1)
                case 126:
                  return this.tsParseEnumDeclaration(s, { declare: !0 })
                case 112:
                  return this.tsParseAmbientExternalModuleDeclaration(s)
                case 75:
                case 74:
                  return !this.match(75) || !this.isLookaheadContextual('enum')
                    ? ((s.declare = !0),
                      this.parseVarStatement(s, r || this.state.value, !0))
                    : (this.expect(75),
                      this.tsParseEnumDeclaration(s, {
                        const: !0,
                        declare: !0,
                      }))
                case 129: {
                  let n = this.tsParseInterfaceDeclaration(s, { declare: !0 })
                  if (n) return n
                }
                default:
                  if (Ve(i))
                    return this.tsParseDeclaration(
                      s,
                      this.state.value,
                      !0,
                      null
                    )
              }
            })
          )
        }
        tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(
            this.startNode(),
            this.state.value,
            !0,
            null
          )
        }
        tsParseExpressionStatement(s, i, r) {
          switch (i.name) {
            case 'declare': {
              let n = this.tsTryParseDeclare(s)
              return n && (n.declare = !0), n
            }
            case 'global':
              if (this.match(5)) {
                this.scope.enter(256), this.prodParam.enter(0)
                let n = s
                return (
                  (n.global = !0),
                  (n.id = i),
                  (n.body = this.tsParseModuleBlock()),
                  this.scope.exit(),
                  this.prodParam.exit(),
                  this.finishNode(n, 'TSModuleDeclaration')
                )
              }
              break
            default:
              return this.tsParseDeclaration(s, i.name, !1, r)
          }
        }
        tsParseDeclaration(s, i, r, n) {
          switch (i) {
            case 'abstract':
              if (
                this.tsCheckLineTerminator(r) &&
                (this.match(80) || Ve(this.state.type))
              )
                return this.tsParseAbstractDeclaration(s, n)
              break
            case 'module':
              if (this.tsCheckLineTerminator(r)) {
                if (this.match(133))
                  return this.tsParseAmbientExternalModuleDeclaration(s)
                if (Ve(this.state.type))
                  return this.tsParseModuleOrNamespaceDeclaration(s)
              }
              break
            case 'namespace':
              if (this.tsCheckLineTerminator(r) && Ve(this.state.type))
                return this.tsParseModuleOrNamespaceDeclaration(s)
              break
            case 'type':
              if (this.tsCheckLineTerminator(r) && Ve(this.state.type))
                return this.tsParseTypeAliasDeclaration(s)
              break
          }
        }
        tsCheckLineTerminator(s) {
          return s
            ? this.hasFollowingLineBreak()
              ? !1
              : (this.next(), !0)
            : !this.isLineTerminator()
        }
        tsTryParseGenericAsyncArrowFunction(s) {
          if (!this.match(47)) return
          let i = this.state.maybeInArrowParameters
          this.state.maybeInArrowParameters = !0
          let r = this.tsTryParseAndCatch(() => {
            let n = this.startNodeAt(s)
            return (
              (n.typeParameters = this.tsParseTypeParameters(
                this.tsParseConstModifier
              )),
              super.parseFunctionParams(n),
              (n.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()),
              this.expect(19),
              n
            )
          })
          if (((this.state.maybeInArrowParameters = i), !!r))
            return super.parseArrowExpression(r, null, !0)
        }
        tsParseTypeArgumentsInExpression() {
          if (this.reScan_lt() === 47) return this.tsParseTypeArguments()
        }
        tsParseTypeArguments() {
          let s = this.startNode()
          return (
            (s.params = this.tsInType(() =>
              this.tsInNoContext(
                () => (
                  this.expect(47),
                  this.tsParseDelimitedList(
                    'TypeParametersOrArguments',
                    this.tsParseType.bind(this)
                  )
                )
              )
            )),
            s.params.length === 0
              ? this.raise(pe.EmptyTypeArguments, s)
              : !this.state.inType &&
                this.curContext() === Ke.brace &&
                this.reScan_lt_gt(),
            this.expect(48),
            this.finishNode(s, 'TSTypeParameterInstantiation')
          )
        }
        tsIsDeclarationStart() {
          return sv(this.state.type)
        }
        isExportDefaultSpecifier() {
          return this.tsIsDeclarationStart()
            ? !1
            : super.isExportDefaultSpecifier()
        }
        parseAssignableListItem(s, i) {
          let r = this.state.startLoc,
            n = {}
          this.tsParseModifiers(
            {
              allowedModifiers: [
                'public',
                'private',
                'protected',
                'override',
                'readonly',
              ],
            },
            n
          )
          let a = n.accessibility,
            o = n.override,
            u = n.readonly
          !(s & 4) &&
            (a || u || o) &&
            this.raise(pe.UnexpectedParameterModifier, r)
          let l = this.parseMaybeDefault()
          this.parseAssignableListItemTypes(l, s)
          let c = this.parseMaybeDefault(l.loc.start, l)
          if (a || u || o) {
            let f = this.startNodeAt(r)
            return (
              i.length && (f.decorators = i),
              a && (f.accessibility = a),
              u && (f.readonly = u),
              o && (f.override = o),
              c.type !== 'Identifier' &&
                c.type !== 'AssignmentPattern' &&
                this.raise(pe.UnsupportedParameterPropertyKind, f),
              (f.parameter = c),
              this.finishNode(f, 'TSParameterProperty')
            )
          }
          return i.length && (l.decorators = i), c
        }
        isSimpleParameter(s) {
          return (
            (s.type === 'TSParameterProperty' &&
              super.isSimpleParameter(s.parameter)) ||
            super.isSimpleParameter(s)
          )
        }
        tsDisallowOptionalPattern(s) {
          for (let i of s.params)
            i.type !== 'Identifier' &&
              i.optional &&
              !this.state.isAmbientContext &&
              this.raise(pe.PatternIsOptional, i)
        }
        setArrowFunctionParameters(s, i, r) {
          super.setArrowFunctionParameters(s, i, r),
            this.tsDisallowOptionalPattern(s)
        }
        parseFunctionBodyAndFinish(s, i, r = !1) {
          this.match(14) &&
            (s.returnType = this.tsParseTypeOrTypePredicateAnnotation(14))
          let n =
            i === 'FunctionDeclaration'
              ? 'TSDeclareFunction'
              : i === 'ClassMethod' || i === 'ClassPrivateMethod'
              ? 'TSDeclareMethod'
              : void 0
          return n && !this.match(5) && this.isLineTerminator()
            ? this.finishNode(s, n)
            : n === 'TSDeclareFunction' &&
              this.state.isAmbientContext &&
              (this.raise(pe.DeclareFunctionHasImplementation, s), s.declare)
            ? super.parseFunctionBodyAndFinish(s, n, r)
            : (this.tsDisallowOptionalPattern(s),
              super.parseFunctionBodyAndFinish(s, i, r))
        }
        registerFunctionStatementId(s) {
          !s.body && s.id
            ? this.checkIdentifier(s.id, 1024)
            : super.registerFunctionStatementId(s)
        }
        tsCheckForInvalidTypeCasts(s) {
          s.forEach((i) => {
            ;(i == null ? void 0 : i.type) === 'TSTypeCastExpression' &&
              this.raise(pe.UnexpectedTypeAnnotation, i.typeAnnotation)
          })
        }
        toReferencedList(s, i) {
          return this.tsCheckForInvalidTypeCasts(s), s
        }
        parseArrayLike(s, i, r, n) {
          let a = super.parseArrayLike(s, i, r, n)
          return (
            a.type === 'ArrayExpression' &&
              this.tsCheckForInvalidTypeCasts(a.elements),
            a
          )
        }
        parseSubscript(s, i, r, n) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
            ;(this.state.canStartJSXElement = !1), this.next()
            let o = this.startNodeAt(i)
            return (o.expression = s), this.finishNode(o, 'TSNonNullExpression')
          }
          let a = !1
          if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (r) return (n.stop = !0), s
            ;(n.optionalChainMember = a = !0), this.next()
          }
          if (this.match(47) || this.match(51)) {
            let o,
              u = this.tsTryParseAndCatch(() => {
                if (!r && this.atPossibleAsyncArrow(s)) {
                  let h = this.tsTryParseGenericAsyncArrowFunction(i)
                  if (h) return h
                }
                let l = this.tsParseTypeArgumentsInExpression()
                if (!l) return
                if (a && !this.match(10)) {
                  o = this.state.curPosition()
                  return
                }
                if (ku(this.state.type)) {
                  let h = super.parseTaggedTemplateExpression(s, i, n)
                  return (h.typeParameters = l), h
                }
                if (!r && this.eat(10)) {
                  let h = this.startNodeAt(i)
                  return (
                    (h.callee = s),
                    (h.arguments = this.parseCallExpressionArguments(11, !1)),
                    this.tsCheckForInvalidTypeCasts(h.arguments),
                    (h.typeParameters = l),
                    n.optionalChainMember && (h.optional = a),
                    this.finishCallExpression(h, n.optionalChainMember)
                  )
                }
                let c = this.state.type
                if (
                  c === 48 ||
                  c === 52 ||
                  (c !== 10 && xh(c) && !this.hasPrecedingLineBreak())
                )
                  return
                let f = this.startNodeAt(i)
                return (
                  (f.expression = s),
                  (f.typeParameters = l),
                  this.finishNode(f, 'TSInstantiationExpression')
                )
              })
            if ((o && this.unexpected(o, 10), u))
              return (
                u.type === 'TSInstantiationExpression' &&
                  (this.match(16) ||
                    (this.match(18) && this.lookaheadCharCode() !== 40)) &&
                  this.raise(
                    pe.InvalidPropertyAccessAfterInstantiationExpression,
                    this.state.startLoc
                  ),
                u
              )
          }
          return super.parseSubscript(s, i, r, n)
        }
        parseNewCallee(s) {
          var i
          super.parseNewCallee(s)
          let { callee: r } = s
          r.type === 'TSInstantiationExpression' &&
            !((i = r.extra) != null && i.parenthesized) &&
            ((s.typeParameters = r.typeParameters), (s.callee = r.expression))
        }
        parseExprOp(s, i, r) {
          let n
          if (
            Lu(58) > r &&
            !this.hasPrecedingLineBreak() &&
            (this.isContextual(93) || (n = this.isContextual(120)))
          ) {
            let a = this.startNodeAt(i)
            return (
              (a.expression = s),
              (a.typeAnnotation = this.tsInType(
                () => (
                  this.next(),
                  this.match(75)
                    ? (n &&
                        this.raise(R.UnexpectedKeyword, this.state.startLoc, {
                          keyword: 'const',
                        }),
                      this.tsParseTypeReference())
                    : this.tsParseType()
                )
              )),
              this.finishNode(
                a,
                n ? 'TSSatisfiesExpression' : 'TSAsExpression'
              ),
              this.reScan_lt_gt(),
              this.parseExprOp(a, i, r)
            )
          }
          return super.parseExprOp(s, i, r)
        }
        checkReservedWord(s, i, r, n) {
          this.state.isAmbientContext || super.checkReservedWord(s, i, r, n)
        }
        checkImportReflection(s) {
          super.checkImportReflection(s),
            s.module &&
              s.importKind !== 'value' &&
              this.raise(
                pe.ImportReflectionHasImportType,
                s.specifiers[0].loc.start
              )
        }
        checkDuplicateExports() {}
        isPotentialImportPhase(s) {
          if (super.isPotentialImportPhase(s)) return !0
          if (this.isContextual(130)) {
            let i = this.lookaheadCharCode()
            return s ? i === 123 || i === 42 : i !== 61
          }
          return !s && this.isContextual(87)
        }
        applyImportPhase(s, i, r, n) {
          super.applyImportPhase(s, i, r, n),
            i
              ? (s.exportKind = r === 'type' ? 'type' : 'value')
              : (s.importKind = r === 'type' || r === 'typeof' ? r : 'value')
        }
        parseImport(s) {
          if (this.match(133))
            return (s.importKind = 'value'), super.parseImport(s)
          let i
          if (Ve(this.state.type) && this.lookaheadCharCode() === 61)
            return (
              (s.importKind = 'value'), this.tsParseImportEqualsDeclaration(s)
            )
          if (this.isContextual(130)) {
            let r = this.parseMaybeImportPhase(s, !1)
            if (this.lookaheadCharCode() === 61)
              return this.tsParseImportEqualsDeclaration(s, r)
            i = super.parseImportSpecifiersAndAfter(s, r)
          } else i = super.parseImport(s)
          return (
            i.importKind === 'type' &&
              i.specifiers.length > 1 &&
              i.specifiers[0].type === 'ImportDefaultSpecifier' &&
              this.raise(pe.TypeImportCannotSpecifyDefaultAndNamed, i),
            i
          )
        }
        parseExport(s, i) {
          if (this.match(83)) {
            this.next()
            let r = s,
              n = null
            return (
              this.isContextual(130) && this.isPotentialImportPhase(!1)
                ? (n = this.parseMaybeImportPhase(r, !1))
                : (r.importKind = 'value'),
              this.tsParseImportEqualsDeclaration(r, n, !0)
            )
          } else if (this.eat(29)) {
            let r = s
            return (
              (r.expression = super.parseExpression()),
              this.semicolon(),
              (this.sawUnambiguousESM = !0),
              this.finishNode(r, 'TSExportAssignment')
            )
          } else if (this.eatContextual(93)) {
            let r = s
            return (
              this.expectContextual(128),
              (r.id = this.parseIdentifier()),
              this.semicolon(),
              this.finishNode(r, 'TSNamespaceExportDeclaration')
            )
          } else return super.parseExport(s, i)
        }
        isAbstractClass() {
          return this.isContextual(124) && this.lookahead().type === 80
        }
        parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            let s = this.startNode()
            return this.next(), (s.abstract = !0), this.parseClass(s, !0, !0)
          }
          if (this.match(129)) {
            let s = this.tsParseInterfaceDeclaration(this.startNode())
            if (s) return s
          }
          return super.parseExportDefaultExpression()
        }
        parseVarStatement(s, i, r = !1) {
          let { isAmbientContext: n } = this.state,
            a = super.parseVarStatement(s, i, r || n)
          if (!n) return a
          for (let { id: o, init: u } of a.declarations)
            !u ||
              (i !== 'const' || !!o.typeAnnotation
                ? this.raise(pe.InitializerNotAllowedInAmbientContext, u)
                : Uv(u, this.hasPlugin('estree')) ||
                  this.raise(
                    pe.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference,
                    u
                  ))
          return a
        }
        parseStatementContent(s, i) {
          if (this.match(75) && this.isLookaheadContextual('enum')) {
            let r = this.startNode()
            return (
              this.expect(75), this.tsParseEnumDeclaration(r, { const: !0 })
            )
          }
          if (this.isContextual(126))
            return this.tsParseEnumDeclaration(this.startNode())
          if (this.isContextual(129)) {
            let r = this.tsParseInterfaceDeclaration(this.startNode())
            if (r) return r
          }
          return super.parseStatementContent(s, i)
        }
        parseAccessModifier() {
          return this.tsParseModifier(['public', 'protected', 'private'])
        }
        tsHasSomeModifiers(s, i) {
          return i.some((r) => (C1(r) ? s.accessibility === r : !!s[r]))
        }
        tsIsStartOfStaticBlocks() {
          return this.isContextual(106) && this.lookaheadCharCode() === 123
        }
        parseClassMember(s, i, r) {
          let n = [
            'declare',
            'private',
            'public',
            'protected',
            'override',
            'abstract',
            'readonly',
            'static',
          ]
          this.tsParseModifiers(
            {
              allowedModifiers: n,
              disallowedModifiers: ['in', 'out'],
              stopOnStartOfClassStaticBlock: !0,
              errorTemplate: pe.InvalidModifierOnTypeParameterPositions,
            },
            i
          )
          let a = () => {
            this.tsIsStartOfStaticBlocks()
              ? (this.next(),
                this.next(),
                this.tsHasSomeModifiers(i, n) &&
                  this.raise(
                    pe.StaticBlockCannotHaveModifier,
                    this.state.curPosition()
                  ),
                super.parseClassStaticBlock(s, i))
              : this.parseClassMemberWithIsStatic(s, i, r, !!i.static)
          }
          i.declare ? this.tsInAmbientContext(a) : a()
        }
        parseClassMemberWithIsStatic(s, i, r, n) {
          let a = this.tsTryParseIndexSignature(i)
          if (a) {
            s.body.push(a),
              i.abstract && this.raise(pe.IndexSignatureHasAbstract, i),
              i.accessibility &&
                this.raise(pe.IndexSignatureHasAccessibility, i, {
                  modifier: i.accessibility,
                }),
              i.declare && this.raise(pe.IndexSignatureHasDeclare, i),
              i.override && this.raise(pe.IndexSignatureHasOverride, i)
            return
          }
          !this.state.inAbstractClass &&
            i.abstract &&
            this.raise(pe.NonAbstractClassHasAbstractMethod, i),
            i.override &&
              (r.hadSuperClass || this.raise(pe.OverrideNotInSubClass, i)),
            super.parseClassMemberWithIsStatic(s, i, r, n)
        }
        parsePostMemberNameModifiers(s) {
          this.eat(17) && (s.optional = !0),
            s.readonly &&
              this.match(10) &&
              this.raise(pe.ClassMethodHasReadonly, s),
            s.declare &&
              this.match(10) &&
              this.raise(pe.ClassMethodHasDeclare, s)
        }
        parseExpressionStatement(s, i, r) {
          return (
            (i.type === 'Identifier'
              ? this.tsParseExpressionStatement(s, i, r)
              : void 0) || super.parseExpressionStatement(s, i, r)
          )
        }
        shouldParseExportDeclaration() {
          return this.tsIsDeclarationStart()
            ? !0
            : super.shouldParseExportDeclaration()
        }
        parseConditional(s, i, r) {
          if (!this.state.maybeInArrowParameters || !this.match(17))
            return super.parseConditional(s, i, r)
          let n = this.tryParse(() => super.parseConditional(s, i))
          return n.node
            ? (n.error && (this.state = n.failState), n.node)
            : (n.error && super.setOptionalParametersError(r, n.error), s)
        }
        parseParenItem(s, i) {
          let r = super.parseParenItem(s, i)
          if (
            (this.eat(17) && ((r.optional = !0), this.resetEndLocation(s)),
            this.match(14))
          ) {
            let n = this.startNodeAt(i)
            return (
              (n.expression = s),
              (n.typeAnnotation = this.tsParseTypeAnnotation()),
              this.finishNode(n, 'TSTypeCastExpression')
            )
          }
          return s
        }
        parseExportDeclaration(s) {
          if (!this.state.isAmbientContext && this.isContextual(125))
            return this.tsInAmbientContext(() => this.parseExportDeclaration(s))
          let i = this.state.startLoc,
            r = this.eatContextual(125)
          if (
            r &&
            (this.isContextual(125) || !this.shouldParseExportDeclaration())
          )
            throw this.raise(
              pe.ExpectedAmbientAfterExportDeclare,
              this.state.startLoc
            )
          let a =
            (Ve(this.state.type) && this.tsTryParseExportDeclaration()) ||
            super.parseExportDeclaration(s)
          return a
            ? ((a.type === 'TSInterfaceDeclaration' ||
                a.type === 'TSTypeAliasDeclaration' ||
                r) &&
                (s.exportKind = 'type'),
              r && (this.resetStartLocation(a, i), (a.declare = !0)),
              a)
            : null
        }
        parseClassId(s, i, r, n) {
          if ((!i || r) && this.isContextual(113)) return
          super.parseClassId(s, i, r, s.declare ? 1024 : 8331)
          let a = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers)
          a && (s.typeParameters = a)
        }
        parseClassPropertyAnnotation(s) {
          s.optional ||
            (this.eat(35)
              ? (s.definite = !0)
              : this.eat(17) && (s.optional = !0))
          let i = this.tsTryParseTypeAnnotation()
          i && (s.typeAnnotation = i)
        }
        parseClassProperty(s) {
          if (
            (this.parseClassPropertyAnnotation(s),
            this.state.isAmbientContext &&
              !(s.readonly && !s.typeAnnotation) &&
              this.match(29) &&
              this.raise(
                pe.DeclareClassFieldHasInitializer,
                this.state.startLoc
              ),
            s.abstract && this.match(29))
          ) {
            let { key: i } = s
            this.raise(pe.AbstractPropertyHasInitializer, this.state.startLoc, {
              propertyName:
                i.type === 'Identifier' && !s.computed
                  ? i.name
                  : `[${this.input.slice(i.start, i.end)}]`,
            })
          }
          return super.parseClassProperty(s)
        }
        parseClassPrivateProperty(s) {
          return (
            s.abstract && this.raise(pe.PrivateElementHasAbstract, s),
            s.accessibility &&
              this.raise(pe.PrivateElementHasAccessibility, s, {
                modifier: s.accessibility,
              }),
            this.parseClassPropertyAnnotation(s),
            super.parseClassPrivateProperty(s)
          )
        }
        parseClassAccessorProperty(s) {
          return (
            this.parseClassPropertyAnnotation(s),
            s.optional && this.raise(pe.AccessorCannotBeOptional, s),
            super.parseClassAccessorProperty(s)
          )
        }
        pushClassMethod(s, i, r, n, a, o) {
          let u = this.tsTryParseTypeParameters(this.tsParseConstModifier)
          u && a && this.raise(pe.ConstructorHasTypeParameters, u)
          let { declare: l = !1, kind: c } = i
          l &&
            (c === 'get' || c === 'set') &&
            this.raise(pe.DeclareAccessor, i, { kind: c }),
            u && (i.typeParameters = u),
            super.pushClassMethod(s, i, r, n, a, o)
        }
        pushClassPrivateMethod(s, i, r, n) {
          let a = this.tsTryParseTypeParameters(this.tsParseConstModifier)
          a && (i.typeParameters = a), super.pushClassPrivateMethod(s, i, r, n)
        }
        declareClassPrivateMethodInScope(s, i) {
          s.type !== 'TSDeclareMethod' &&
            ((s.type === 'MethodDefinition' &&
              !hasOwnProperty.call(s.value, 'body')) ||
              super.declareClassPrivateMethodInScope(s, i))
        }
        parseClassSuper(s) {
          super.parseClassSuper(s),
            s.superClass &&
              (this.match(47) || this.match(51)) &&
              (s.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
            this.eatContextual(113) &&
              (s.implements = this.tsParseHeritageClause('implements'))
        }
        parseObjPropValue(s, i, r, n, a, o, u) {
          let l = this.tsTryParseTypeParameters(this.tsParseConstModifier)
          return (
            l && (s.typeParameters = l),
            super.parseObjPropValue(s, i, r, n, a, o, u)
          )
        }
        parseFunctionParams(s, i) {
          let r = this.tsTryParseTypeParameters(this.tsParseConstModifier)
          r && (s.typeParameters = r), super.parseFunctionParams(s, i)
        }
        parseVarId(s, i) {
          super.parseVarId(s, i),
            s.id.type === 'Identifier' &&
              !this.hasPrecedingLineBreak() &&
              this.eat(35) &&
              (s.definite = !0)
          let r = this.tsTryParseTypeAnnotation()
          r && ((s.id.typeAnnotation = r), this.resetEndLocation(s.id))
        }
        parseAsyncArrowFromCallExpression(s, i) {
          return (
            this.match(14) && (s.returnType = this.tsParseTypeAnnotation()),
            super.parseAsyncArrowFromCallExpression(s, i)
          )
        }
        parseMaybeAssign(s, i) {
          var r, n, a, o, u
          let l, c, f
          if (this.hasPlugin('jsx') && (this.match(142) || this.match(47))) {
            if (
              ((l = this.state.clone()),
              (c = this.tryParse(() => super.parseMaybeAssign(s, i), l)),
              !c.error)
            )
              return c.node
            let { context: m } = this.state,
              y = m[m.length - 1]
            ;(y === Ke.j_oTag || y === Ke.j_expr) && m.pop()
          }
          if (!((r = c) != null && r.error) && !this.match(47))
            return super.parseMaybeAssign(s, i)
          ;(!l || l === this.state) && (l = this.state.clone())
          let h,
            p = this.tryParse((m) => {
              var y, x
              h = this.tsParseTypeParameters(this.tsParseConstModifier)
              let C = super.parseMaybeAssign(s, i)
              return (
                (C.type !== 'ArrowFunctionExpression' ||
                  ((y = C.extra) != null && y.parenthesized)) &&
                  m(),
                ((x = h) == null ? void 0 : x.params.length) !== 0 &&
                  this.resetStartLocationFromNode(C, h),
                (C.typeParameters = h),
                C
              )
            }, l)
          if (!p.error && !p.aborted)
            return h && this.reportReservedArrowTypeParam(h), p.node
          if (
            !c &&
            (P1(!this.hasPlugin('jsx')),
            (f = this.tryParse(() => super.parseMaybeAssign(s, i), l)),
            !f.error)
          )
            return f.node
          if ((n = c) != null && n.node)
            return (this.state = c.failState), c.node
          if (p.node)
            return (
              (this.state = p.failState),
              h && this.reportReservedArrowTypeParam(h),
              p.node
            )
          if ((a = f) != null && a.node)
            return (this.state = f.failState), f.node
          throw (
            ((o = c) == null ? void 0 : o.error) ||
            p.error ||
            ((u = f) == null ? void 0 : u.error)
          )
        }
        reportReservedArrowTypeParam(s) {
          var i
          s.params.length === 1 &&
            !s.params[0].constraint &&
            !((i = s.extra) != null && i.trailingComma) &&
            this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') &&
            this.raise(pe.ReservedArrowTypeParam, s)
        }
        parseMaybeUnary(s, i) {
          return !this.hasPlugin('jsx') && this.match(47)
            ? this.tsParseTypeAssertion()
            : super.parseMaybeUnary(s, i)
        }
        parseArrow(s) {
          if (this.match(14)) {
            let i = this.tryParse((r) => {
              let n = this.tsParseTypeOrTypePredicateAnnotation(14)
              return (this.canInsertSemicolon() || !this.match(19)) && r(), n
            })
            if (i.aborted) return
            i.thrown ||
              (i.error && (this.state = i.failState), (s.returnType = i.node))
          }
          return super.parseArrow(s)
        }
        parseAssignableListItemTypes(s, i) {
          if (!(i & 2)) return s
          this.eat(17) && (s.optional = !0)
          let r = this.tsTryParseTypeAnnotation()
          return r && (s.typeAnnotation = r), this.resetEndLocation(s), s
        }
        isAssignable(s, i) {
          switch (s.type) {
            case 'TSTypeCastExpression':
              return this.isAssignable(s.expression, i)
            case 'TSParameterProperty':
              return !0
            default:
              return super.isAssignable(s, i)
          }
        }
        toAssignable(s, i = !1) {
          switch (s.type) {
            case 'ParenthesizedExpression':
              this.toAssignableParenthesizedExpression(s, i)
              break
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSNonNullExpression':
            case 'TSTypeAssertion':
              i
                ? this.expressionScope.recordArrowParameterBindingError(
                    pe.UnexpectedTypeCastInParameter,
                    s
                  )
                : this.raise(pe.UnexpectedTypeCastInParameter, s),
                this.toAssignable(s.expression, i)
              break
            case 'AssignmentExpression':
              !i &&
                s.left.type === 'TSTypeCastExpression' &&
                (s.left = this.typeCastToParameter(s.left))
            default:
              super.toAssignable(s, i)
          }
        }
        toAssignableParenthesizedExpression(s, i) {
          switch (s.expression.type) {
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSNonNullExpression':
            case 'TSTypeAssertion':
            case 'ParenthesizedExpression':
              this.toAssignable(s.expression, i)
              break
            default:
              super.toAssignable(s, i)
          }
        }
        checkToRestConversion(s, i) {
          switch (s.type) {
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSTypeAssertion':
            case 'TSNonNullExpression':
              this.checkToRestConversion(s.expression, !1)
              break
            default:
              super.checkToRestConversion(s, i)
          }
        }
        isValidLVal(s, i, r) {
          return (
            Lv(
              {
                TSTypeCastExpression: !0,
                TSParameterProperty: 'parameter',
                TSNonNullExpression: 'expression',
                TSInstantiationExpression: 'expression',
                TSAsExpression: (r !== 64 || !i) && ['expression', !0],
                TSSatisfiesExpression: (r !== 64 || !i) && ['expression', !0],
                TSTypeAssertion: (r !== 64 || !i) && ['expression', !0],
              },
              s
            ) || super.isValidLVal(s, i, r)
          )
        }
        parseBindingAtom() {
          return this.state.type === 78
            ? this.parseIdentifier(!0)
            : super.parseBindingAtom()
        }
        parseMaybeDecoratorArguments(s) {
          if (this.match(47) || this.match(51)) {
            let i = this.tsParseTypeArgumentsInExpression()
            if (this.match(10)) {
              let r = super.parseMaybeDecoratorArguments(s)
              return (r.typeParameters = i), r
            }
            this.unexpected(null, 10)
          }
          return super.parseMaybeDecoratorArguments(s)
        }
        checkCommaAfterRest(s) {
          return this.state.isAmbientContext &&
            this.match(12) &&
            this.lookaheadCharCode() === s
            ? (this.next(), !1)
            : super.checkCommaAfterRest(s)
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod()
        }
        isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty()
        }
        parseMaybeDefault(s, i) {
          let r = super.parseMaybeDefault(s, i)
          return (
            r.type === 'AssignmentPattern' &&
              r.typeAnnotation &&
              r.right.start < r.typeAnnotation.start &&
              this.raise(pe.TypeAnnotationAfterAssign, r.typeAnnotation),
            r
          )
        }
        getTokenFromCode(s) {
          if (this.state.inType) {
            if (s === 62) {
              this.finishOp(48, 1)
              return
            }
            if (s === 60) {
              this.finishOp(47, 1)
              return
            }
          }
          super.getTokenFromCode(s)
        }
        reScan_lt_gt() {
          let { type: s } = this.state
          s === 47
            ? ((this.state.pos -= 1), this.readToken_lt())
            : s === 48 && ((this.state.pos -= 1), this.readToken_gt())
        }
        reScan_lt() {
          let { type: s } = this.state
          return s === 51
            ? ((this.state.pos -= 2), this.finishOp(47, 1), 47)
            : s
        }
        toAssignableList(s, i, r) {
          for (let n = 0; n < s.length; n++) {
            let a = s[n]
            ;(a == null ? void 0 : a.type) === 'TSTypeCastExpression' &&
              (s[n] = this.typeCastToParameter(a))
          }
          super.toAssignableList(s, i, r)
        }
        typeCastToParameter(s) {
          return (
            (s.expression.typeAnnotation = s.typeAnnotation),
            this.resetEndLocation(s.expression, s.typeAnnotation.loc.end),
            s.expression
          )
        }
        shouldParseArrow(s) {
          return this.match(14)
            ? s.every((i) => this.isAssignable(i, !0))
            : super.shouldParseArrow(s)
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow()
        }
        canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass()
        }
        jsxParseOpeningElementAfterName(s) {
          if (this.match(47) || this.match(51)) {
            let i = this.tsTryParseAndCatch(() =>
              this.tsParseTypeArgumentsInExpression()
            )
            i && (s.typeParameters = i)
          }
          return super.jsxParseOpeningElementAfterName(s)
        }
        getGetterSetterExpectedParamCount(s) {
          let i = super.getGetterSetterExpectedParamCount(s),
            n = this.getObjectOrClassMethodParams(s)[0]
          return n && this.isThisParam(n) ? i + 1 : i
        }
        parseCatchClauseParam() {
          let s = super.parseCatchClauseParam(),
            i = this.tsTryParseTypeAnnotation()
          return i && ((s.typeAnnotation = i), this.resetEndLocation(s)), s
        }
        tsInAmbientContext(s) {
          let { isAmbientContext: i, strict: r } = this.state
          ;(this.state.isAmbientContext = !0), (this.state.strict = !1)
          try {
            return s()
          } finally {
            ;(this.state.isAmbientContext = i), (this.state.strict = r)
          }
        }
        parseClass(s, i, r) {
          let n = this.state.inAbstractClass
          this.state.inAbstractClass = !!s.abstract
          try {
            return super.parseClass(s, i, r)
          } finally {
            this.state.inAbstractClass = n
          }
        }
        tsParseAbstractDeclaration(s, i) {
          if (this.match(80))
            return (
              (s.abstract = !0),
              this.maybeTakeDecorators(i, this.parseClass(s, !0, !1))
            )
          if (this.isContextual(129)) {
            if (!this.hasFollowingLineBreak())
              return (
                (s.abstract = !0),
                this.raise(pe.NonClassMethodPropertyHasAbstractModifer, s),
                this.tsParseInterfaceDeclaration(s)
              )
          } else this.unexpected(null, 80)
        }
        parseMethod(s, i, r, n, a, o, u) {
          let l = super.parseMethod(s, i, r, n, a, o, u)
          if (
            l.abstract &&
            (this.hasPlugin('estree') ? !!l.value.body : !!l.body)
          ) {
            let { key: f } = l
            this.raise(pe.AbstractMethodHasImplementation, l, {
              methodName:
                f.type === 'Identifier' && !l.computed
                  ? f.name
                  : `[${this.input.slice(f.start, f.end)}]`,
            })
          }
          return l
        }
        tsParseTypeParameterName() {
          return this.parseIdentifier().name
        }
        shouldParseAsAmbientContext() {
          return !!this.getPluginOption('typescript', 'dts')
        }
        parse() {
          return (
            this.shouldParseAsAmbientContext() &&
              (this.state.isAmbientContext = !0),
            super.parse()
          )
        }
        getExpression() {
          return (
            this.shouldParseAsAmbientContext() &&
              (this.state.isAmbientContext = !0),
            super.getExpression()
          )
        }
        parseExportSpecifier(s, i, r, n) {
          return !i && n
            ? (this.parseTypeOnlyImportExportSpecifier(s, !1, r),
              this.finishNode(s, 'ExportSpecifier'))
            : ((s.exportKind = 'value'), super.parseExportSpecifier(s, i, r, n))
        }
        parseImportSpecifier(s, i, r, n, a) {
          return !i && n
            ? (this.parseTypeOnlyImportExportSpecifier(s, !0, r),
              this.finishNode(s, 'ImportSpecifier'))
            : ((s.importKind = 'value'),
              super.parseImportSpecifier(s, i, r, n, r ? 4098 : 4096))
        }
        parseTypeOnlyImportExportSpecifier(s, i, r) {
          let n = i ? 'imported' : 'local',
            a = i ? 'local' : 'exported',
            o = s[n],
            u,
            l = !1,
            c = !0,
            f = o.loc.start
          if (this.isContextual(93)) {
            let p = this.parseIdentifier()
            if (this.isContextual(93)) {
              let m = this.parseIdentifier()
              Hs(this.state.type)
                ? ((l = !0),
                  (o = p),
                  (u = i
                    ? this.parseIdentifier()
                    : this.parseModuleExportName()),
                  (c = !1))
                : ((u = m), (c = !1))
            } else
              Hs(this.state.type)
                ? ((c = !1),
                  (u = i
                    ? this.parseIdentifier()
                    : this.parseModuleExportName()))
                : ((l = !0), (o = p))
          } else
            Hs(this.state.type) &&
              ((l = !0),
              i
                ? ((o = this.parseIdentifier(!0)),
                  this.isContextual(93) ||
                    this.checkReservedWord(o.name, o.loc.start, !0, !0))
                : (o = this.parseModuleExportName()))
          l &&
            r &&
            this.raise(
              i
                ? pe.TypeModifierIsUsedInTypeImports
                : pe.TypeModifierIsUsedInTypeExports,
              f
            ),
            (s[n] = o),
            (s[a] = u)
          let h = i ? 'importKind' : 'exportKind'
          ;(s[h] = l ? 'type' : 'value'),
            c &&
              this.eatContextual(93) &&
              (s[a] = i
                ? this.parseIdentifier()
                : this.parseModuleExportName()),
            s[a] || (s[a] = bi(s[n])),
            i && this.checkIdentifier(s[a], l ? 4098 : 4096)
        }
      }
    function Vv(t) {
      if (t.type !== 'MemberExpression') return !1
      let { computed: e, property: s } = t
      return e &&
        s.type !== 'StringLiteral' &&
        (s.type !== 'TemplateLiteral' || s.expressions.length > 0)
        ? !1
        : N1(t.object)
    }
    function Uv(t, e) {
      var s
      let { type: i } = t
      if ((s = t.extra) != null && s.parenthesized) return !1
      if (e) {
        if (i === 'Literal') {
          let { value: r } = t
          if (typeof r == 'string' || typeof r == 'boolean') return !0
        }
      } else if (i === 'StringLiteral' || i === 'BooleanLiteral') return !0
      return !!(
        v1(t, e) ||
        Hv(t, e) ||
        (i === 'TemplateLiteral' && t.expressions.length === 0) ||
        Vv(t)
      )
    }
    function v1(t, e) {
      return e
        ? t.type === 'Literal' && (typeof t.value == 'number' || 'bigint' in t)
        : t.type === 'NumericLiteral' || t.type === 'BigIntLiteral'
    }
    function Hv(t, e) {
      if (t.type === 'UnaryExpression') {
        let { operator: s, argument: i } = t
        if (s === '-' && v1(i, e)) return !0
      }
      return !1
    }
    function N1(t) {
      return t.type === 'Identifier'
        ? !0
        : t.type !== 'MemberExpression' || t.computed
        ? !1
        : N1(t.object)
    }
    var I1 = pi`placeholders`({
        ClassNameIsRequired: 'A class name is required.',
        UnexpectedSpace: 'Unexpected space in placeholder.',
      }),
      $v = (t) =>
        class extends t {
          parsePlaceholder(s) {
            if (this.match(144)) {
              let i = this.startNode()
              return (
                this.next(),
                this.assertNoSpace(),
                (i.name = super.parseIdentifier(!0)),
                this.assertNoSpace(),
                this.expect(144),
                this.finishPlaceholder(i, s)
              )
            }
          }
          finishPlaceholder(s, i) {
            let r = s
            return (
              (!r.expectedNode || !r.type) &&
                (r = this.finishNode(r, 'Placeholder')),
              (r.expectedNode = i),
              r
            )
          }
          getTokenFromCode(s) {
            s === 37 && this.input.charCodeAt(this.state.pos + 1) === 37
              ? this.finishOp(144, 2)
              : super.getTokenFromCode(s)
          }
          parseExprAtom(s) {
            return this.parsePlaceholder('Expression') || super.parseExprAtom(s)
          }
          parseIdentifier(s) {
            return (
              this.parsePlaceholder('Identifier') || super.parseIdentifier(s)
            )
          }
          checkReservedWord(s, i, r, n) {
            s !== void 0 && super.checkReservedWord(s, i, r, n)
          }
          parseBindingAtom() {
            return this.parsePlaceholder('Pattern') || super.parseBindingAtom()
          }
          isValidLVal(s, i, r) {
            return s === 'Placeholder' || super.isValidLVal(s, i, r)
          }
          toAssignable(s, i) {
            s && s.type === 'Placeholder' && s.expectedNode === 'Expression'
              ? (s.expectedNode = 'Pattern')
              : super.toAssignable(s, i)
          }
          chStartsBindingIdentifier(s, i) {
            return !!(
              super.chStartsBindingIdentifier(s, i) ||
              this.lookahead().type === 144
            )
          }
          verifyBreakContinue(s, i) {
            ;(s.label && s.label.type === 'Placeholder') ||
              super.verifyBreakContinue(s, i)
          }
          parseExpressionStatement(s, i) {
            var r
            if (
              i.type !== 'Placeholder' ||
              ((r = i.extra) != null && r.parenthesized)
            )
              return super.parseExpressionStatement(s, i)
            if (this.match(14)) {
              let a = s
              return (
                (a.label = this.finishPlaceholder(i, 'Identifier')),
                this.next(),
                (a.body =
                  super.parseStatementOrSloppyAnnexBFunctionDeclaration()),
                this.finishNode(a, 'LabeledStatement')
              )
            }
            this.semicolon()
            let n = s
            return (n.name = i.name), this.finishPlaceholder(n, 'Statement')
          }
          parseBlock(s, i, r) {
            return (
              this.parsePlaceholder('BlockStatement') ||
              super.parseBlock(s, i, r)
            )
          }
          parseFunctionId(s) {
            return (
              this.parsePlaceholder('Identifier') || super.parseFunctionId(s)
            )
          }
          parseClass(s, i, r) {
            let n = i ? 'ClassDeclaration' : 'ClassExpression'
            this.next()
            let a = this.state.strict,
              o = this.parsePlaceholder('Identifier')
            if (o)
              if (this.match(81) || this.match(144) || this.match(5)) s.id = o
              else {
                if (r || !i)
                  return (
                    (s.id = null),
                    (s.body = this.finishPlaceholder(o, 'ClassBody')),
                    this.finishNode(s, n)
                  )
                throw this.raise(I1.ClassNameIsRequired, this.state.startLoc)
              }
            else this.parseClassId(s, i, r)
            return (
              super.parseClassSuper(s),
              (s.body =
                this.parsePlaceholder('ClassBody') ||
                super.parseClassBody(!!s.superClass, a)),
              this.finishNode(s, n)
            )
          }
          parseExport(s, i) {
            let r = this.parsePlaceholder('Identifier')
            if (!r) return super.parseExport(s, i)
            let n = s
            if (!this.isContextual(98) && !this.match(12))
              return (
                (n.specifiers = []),
                (n.source = null),
                (n.declaration = this.finishPlaceholder(r, 'Declaration')),
                this.finishNode(n, 'ExportNamedDeclaration')
              )
            this.expectPlugin('exportDefaultFrom')
            let a = this.startNode()
            return (
              (a.exported = r),
              (n.specifiers = [this.finishNode(a, 'ExportDefaultSpecifier')]),
              super.parseExport(n, i)
            )
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              let s = this.nextTokenStart()
              if (
                this.isUnparsedContextual(s, 'from') &&
                this.input.startsWith(Zi(144), this.nextTokenStartSince(s + 4))
              )
                return !0
            }
            return super.isExportDefaultSpecifier()
          }
          maybeParseExportDefaultSpecifier(s, i) {
            var r
            return (r = s.specifiers) != null && r.length
              ? !0
              : super.maybeParseExportDefaultSpecifier(s, i)
          }
          checkExport(s) {
            let { specifiers: i } = s
            i != null &&
              i.length &&
              (s.specifiers = i.filter(
                (r) => r.exported.type === 'Placeholder'
              )),
              super.checkExport(s),
              (s.specifiers = i)
          }
          parseImport(s) {
            let i = this.parsePlaceholder('Identifier')
            if (!i) return super.parseImport(s)
            if (
              ((s.specifiers = []), !this.isContextual(98) && !this.match(12))
            )
              return (
                (s.source = this.finishPlaceholder(i, 'StringLiteral')),
                this.semicolon(),
                this.finishNode(s, 'ImportDeclaration')
              )
            let r = this.startNodeAtNode(i)
            return (
              (r.local = i),
              s.specifiers.push(this.finishNode(r, 'ImportDefaultSpecifier')),
              this.eat(12) &&
                (this.maybeParseStarImportSpecifier(s) ||
                  this.parseNamedImportSpecifiers(s)),
              this.expectContextual(98),
              (s.source = this.parseImportSource()),
              this.semicolon(),
              this.finishNode(s, 'ImportDeclaration')
            )
          }
          parseImportSource() {
            return (
              this.parsePlaceholder('StringLiteral') ||
              super.parseImportSource()
            )
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index &&
              this.raise(I1.UnexpectedSpace, this.state.lastTokEndLoc)
          }
        },
      jv = (t) =>
        class extends t {
          parseV8Intrinsic() {
            if (this.match(54)) {
              let s = this.state.startLoc,
                i = this.startNode()
              if ((this.next(), Ve(this.state.type))) {
                let r = this.parseIdentifierName(),
                  n = this.createIdentifier(i, r)
                if (((n.type = 'V8IntrinsicIdentifier'), this.match(10)))
                  return n
              }
              this.unexpected(s)
            }
          }
          parseExprAtom(s) {
            return this.parseV8Intrinsic() || super.parseExprAtom(s)
          }
        }
    function yt(t, e) {
      let [s, i] = typeof e == 'string' ? [e, {}] : e,
        r = Object.keys(i),
        n = r.length === 0
      return t.some((a) => {
        if (typeof a == 'string') return n && a === s
        {
          let [o, u] = a
          if (o !== s) return !1
          for (let l of r) if (u[l] !== i[l]) return !1
          return !0
        }
      })
    }
    function jr(t, e, s) {
      let i = t.find((r) => (Array.isArray(r) ? r[0] === e : r === e))
      return i && Array.isArray(i) && i.length > 1 ? i[1][s] : null
    }
    var O1 = ['minimal', 'fsharp', 'hack', 'smart'],
      w1 = ['^^', '@@', '^', '%', '#']
    function qv(t) {
      if (yt(t, 'decorators')) {
        if (yt(t, 'decorators-legacy'))
          throw new Error(
            'Cannot use the decorators and decorators-legacy plugin together'
          )
        let e = jr(t, 'decorators', 'decoratorsBeforeExport')
        if (e != null && typeof e != 'boolean')
          throw new Error(
            "'decoratorsBeforeExport' must be a boolean, if specified."
          )
        let s = jr(t, 'decorators', 'allowCallParenthesized')
        if (s != null && typeof s != 'boolean')
          throw new Error("'allowCallParenthesized' must be a boolean.")
      }
      if (yt(t, 'flow') && yt(t, 'typescript'))
        throw new Error('Cannot combine flow and typescript plugins.')
      if (yt(t, 'placeholders') && yt(t, 'v8intrinsic'))
        throw new Error('Cannot combine placeholders and v8intrinsic plugins.')
      if (yt(t, 'pipelineOperator')) {
        let e = jr(t, 'pipelineOperator', 'proposal')
        if (!O1.includes(e)) {
          let r = O1.map((n) => `"${n}"`).join(', ')
          throw new Error(
            `"pipelineOperator" requires "proposal" option whose value must be one of: ${r}.`
          )
        }
        let s = ['recordAndTuple', { syntaxType: 'hash' }],
          i = yt(t, s)
        if (e === 'hack') {
          if (yt(t, 'placeholders'))
            throw new Error(
              'Cannot combine placeholders plugin and Hack-style pipes.'
            )
          if (yt(t, 'v8intrinsic'))
            throw new Error(
              'Cannot combine v8intrinsic plugin and Hack-style pipes.'
            )
          let r = jr(t, 'pipelineOperator', 'topicToken')
          if (!w1.includes(r)) {
            let n = w1.map((a) => `"${a}"`).join(', ')
            throw new Error(
              `"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${n}.`
            )
          }
          if (r === '#' && i)
            throw new Error(
              `Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(
                s
              )}\`.`
            )
        } else if (e === 'smart' && i)
          throw new Error(
            `Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(
              s
            )}\`.`
          )
      }
      if (yt(t, 'moduleAttributes')) {
        if (yt(t, 'importAssertions') || yt(t, 'importAttributes'))
          throw new Error(
            'Cannot combine importAssertions, importAttributes and moduleAttributes plugins.'
          )
        if (jr(t, 'moduleAttributes', 'version') !== 'may-2020')
          throw new Error(
            "The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'."
          )
      }
      if (yt(t, 'importAssertions') && yt(t, 'importAttributes'))
        throw new Error(
          'Cannot combine importAssertions and importAttributes plugins.'
        )
      if (yt(t, 'recordAndTuple')) {
        let e = jr(t, 'recordAndTuple', 'syntaxType')
        if (e != null) {
          let s = ['hash', 'bar']
          if (!s.includes(e))
            throw new Error(
              "The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " +
                s.map((i) => `'${i}'`).join(', ')
            )
        }
      }
      if (yt(t, 'asyncDoExpressions') && !yt(t, 'doExpressions')) {
        let e = new Error(
          "'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins."
        )
        throw ((e.missingPlugins = 'doExpressions'), e)
      }
      if (
        yt(t, 'optionalChainingAssign') &&
        jr(t, 'optionalChainingAssign', 'version') !== '2023-07'
      )
        throw new Error(
          "The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'."
        )
    }
    var M1 = {
        estree: KC,
        jsx: Mv,
        flow: Ov,
        typescript: Bv,
        v8intrinsic: jv,
        placeholders: $v,
      },
      Kv = Object.keys(M1),
      Mh = {
        sourceType: 'script',
        sourceFilename: void 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: !1,
        allowReturnOutsideFunction: !1,
        allowNewTargetOutsideFunction: !1,
        allowImportExportEverywhere: !1,
        allowSuperOutsideMethod: !1,
        allowUndeclaredExports: !1,
        plugins: [],
        strictMode: null,
        ranges: !1,
        tokens: !1,
        createImportExpressions: !1,
        createParenthesizedExpressions: !1,
        errorRecovery: !1,
        attachComment: !0,
        annexB: !0,
      }
    function Xv(t) {
      if (t == null) return Object.assign({}, Mh)
      if (t.annexB != null && t.annexB !== !1)
        throw new Error('The `annexB` option can only be set to `false`.')
      let e = {}
      for (let i of Object.keys(Mh)) {
        var s
        e[i] = (s = t[i]) != null ? s : Mh[i]
      }
      return e
    }
    var R1 = class extends A1 {
        checkProto(e, s, i, r) {
          if (
            e.type === 'SpreadElement' ||
            this.isObjectMethod(e) ||
            e.computed ||
            e.shorthand
          )
            return
          let n = e.key
          if ((n.type === 'Identifier' ? n.name : n.value) === '__proto__') {
            if (s) {
              this.raise(R.RecordNoProto, n)
              return
            }
            i.used &&
              (r
                ? r.doubleProtoLoc === null && (r.doubleProtoLoc = n.loc.start)
                : this.raise(R.DuplicateProto, n)),
              (i.used = !0)
          }
        }
        shouldExitDescending(e, s) {
          return e.type === 'ArrowFunctionExpression' && e.start === s
        }
        getExpression() {
          this.enterInitialScopes(), this.nextToken()
          let e = this.parseExpression()
          return (
            this.match(139) || this.unexpected(),
            this.finalizeRemainingComments(),
            (e.comments = this.comments),
            (e.errors = this.state.errors),
            this.options.tokens && (e.tokens = this.tokens),
            e
          )
        }
        parseExpression(e, s) {
          return e
            ? this.disallowInAnd(() => this.parseExpressionBase(s))
            : this.allowInAnd(() => this.parseExpressionBase(s))
        }
        parseExpressionBase(e) {
          let s = this.state.startLoc,
            i = this.parseMaybeAssign(e)
          if (this.match(12)) {
            let r = this.startNodeAt(s)
            for (r.expressions = [i]; this.eat(12); )
              r.expressions.push(this.parseMaybeAssign(e))
            return (
              this.toReferencedList(r.expressions),
              this.finishNode(r, 'SequenceExpression')
            )
          }
          return i
        }
        parseMaybeAssignDisallowIn(e, s) {
          return this.disallowInAnd(() => this.parseMaybeAssign(e, s))
        }
        parseMaybeAssignAllowIn(e, s) {
          return this.allowInAnd(() => this.parseMaybeAssign(e, s))
        }
        setOptionalParametersError(e, s) {
          var i
          e.optionalParametersLoc =
            (i = s == null ? void 0 : s.loc) != null ? i : this.state.startLoc
        }
        parseMaybeAssign(e, s) {
          let i = this.state.startLoc
          if (this.isContextual(108) && this.prodParam.hasYield) {
            let o = this.parseYield()
            return s && (o = s.call(this, o, i)), o
          }
          let r
          e ? (r = !1) : ((e = new $a()), (r = !0))
          let { type: n } = this.state
          ;(n === 10 || Ve(n)) &&
            (this.state.potentialArrowAt = this.state.start)
          let a = this.parseMaybeConditional(e)
          if ((s && (a = s.call(this, a, i)), JC(this.state.type))) {
            let o = this.startNodeAt(i),
              u = this.state.value
            if (((o.operator = u), this.match(29))) {
              this.toAssignable(a, !0), (o.left = a)
              let l = i.index
              e.doubleProtoLoc != null &&
                e.doubleProtoLoc.index >= l &&
                (e.doubleProtoLoc = null),
                e.shorthandAssignLoc != null &&
                  e.shorthandAssignLoc.index >= l &&
                  (e.shorthandAssignLoc = null),
                e.privateKeyLoc != null &&
                  e.privateKeyLoc.index >= l &&
                  (this.checkDestructuringPrivate(e), (e.privateKeyLoc = null))
            } else o.left = a
            return (
              this.next(),
              (o.right = this.parseMaybeAssign()),
              this.checkLVal(a, {
                in: this.finishNode(o, 'AssignmentExpression'),
              }),
              o
            )
          } else r && this.checkExpressionErrors(e, !0)
          return a
        }
        parseMaybeConditional(e) {
          let s = this.state.startLoc,
            i = this.state.potentialArrowAt,
            r = this.parseExprOps(e)
          return this.shouldExitDescending(r, i)
            ? r
            : this.parseConditional(r, s, e)
        }
        parseConditional(e, s, i) {
          if (this.eat(17)) {
            let r = this.startNodeAt(s)
            return (
              (r.test = e),
              (r.consequent = this.parseMaybeAssignAllowIn()),
              this.expect(14),
              (r.alternate = this.parseMaybeAssign()),
              this.finishNode(r, 'ConditionalExpression')
            )
          }
          return e
        }
        parseMaybeUnaryOrPrivate(e) {
          return this.match(138)
            ? this.parsePrivateName()
            : this.parseMaybeUnary(e)
        }
        parseExprOps(e) {
          let s = this.state.startLoc,
            i = this.state.potentialArrowAt,
            r = this.parseMaybeUnaryOrPrivate(e)
          return this.shouldExitDescending(r, i)
            ? r
            : this.parseExprOp(r, s, -1)
        }
        parseExprOp(e, s, i) {
          if (this.isPrivateName(e)) {
            let n = this.getPrivateNameSV(e)
            ;(i >= Lu(58) || !this.prodParam.hasIn || !this.match(58)) &&
              this.raise(R.PrivateInExpectedIn, e, { identifierName: n }),
              this.classScope.usePrivateName(n, e.loc.start)
          }
          let r = this.state.type
          if (QC(r) && (this.prodParam.hasIn || !this.match(58))) {
            let n = Lu(r)
            if (n > i) {
              if (r === 39) {
                if (
                  (this.expectPlugin('pipelineOperator'),
                  this.state.inFSharpPipelineDirectBody)
                )
                  return e
                this.checkPipelineAtInfixOperator(e, s)
              }
              let a = this.startNodeAt(s)
              ;(a.left = e), (a.operator = this.state.value)
              let o = r === 41 || r === 42,
                u = r === 40
              if (
                (u && (n = Lu(42)),
                this.next(),
                r === 39 &&
                  this.hasPlugin([
                    'pipelineOperator',
                    { proposal: 'minimal' },
                  ]) &&
                  this.state.type === 96 &&
                  this.prodParam.hasAwait)
              )
                throw this.raise(
                  R.UnexpectedAwaitAfterPipelineBody,
                  this.state.startLoc
                )
              a.right = this.parseExprOpRightExpr(r, n)
              let l = this.finishNode(
                  a,
                  o || u ? 'LogicalExpression' : 'BinaryExpression'
                ),
                c = this.state.type
              if ((u && (c === 41 || c === 42)) || (o && c === 40))
                throw this.raise(
                  R.MixingCoalesceWithLogical,
                  this.state.startLoc
                )
              return this.parseExprOp(l, s, i)
            }
          }
          return e
        }
        parseExprOpRightExpr(e, s) {
          let i = this.state.startLoc
          switch (e) {
            case 39:
              switch (this.getPluginOption('pipelineOperator', 'proposal')) {
                case 'hack':
                  return this.withTopicBindingContext(() =>
                    this.parseHackPipeBody()
                  )
                case 'smart':
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(108))
                      throw this.raise(R.PipeBodyIsTighter, this.state.startLoc)
                    return this.parseSmartPipelineBodyInStyle(
                      this.parseExprOpBaseRightExpr(e, s),
                      i
                    )
                  })
                case 'fsharp':
                  return this.withSoloAwaitPermittingContext(() =>
                    this.parseFSharpPipelineBody(s)
                  )
              }
            default:
              return this.parseExprOpBaseRightExpr(e, s)
          }
        }
        parseExprOpBaseRightExpr(e, s) {
          let i = this.state.startLoc
          return this.parseExprOp(
            this.parseMaybeUnaryOrPrivate(),
            i,
            iv(e) ? s - 1 : s
          )
        }
        parseHackPipeBody() {
          var e
          let { startLoc: s } = this.state,
            i = this.parseMaybeAssign()
          return (
            VC.has(i.type) &&
              !((e = i.extra) != null && e.parenthesized) &&
              this.raise(R.PipeUnparenthesizedBody, s, { type: i.type }),
            this.topicReferenceWasUsedInCurrentContext() ||
              this.raise(R.PipeTopicUnused, s),
            i
          )
        }
        checkExponentialAfterUnary(e) {
          this.match(57) &&
            this.raise(R.UnexpectedTokenUnaryExponentiation, e.argument)
        }
        parseMaybeUnary(e, s) {
          let i = this.state.startLoc,
            r = this.isContextual(96)
          if (r && this.isAwaitAllowed()) {
            this.next()
            let u = this.parseAwait(i)
            return s || this.checkExponentialAfterUnary(u), u
          }
          let n = this.match(34),
            a = this.startNode()
          if (ev(this.state.type)) {
            ;(a.operator = this.state.value),
              (a.prefix = !0),
              this.match(72) && this.expectPlugin('throwExpressions')
            let u = this.match(89)
            if (
              (this.next(),
              (a.argument = this.parseMaybeUnary(null, !0)),
              this.checkExpressionErrors(e, !0),
              this.state.strict && u)
            ) {
              let l = a.argument
              l.type === 'Identifier'
                ? this.raise(R.StrictDelete, a)
                : this.hasPropertyAsPrivateName(l) &&
                  this.raise(R.DeletePrivateField, a)
            }
            if (!n)
              return (
                s || this.checkExponentialAfterUnary(a),
                this.finishNode(a, 'UnaryExpression')
              )
          }
          let o = this.parseUpdate(a, n, e)
          if (r) {
            let { type: u } = this.state
            if (
              (this.hasPlugin('v8intrinsic')
                ? xh(u)
                : xh(u) && !this.match(54)) &&
              !this.isAmbiguousAwait()
            )
              return (
                this.raiseOverwrite(R.AwaitNotInAsyncContext, i),
                this.parseAwait(i)
              )
          }
          return o
        }
        parseUpdate(e, s, i) {
          if (s) {
            let a = e
            return (
              this.checkLVal(a.argument, {
                in: this.finishNode(a, 'UpdateExpression'),
              }),
              e
            )
          }
          let r = this.state.startLoc,
            n = this.parseExprSubscripts(i)
          if (this.checkExpressionErrors(i, !1)) return n
          for (; ZC(this.state.type) && !this.canInsertSemicolon(); ) {
            let a = this.startNodeAt(r)
            ;(a.operator = this.state.value),
              (a.prefix = !1),
              (a.argument = n),
              this.next(),
              this.checkLVal(n, {
                in: (n = this.finishNode(a, 'UpdateExpression')),
              })
          }
          return n
        }
        parseExprSubscripts(e) {
          let s = this.state.startLoc,
            i = this.state.potentialArrowAt,
            r = this.parseExprAtom(e)
          return this.shouldExitDescending(r, i)
            ? r
            : this.parseSubscripts(r, s)
        }
        parseSubscripts(e, s, i) {
          let r = {
            optionalChainMember: !1,
            maybeAsyncArrow: this.atPossibleAsyncArrow(e),
            stop: !1,
          }
          do (e = this.parseSubscript(e, s, i, r)), (r.maybeAsyncArrow = !1)
          while (!r.stop)
          return e
        }
        parseSubscript(e, s, i, r) {
          let { type: n } = this.state
          if (!i && n === 15) return this.parseBind(e, s, i, r)
          if (ku(n)) return this.parseTaggedTemplateExpression(e, s, r)
          let a = !1
          if (n === 18) {
            if (
              i &&
              (this.raise(R.OptionalChainingNoNew, this.state.startLoc),
              this.lookaheadCharCode() === 40)
            )
              return (r.stop = !0), e
            ;(r.optionalChainMember = a = !0), this.next()
          }
          if (!i && this.match(10))
            return this.parseCoverCallAndAsyncArrowHead(e, s, r, a)
          {
            let o = this.eat(0)
            return o || a || this.eat(16)
              ? this.parseMember(e, s, r, o, a)
              : ((r.stop = !0), e)
          }
        }
        parseMember(e, s, i, r, n) {
          let a = this.startNodeAt(s)
          return (
            (a.object = e),
            (a.computed = r),
            r
              ? ((a.property = this.parseExpression()), this.expect(3))
              : this.match(138)
              ? (e.type === 'Super' && this.raise(R.SuperPrivateField, s),
                this.classScope.usePrivateName(
                  this.state.value,
                  this.state.startLoc
                ),
                (a.property = this.parsePrivateName()))
              : (a.property = this.parseIdentifier(!0)),
            i.optionalChainMember
              ? ((a.optional = n),
                this.finishNode(a, 'OptionalMemberExpression'))
              : this.finishNode(a, 'MemberExpression')
          )
        }
        parseBind(e, s, i, r) {
          let n = this.startNodeAt(s)
          return (
            (n.object = e),
            this.next(),
            (n.callee = this.parseNoCallExpr()),
            (r.stop = !0),
            this.parseSubscripts(this.finishNode(n, 'BindExpression'), s, i)
          )
        }
        parseCoverCallAndAsyncArrowHead(e, s, i, r) {
          let n = this.state.maybeInArrowParameters,
            a = null
          ;(this.state.maybeInArrowParameters = !0), this.next()
          let o = this.startNodeAt(s)
          o.callee = e
          let { maybeAsyncArrow: u, optionalChainMember: l } = i
          u && (this.expressionScope.enter(_v()), (a = new $a())),
            l && (o.optional = r),
            r
              ? (o.arguments = this.parseCallExpressionArguments(11))
              : (o.arguments = this.parseCallExpressionArguments(
                  11,
                  e.type === 'Import',
                  e.type !== 'Super',
                  o,
                  a
                ))
          let c = this.finishCallExpression(o, l)
          return (
            u && this.shouldParseAsyncArrow() && !r
              ? ((i.stop = !0),
                this.checkDestructuringPrivate(a),
                this.expressionScope.validateAsPattern(),
                this.expressionScope.exit(),
                (c = this.parseAsyncArrowFromCallExpression(
                  this.startNodeAt(s),
                  c
                )))
              : (u &&
                  (this.checkExpressionErrors(a, !0),
                  this.expressionScope.exit()),
                this.toReferencedArguments(c)),
            (this.state.maybeInArrowParameters = n),
            c
          )
        }
        toReferencedArguments(e, s) {
          this.toReferencedListDeep(e.arguments, s)
        }
        parseTaggedTemplateExpression(e, s, i) {
          let r = this.startNodeAt(s)
          return (
            (r.tag = e),
            (r.quasi = this.parseTemplate(!0)),
            i.optionalChainMember &&
              this.raise(R.OptionalChainingNoTemplate, s),
            this.finishNode(r, 'TaggedTemplateExpression')
          )
        }
        atPossibleAsyncArrow(e) {
          return (
            e.type === 'Identifier' &&
            e.name === 'async' &&
            this.state.lastTokEndLoc.index === e.end &&
            !this.canInsertSemicolon() &&
            e.end - e.start == 5 &&
            e.start === this.state.potentialArrowAt
          )
        }
        expectImportAttributesPlugin() {
          this.hasPlugin('importAssertions') ||
            this.expectPlugin('importAttributes')
        }
        finishCallExpression(e, s) {
          if (e.callee.type === 'Import')
            if (
              (e.arguments.length === 2 &&
                (this.hasPlugin('moduleAttributes') ||
                  this.expectImportAttributesPlugin()),
              e.arguments.length === 0 || e.arguments.length > 2)
            )
              this.raise(R.ImportCallArity, e, {
                maxArgumentCount:
                  this.hasPlugin('importAttributes') ||
                  this.hasPlugin('importAssertions') ||
                  this.hasPlugin('moduleAttributes')
                    ? 2
                    : 1,
              })
            else
              for (let i of e.arguments)
                i.type === 'SpreadElement' &&
                  this.raise(R.ImportCallSpreadArgument, i)
          return this.finishNode(
            e,
            s ? 'OptionalCallExpression' : 'CallExpression'
          )
        }
        parseCallExpressionArguments(e, s, i, r, n) {
          let a = [],
            o = !0,
            u = this.state.inFSharpPipelineDirectBody
          for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
            if (o) o = !1
            else if ((this.expect(12), this.match(e))) {
              s &&
                !this.hasPlugin('importAttributes') &&
                !this.hasPlugin('importAssertions') &&
                !this.hasPlugin('moduleAttributes') &&
                this.raise(
                  R.ImportCallArgumentTrailingComma,
                  this.state.lastTokStartLoc
                ),
                r && this.addTrailingCommaExtraToNode(r),
                this.next()
              break
            }
            a.push(this.parseExprListItem(!1, n, i))
          }
          return (this.state.inFSharpPipelineDirectBody = u), a
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon()
        }
        parseAsyncArrowFromCallExpression(e, s) {
          var i
          return (
            this.resetPreviousNodeTrailingComments(s),
            this.expect(19),
            this.parseArrowExpression(
              e,
              s.arguments,
              !0,
              (i = s.extra) == null ? void 0 : i.trailingCommaLoc
            ),
            s.innerComments && Fa(e, s.innerComments),
            s.callee.trailingComments && Fa(e, s.callee.trailingComments),
            e
          )
        }
        parseNoCallExpr() {
          let e = this.state.startLoc
          return this.parseSubscripts(this.parseExprAtom(), e, !0)
        }
        parseExprAtom(e) {
          let s,
            i = null,
            { type: r } = this.state
          switch (r) {
            case 79:
              return this.parseSuper()
            case 83:
              return (
                (s = this.startNode()),
                this.next(),
                this.match(16)
                  ? this.parseImportMetaProperty(s)
                  : this.match(10)
                  ? this.options.createImportExpressions
                    ? this.parseImportCall(s)
                    : this.finishNode(s, 'Import')
                  : (this.raise(
                      R.UnsupportedImport,
                      this.state.lastTokStartLoc
                    ),
                    this.finishNode(s, 'Import'))
              )
            case 78:
              return (
                (s = this.startNode()),
                this.next(),
                this.finishNode(s, 'ThisExpression')
              )
            case 90:
              return this.parseDo(this.startNode(), !1)
            case 56:
            case 31:
              return (
                this.readRegexp(), this.parseRegExpLiteral(this.state.value)
              )
            case 134:
              return this.parseNumericLiteral(this.state.value)
            case 135:
              return this.parseBigIntLiteral(this.state.value)
            case 136:
              return this.parseDecimalLiteral(this.state.value)
            case 133:
              return this.parseStringLiteral(this.state.value)
            case 84:
              return this.parseNullLiteral()
            case 85:
              return this.parseBooleanLiteral(!0)
            case 86:
              return this.parseBooleanLiteral(!1)
            case 10: {
              let n = this.state.potentialArrowAt === this.state.start
              return this.parseParenAndDistinguishExpression(n)
            }
            case 2:
            case 1:
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0)
            case 0:
              return this.parseArrayLike(3, !0, !1, e)
            case 6:
            case 7:
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0)
            case 5:
              return this.parseObjectLike(8, !1, !1, e)
            case 68:
              return this.parseFunctionOrFunctionSent()
            case 26:
              i = this.parseDecorators()
            case 80:
              return this.parseClass(
                this.maybeTakeDecorators(i, this.startNode()),
                !1
              )
            case 77:
              return this.parseNewOrNewTarget()
            case 25:
            case 24:
              return this.parseTemplate(!1)
            case 15: {
              ;(s = this.startNode()), this.next(), (s.object = null)
              let n = (s.callee = this.parseNoCallExpr())
              if (n.type === 'MemberExpression')
                return this.finishNode(s, 'BindExpression')
              throw this.raise(R.UnsupportedBind, n)
            }
            case 138:
              return (
                this.raise(R.PrivateInExpectedIn, this.state.startLoc, {
                  identifierName: this.state.value,
                }),
                this.parsePrivateName()
              )
            case 33:
              return this.parseTopicReferenceThenEqualsSign(54, '%')
            case 32:
              return this.parseTopicReferenceThenEqualsSign(44, '^')
            case 37:
            case 38:
              return this.parseTopicReference('hack')
            case 44:
            case 54:
            case 27: {
              let n = this.getPluginOption('pipelineOperator', 'proposal')
              if (n) return this.parseTopicReference(n)
              this.unexpected()
              break
            }
            case 47: {
              let n = this.input.codePointAt(this.nextTokenStart())
              gi(n) || n === 62
                ? this.expectOnePlugin(['jsx', 'flow', 'typescript'])
                : this.unexpected()
              break
            }
            default:
              if (Ve(r)) {
                if (
                  this.isContextual(127) &&
                  this.lookaheadInLineCharCode() === 123
                )
                  return this.parseModuleExpression()
                let n = this.state.potentialArrowAt === this.state.start,
                  a = this.state.containsEsc,
                  o = this.parseIdentifier()
                if (!a && o.name === 'async' && !this.canInsertSemicolon()) {
                  let { type: u } = this.state
                  if (u === 68)
                    return (
                      this.resetPreviousNodeTrailingComments(o),
                      this.next(),
                      this.parseAsyncFunctionExpression(this.startNodeAtNode(o))
                    )
                  if (Ve(u))
                    return this.lookaheadCharCode() === 61
                      ? this.parseAsyncArrowUnaryFunction(
                          this.startNodeAtNode(o)
                        )
                      : o
                  if (u === 90)
                    return (
                      this.resetPreviousNodeTrailingComments(o),
                      this.parseDo(this.startNodeAtNode(o), !0)
                    )
                }
                return n && this.match(19) && !this.canInsertSemicolon()
                  ? (this.next(),
                    this.parseArrowExpression(this.startNodeAtNode(o), [o], !1))
                  : o
              } else this.unexpected()
          }
        }
        parseTopicReferenceThenEqualsSign(e, s) {
          let i = this.getPluginOption('pipelineOperator', 'proposal')
          if (i)
            return (
              (this.state.type = e),
              (this.state.value = s),
              this.state.pos--,
              this.state.end--,
              (this.state.endLoc = zt(this.state.endLoc, -1)),
              this.parseTopicReference(i)
            )
          this.unexpected()
        }
        parseTopicReference(e) {
          let s = this.startNode(),
            i = this.state.startLoc,
            r = this.state.type
          return this.next(), this.finishTopicReference(s, i, e, r)
        }
        finishTopicReference(e, s, i, r) {
          if (this.testTopicReferenceConfiguration(i, s, r)) {
            let n =
              i === 'smart' ? 'PipelinePrimaryTopicReference' : 'TopicReference'
            return (
              this.topicReferenceIsAllowedInCurrentContext() ||
                this.raise(
                  i === 'smart' ? R.PrimaryTopicNotAllowed : R.PipeTopicUnbound,
                  s
                ),
              this.registerTopicReference(),
              this.finishNode(e, n)
            )
          } else
            throw this.raise(R.PipeTopicUnconfiguredToken, s, { token: Zi(r) })
        }
        testTopicReferenceConfiguration(e, s, i) {
          switch (e) {
            case 'hack':
              return this.hasPlugin(['pipelineOperator', { topicToken: Zi(i) }])
            case 'smart':
              return i === 27
            default:
              throw this.raise(R.PipeTopicRequiresHackPipes, s)
          }
        }
        parseAsyncArrowUnaryFunction(e) {
          this.prodParam.enter($u(!0, this.prodParam.hasYield))
          let s = [this.parseIdentifier()]
          return (
            this.prodParam.exit(),
            this.hasPrecedingLineBreak() &&
              this.raise(R.LineTerminatorBeforeArrow, this.state.curPosition()),
            this.expect(19),
            this.parseArrowExpression(e, s, !0)
          )
        }
        parseDo(e, s) {
          this.expectPlugin('doExpressions'),
            s && this.expectPlugin('asyncDoExpressions'),
            (e.async = s),
            this.next()
          let i = this.state.labels
          return (
            (this.state.labels = []),
            s
              ? (this.prodParam.enter(2),
                (e.body = this.parseBlock()),
                this.prodParam.exit())
              : (e.body = this.parseBlock()),
            (this.state.labels = i),
            this.finishNode(e, 'DoExpression')
          )
        }
        parseSuper() {
          let e = this.startNode()
          return (
            this.next(),
            this.match(10) &&
            !this.scope.allowDirectSuper &&
            !this.options.allowSuperOutsideMethod
              ? this.raise(R.SuperNotAllowed, e)
              : !this.scope.allowSuper &&
                !this.options.allowSuperOutsideMethod &&
                this.raise(R.UnexpectedSuper, e),
            !this.match(10) &&
              !this.match(0) &&
              !this.match(16) &&
              this.raise(R.UnsupportedSuper, e),
            this.finishNode(e, 'Super')
          )
        }
        parsePrivateName() {
          let e = this.startNode(),
            s = this.startNodeAt(zt(this.state.startLoc, 1)),
            i = this.state.value
          return (
            this.next(),
            (e.id = this.createIdentifier(s, i)),
            this.finishNode(e, 'PrivateName')
          )
        }
        parseFunctionOrFunctionSent() {
          let e = this.startNode()
          if ((this.next(), this.prodParam.hasYield && this.match(16))) {
            let s = this.createIdentifier(this.startNodeAtNode(e), 'function')
            return (
              this.next(),
              this.match(103)
                ? this.expectPlugin('functionSent')
                : this.hasPlugin('functionSent') || this.unexpected(),
              this.parseMetaProperty(e, s, 'sent')
            )
          }
          return this.parseFunction(e)
        }
        parseMetaProperty(e, s, i) {
          e.meta = s
          let r = this.state.containsEsc
          return (
            (e.property = this.parseIdentifier(!0)),
            (e.property.name !== i || r) &&
              this.raise(R.UnsupportedMetaProperty, e.property, {
                target: s.name,
                onlyValidPropertyName: i,
              }),
            this.finishNode(e, 'MetaProperty')
          )
        }
        parseImportMetaProperty(e) {
          let s = this.createIdentifier(this.startNodeAtNode(e), 'import')
          if ((this.next(), this.isContextual(101)))
            this.inModule || this.raise(R.ImportMetaOutsideModule, s),
              (this.sawUnambiguousESM = !0)
          else if (this.isContextual(105) || this.isContextual(97)) {
            let i = this.isContextual(105)
            if (
              (i || this.unexpected(),
              this.expectPlugin(
                i ? 'sourcePhaseImports' : 'deferredImportEvaluation'
              ),
              !this.options.createImportExpressions)
            )
              throw this.raise(
                R.DynamicImportPhaseRequiresImportExpressions,
                this.state.startLoc,
                { phase: this.state.value }
              )
            return (
              this.next(),
              (e.phase = i ? 'source' : 'defer'),
              this.parseImportCall(e)
            )
          }
          return this.parseMetaProperty(e, s, 'meta')
        }
        parseLiteralAtNode(e, s, i) {
          return (
            this.addExtra(i, 'rawValue', e),
            this.addExtra(i, 'raw', this.input.slice(i.start, this.state.end)),
            (i.value = e),
            this.next(),
            this.finishNode(i, s)
          )
        }
        parseLiteral(e, s) {
          let i = this.startNode()
          return this.parseLiteralAtNode(e, s, i)
        }
        parseStringLiteral(e) {
          return this.parseLiteral(e, 'StringLiteral')
        }
        parseNumericLiteral(e) {
          return this.parseLiteral(e, 'NumericLiteral')
        }
        parseBigIntLiteral(e) {
          return this.parseLiteral(e, 'BigIntLiteral')
        }
        parseDecimalLiteral(e) {
          return this.parseLiteral(e, 'DecimalLiteral')
        }
        parseRegExpLiteral(e) {
          let s = this.startNode()
          return (
            this.addExtra(s, 'raw', this.input.slice(s.start, this.state.end)),
            (s.pattern = e.pattern),
            (s.flags = e.flags),
            this.next(),
            this.finishNode(s, 'RegExpLiteral')
          )
        }
        parseBooleanLiteral(e) {
          let s = this.startNode()
          return (
            (s.value = e), this.next(), this.finishNode(s, 'BooleanLiteral')
          )
        }
        parseNullLiteral() {
          let e = this.startNode()
          return this.next(), this.finishNode(e, 'NullLiteral')
        }
        parseParenAndDistinguishExpression(e) {
          let s = this.state.startLoc,
            i
          this.next(), this.expressionScope.enter(Tv())
          let r = this.state.maybeInArrowParameters,
            n = this.state.inFSharpPipelineDirectBody
          ;(this.state.maybeInArrowParameters = !0),
            (this.state.inFSharpPipelineDirectBody = !1)
          let a = this.state.startLoc,
            o = [],
            u = new $a(),
            l = !0,
            c,
            f
          for (; !this.match(11); ) {
            if (l) l = !1
            else if (
              (this.expect(
                12,
                u.optionalParametersLoc === null
                  ? null
                  : u.optionalParametersLoc
              ),
              this.match(11))
            ) {
              f = this.state.startLoc
              break
            }
            if (this.match(21)) {
              let m = this.state.startLoc
              if (
                ((c = this.state.startLoc),
                o.push(this.parseParenItem(this.parseRestBinding(), m)),
                !this.checkCommaAfterRest(41))
              )
                break
            } else o.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem))
          }
          let h = this.state.lastTokEndLoc
          this.expect(11),
            (this.state.maybeInArrowParameters = r),
            (this.state.inFSharpPipelineDirectBody = n)
          let p = this.startNodeAt(s)
          return e && this.shouldParseArrow(o) && (p = this.parseArrow(p))
            ? (this.checkDestructuringPrivate(u),
              this.expressionScope.validateAsPattern(),
              this.expressionScope.exit(),
              this.parseArrowExpression(p, o, !1),
              p)
            : (this.expressionScope.exit(),
              o.length || this.unexpected(this.state.lastTokStartLoc),
              f && this.unexpected(f),
              c && this.unexpected(c),
              this.checkExpressionErrors(u, !0),
              this.toReferencedListDeep(o, !0),
              o.length > 1
                ? ((i = this.startNodeAt(a)),
                  (i.expressions = o),
                  this.finishNode(i, 'SequenceExpression'),
                  this.resetEndLocation(i, h))
                : (i = o[0]),
              this.wrapParenthesis(s, i))
        }
        wrapParenthesis(e, s) {
          if (!this.options.createParenthesizedExpressions)
            return (
              this.addExtra(s, 'parenthesized', !0),
              this.addExtra(s, 'parenStart', e.index),
              this.takeSurroundingComments(
                s,
                e.index,
                this.state.lastTokEndLoc.index
              ),
              s
            )
          let i = this.startNodeAt(e)
          return (
            (i.expression = s), this.finishNode(i, 'ParenthesizedExpression')
          )
        }
        shouldParseArrow(e) {
          return !this.canInsertSemicolon()
        }
        parseArrow(e) {
          if (this.eat(19)) return e
        }
        parseParenItem(e, s) {
          return e
        }
        parseNewOrNewTarget() {
          let e = this.startNode()
          if ((this.next(), this.match(16))) {
            let s = this.createIdentifier(this.startNodeAtNode(e), 'new')
            this.next()
            let i = this.parseMetaProperty(e, s, 'target')
            return (
              !this.scope.inNonArrowFunction &&
                !this.scope.inClass &&
                !this.options.allowNewTargetOutsideFunction &&
                this.raise(R.UnexpectedNewTarget, i),
              i
            )
          }
          return this.parseNew(e)
        }
        parseNew(e) {
          if ((this.parseNewCallee(e), this.eat(10))) {
            let s = this.parseExprList(11)
            this.toReferencedList(s), (e.arguments = s)
          } else e.arguments = []
          return this.finishNode(e, 'NewExpression')
        }
        parseNewCallee(e) {
          let s = this.match(83),
            i = this.parseNoCallExpr()
          ;(e.callee = i),
            s &&
              (i.type === 'Import' || i.type === 'ImportExpression') &&
              this.raise(R.ImportCallNotNewExpression, i)
        }
        parseTemplateElement(e) {
          let { start: s, startLoc: i, end: r, value: n } = this.state,
            a = s + 1,
            o = this.startNodeAt(zt(i, 1))
          n === null &&
            (e ||
              this.raise(
                R.InvalidEscapeSequenceTemplate,
                zt(this.state.firstInvalidTemplateEscapePos, 1)
              ))
          let u = this.match(24),
            l = u ? -1 : -2,
            c = r + l
          ;(o.value = {
            raw: this.input.slice(a, c).replace(
              /\r\n?/g,
              `
`
            ),
            cooked: n === null ? null : n.slice(1, l),
          }),
            (o.tail = u),
            this.next()
          let f = this.finishNode(o, 'TemplateElement')
          return this.resetEndLocation(f, zt(this.state.lastTokEndLoc, l)), f
        }
        parseTemplate(e) {
          let s = this.startNode(),
            i = this.parseTemplateElement(e),
            r = [i],
            n = []
          for (; !i.tail; )
            n.push(this.parseTemplateSubstitution()),
              this.readTemplateContinuation(),
              r.push((i = this.parseTemplateElement(e)))
          return (
            (s.expressions = n),
            (s.quasis = r),
            this.finishNode(s, 'TemplateLiteral')
          )
        }
        parseTemplateSubstitution() {
          return this.parseExpression()
        }
        parseObjectLike(e, s, i, r) {
          i && this.expectPlugin('recordAndTuple')
          let n = this.state.inFSharpPipelineDirectBody
          this.state.inFSharpPipelineDirectBody = !1
          let a = Object.create(null),
            o = !0,
            u = this.startNode()
          for (u.properties = [], this.next(); !this.match(e); ) {
            if (o) o = !1
            else if ((this.expect(12), this.match(e))) {
              this.addTrailingCommaExtraToNode(u)
              break
            }
            let c
            s
              ? (c = this.parseBindingProperty())
              : ((c = this.parsePropertyDefinition(r)),
                this.checkProto(c, i, a, r)),
              i &&
                !this.isObjectProperty(c) &&
                c.type !== 'SpreadElement' &&
                this.raise(R.InvalidRecordProperty, c),
              c.shorthand && this.addExtra(c, 'shorthand', !0),
              u.properties.push(c)
          }
          this.next(), (this.state.inFSharpPipelineDirectBody = n)
          let l = 'ObjectExpression'
          return (
            s ? (l = 'ObjectPattern') : i && (l = 'RecordExpression'),
            this.finishNode(u, l)
          )
        }
        addTrailingCommaExtraToNode(e) {
          this.addExtra(e, 'trailingComma', this.state.lastTokStartLoc.index),
            this.addExtra(e, 'trailingCommaLoc', this.state.lastTokStartLoc, !1)
        }
        maybeAsyncOrAccessorProp(e) {
          return (
            !e.computed &&
            e.key.type === 'Identifier' &&
            (this.isLiteralPropertyName() || this.match(0) || this.match(55))
          )
        }
        parsePropertyDefinition(e) {
          let s = []
          if (this.match(26))
            for (
              this.hasPlugin('decorators') &&
              this.raise(R.UnsupportedPropertyDecorator, this.state.startLoc);
              this.match(26);

            )
              s.push(this.parseDecorator())
          let i = this.startNode(),
            r = !1,
            n = !1,
            a
          if (this.match(21))
            return s.length && this.unexpected(), this.parseSpread()
          s.length && ((i.decorators = s), (s = [])),
            (i.method = !1),
            e && (a = this.state.startLoc)
          let o = this.eat(55)
          this.parsePropertyNamePrefixOperator(i)
          let u = this.state.containsEsc
          if (
            (this.parsePropertyName(i, e),
            !o && !u && this.maybeAsyncOrAccessorProp(i))
          ) {
            let { key: l } = i,
              c = l.name
            c === 'async' &&
              !this.hasPrecedingLineBreak() &&
              ((r = !0),
              this.resetPreviousNodeTrailingComments(l),
              (o = this.eat(55)),
              this.parsePropertyName(i)),
              (c === 'get' || c === 'set') &&
                ((n = !0),
                this.resetPreviousNodeTrailingComments(l),
                (i.kind = c),
                this.match(55) &&
                  ((o = !0),
                  this.raise(R.AccessorIsGenerator, this.state.curPosition(), {
                    kind: c,
                  }),
                  this.next()),
                this.parsePropertyName(i))
          }
          return this.parseObjPropValue(i, a, o, r, !1, n, e)
        }
        getGetterSetterExpectedParamCount(e) {
          return e.kind === 'get' ? 0 : 1
        }
        getObjectOrClassMethodParams(e) {
          return e.params
        }
        checkGetterSetterParams(e) {
          var s
          let i = this.getGetterSetterExpectedParamCount(e),
            r = this.getObjectOrClassMethodParams(e)
          r.length !== i &&
            this.raise(
              e.kind === 'get' ? R.BadGetterArity : R.BadSetterArity,
              e
            ),
            e.kind === 'set' &&
              ((s = r[r.length - 1]) == null ? void 0 : s.type) ===
                'RestElement' &&
              this.raise(R.BadSetterRestParameter, e)
        }
        parseObjectMethod(e, s, i, r, n) {
          if (n) {
            let a = this.parseMethod(e, s, !1, !1, !1, 'ObjectMethod')
            return this.checkGetterSetterParams(a), a
          }
          if (i || s || this.match(10))
            return (
              r && this.unexpected(),
              (e.kind = 'method'),
              (e.method = !0),
              this.parseMethod(e, s, i, !1, !1, 'ObjectMethod')
            )
        }
        parseObjectProperty(e, s, i, r) {
          if (((e.shorthand = !1), this.eat(14)))
            return (
              (e.value = i
                ? this.parseMaybeDefault(this.state.startLoc)
                : this.parseMaybeAssignAllowIn(r)),
              this.finishNode(e, 'ObjectProperty')
            )
          if (!e.computed && e.key.type === 'Identifier') {
            if (
              (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), i)
            )
              e.value = this.parseMaybeDefault(s, bi(e.key))
            else if (this.match(29)) {
              let n = this.state.startLoc
              r != null
                ? r.shorthandAssignLoc === null && (r.shorthandAssignLoc = n)
                : this.raise(R.InvalidCoverInitializedName, n),
                (e.value = this.parseMaybeDefault(s, bi(e.key)))
            } else e.value = bi(e.key)
            return (e.shorthand = !0), this.finishNode(e, 'ObjectProperty')
          }
        }
        parseObjPropValue(e, s, i, r, n, a, o) {
          let u =
            this.parseObjectMethod(e, i, r, n, a) ||
            this.parseObjectProperty(e, s, n, o)
          return u || this.unexpected(), u
        }
        parsePropertyName(e, s) {
          if (this.eat(0))
            (e.computed = !0),
              (e.key = this.parseMaybeAssignAllowIn()),
              this.expect(3)
          else {
            let { type: i, value: r } = this.state,
              n
            if (Hs(i)) n = this.parseIdentifier(!0)
            else
              switch (i) {
                case 134:
                  n = this.parseNumericLiteral(r)
                  break
                case 133:
                  n = this.parseStringLiteral(r)
                  break
                case 135:
                  n = this.parseBigIntLiteral(r)
                  break
                case 136:
                  n = this.parseDecimalLiteral(r)
                  break
                case 138: {
                  let a = this.state.startLoc
                  s != null
                    ? s.privateKeyLoc === null && (s.privateKeyLoc = a)
                    : this.raise(R.UnexpectedPrivateField, a),
                    (n = this.parsePrivateName())
                  break
                }
                default:
                  this.unexpected()
              }
            ;(e.key = n), i !== 138 && (e.computed = !1)
          }
        }
        initFunction(e, s) {
          ;(e.id = null), (e.generator = !1), (e.async = s)
        }
        parseMethod(e, s, i, r, n, a, o = !1) {
          this.initFunction(e, i),
            (e.generator = s),
            this.scope.enter(2 | 16 | (o ? 64 : 0) | (n ? 32 : 0)),
            this.prodParam.enter($u(i, e.generator)),
            this.parseFunctionParams(e, r)
          let u = this.parseFunctionBodyAndFinish(e, a, !0)
          return this.prodParam.exit(), this.scope.exit(), u
        }
        parseArrayLike(e, s, i, r) {
          i && this.expectPlugin('recordAndTuple')
          let n = this.state.inFSharpPipelineDirectBody
          this.state.inFSharpPipelineDirectBody = !1
          let a = this.startNode()
          return (
            this.next(),
            (a.elements = this.parseExprList(e, !i, r, a)),
            (this.state.inFSharpPipelineDirectBody = n),
            this.finishNode(a, i ? 'TupleExpression' : 'ArrayExpression')
          )
        }
        parseArrowExpression(e, s, i, r) {
          this.scope.enter(2 | 4)
          let n = $u(i, !1)
          !this.match(5) && this.prodParam.hasIn && (n |= 8),
            this.prodParam.enter(n),
            this.initFunction(e, i)
          let a = this.state.maybeInArrowParameters
          return (
            s &&
              ((this.state.maybeInArrowParameters = !0),
              this.setArrowFunctionParameters(e, s, r)),
            (this.state.maybeInArrowParameters = !1),
            this.parseFunctionBody(e, !0),
            this.prodParam.exit(),
            this.scope.exit(),
            (this.state.maybeInArrowParameters = a),
            this.finishNode(e, 'ArrowFunctionExpression')
          )
        }
        setArrowFunctionParameters(e, s, i) {
          this.toAssignableList(s, i, !1), (e.params = s)
        }
        parseFunctionBodyAndFinish(e, s, i = !1) {
          return this.parseFunctionBody(e, !1, i), this.finishNode(e, s)
        }
        parseFunctionBody(e, s, i = !1) {
          let r = s && !this.match(5)
          if ((this.expressionScope.enter(g1()), r))
            (e.body = this.parseMaybeAssign()), this.checkParams(e, !1, s, !1)
          else {
            let n = this.state.strict,
              a = this.state.labels
            ;(this.state.labels = []),
              this.prodParam.enter(this.prodParam.currentFlags() | 4),
              (e.body = this.parseBlock(!0, !1, (o) => {
                let u = !this.isSimpleParamList(e.params)
                o &&
                  u &&
                  this.raise(
                    R.IllegalLanguageModeDirective,
                    (e.kind === 'method' || e.kind === 'constructor') && !!e.key
                      ? e.key.loc.end
                      : e
                  )
                let l = !n && this.state.strict
                this.checkParams(e, !this.state.strict && !s && !i && !u, s, l),
                  this.state.strict && e.id && this.checkIdentifier(e.id, 65, l)
              })),
              this.prodParam.exit(),
              (this.state.labels = a)
          }
          this.expressionScope.exit()
        }
        isSimpleParameter(e) {
          return e.type === 'Identifier'
        }
        isSimpleParamList(e) {
          for (let s = 0, i = e.length; s < i; s++)
            if (!this.isSimpleParameter(e[s])) return !1
          return !0
        }
        checkParams(e, s, i, r = !0) {
          let n = !s && new Set(),
            a = { type: 'FormalParameters' }
          for (let o of e.params)
            this.checkLVal(o, {
              in: a,
              binding: 5,
              checkClashes: n,
              strictModeChanged: r,
            })
        }
        parseExprList(e, s, i, r) {
          let n = [],
            a = !0
          for (; !this.eat(e); ) {
            if (a) a = !1
            else if ((this.expect(12), this.match(e))) {
              r && this.addTrailingCommaExtraToNode(r), this.next()
              break
            }
            n.push(this.parseExprListItem(s, i))
          }
          return n
        }
        parseExprListItem(e, s, i) {
          let r
          if (this.match(12))
            e ||
              this.raise(R.UnexpectedToken, this.state.curPosition(), {
                unexpected: ',',
              }),
              (r = null)
          else if (this.match(21)) {
            let n = this.state.startLoc
            r = this.parseParenItem(this.parseSpread(s), n)
          } else if (this.match(17)) {
            this.expectPlugin('partialApplication'),
              i ||
                this.raise(R.UnexpectedArgumentPlaceholder, this.state.startLoc)
            let n = this.startNode()
            this.next(), (r = this.finishNode(n, 'ArgumentPlaceholder'))
          } else r = this.parseMaybeAssignAllowIn(s, this.parseParenItem)
          return r
        }
        parseIdentifier(e) {
          let s = this.startNode(),
            i = this.parseIdentifierName(e)
          return this.createIdentifier(s, i)
        }
        createIdentifier(e, s) {
          return (
            (e.name = s),
            (e.loc.identifierName = s),
            this.finishNode(e, 'Identifier')
          )
        }
        parseIdentifierName(e) {
          let s,
            { startLoc: i, type: r } = this.state
          Hs(r) ? (s = this.state.value) : this.unexpected()
          let n = WC(r)
          return (
            e
              ? n && this.replaceToken(132)
              : this.checkReservedWord(s, i, n, !1),
            this.next(),
            s
          )
        }
        checkReservedWord(e, s, i, r) {
          if (e.length > 10 || !pv(e)) return
          if (i && cv(e)) {
            this.raise(R.UnexpectedKeyword, s, { keyword: e })
            return
          }
          if ((this.state.strict ? (r ? e1 : Qg) : Yg)(e, this.inModule)) {
            this.raise(R.UnexpectedReservedWord, s, { reservedWord: e })
            return
          } else if (e === 'yield') {
            if (this.prodParam.hasYield) {
              this.raise(R.YieldBindingIdentifier, s)
              return
            }
          } else if (e === 'await') {
            if (this.prodParam.hasAwait) {
              this.raise(R.AwaitBindingIdentifier, s)
              return
            }
            if (this.scope.inStaticBlock) {
              this.raise(R.AwaitBindingIdentifierInStaticBlock, s)
              return
            }
            this.expressionScope.recordAsyncArrowParametersError(s)
          } else if (
            e === 'arguments' &&
            this.scope.inClassAndNotInNonArrowFunction
          ) {
            this.raise(R.ArgumentsInClass, s)
            return
          }
        }
        isAwaitAllowed() {
          return !!(
            this.prodParam.hasAwait ||
            (this.options.allowAwaitOutsideFunction && !this.scope.inFunction)
          )
        }
        parseAwait(e) {
          let s = this.startNodeAt(e)
          return (
            this.expressionScope.recordParameterInitializerError(
              R.AwaitExpressionFormalParameter,
              s
            ),
            this.eat(55) && this.raise(R.ObsoleteAwaitStar, s),
            !this.scope.inFunction &&
              !this.options.allowAwaitOutsideFunction &&
              (this.isAmbiguousAwait()
                ? (this.ambiguousScriptDifferentAst = !0)
                : (this.sawUnambiguousESM = !0)),
            this.state.soloAwait ||
              (s.argument = this.parseMaybeUnary(null, !0)),
            this.finishNode(s, 'AwaitExpression')
          )
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak()) return !0
          let { type: e } = this.state
          return (
            e === 53 ||
            e === 10 ||
            e === 0 ||
            ku(e) ||
            (e === 102 && !this.state.containsEsc) ||
            e === 137 ||
            e === 56 ||
            (this.hasPlugin('v8intrinsic') && e === 54)
          )
        }
        parseYield() {
          let e = this.startNode()
          this.expressionScope.recordParameterInitializerError(
            R.YieldInParameter,
            e
          ),
            this.next()
          let s = !1,
            i = null
          if (!this.hasPrecedingLineBreak())
            switch (((s = this.eat(55)), this.state.type)) {
              case 13:
              case 139:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!s) break
              default:
                i = this.parseMaybeAssign()
            }
          return (
            (e.delegate = s),
            (e.argument = i),
            this.finishNode(e, 'YieldExpression')
          )
        }
        parseImportCall(e) {
          return (
            this.next(),
            (e.source = this.parseMaybeAssignAllowIn()),
            (this.hasPlugin('importAttributes') ||
              this.hasPlugin('importAssertions')) &&
              (e.options = null),
            this.eat(12) &&
              (this.expectImportAttributesPlugin(),
              this.match(11) ||
                ((e.options = this.parseMaybeAssignAllowIn()), this.eat(12))),
            this.expect(11),
            this.finishNode(e, 'ImportExpression')
          )
        }
        checkPipelineAtInfixOperator(e, s) {
          this.hasPlugin(['pipelineOperator', { proposal: 'smart' }]) &&
            e.type === 'SequenceExpression' &&
            this.raise(R.PipelineHeadSequenceExpression, s)
        }
        parseSmartPipelineBodyInStyle(e, s) {
          if (this.isSimpleReference(e)) {
            let i = this.startNodeAt(s)
            return (i.callee = e), this.finishNode(i, 'PipelineBareFunction')
          } else {
            let i = this.startNodeAt(s)
            return (
              this.checkSmartPipeTopicBodyEarlyErrors(s),
              (i.expression = e),
              this.finishNode(i, 'PipelineTopicExpression')
            )
          }
        }
        isSimpleReference(e) {
          switch (e.type) {
            case 'MemberExpression':
              return !e.computed && this.isSimpleReference(e.object)
            case 'Identifier':
              return !0
            default:
              return !1
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(e) {
          if (this.match(19))
            throw this.raise(R.PipelineBodyNoArrow, this.state.startLoc)
          this.topicReferenceWasUsedInCurrentContext() ||
            this.raise(R.PipelineTopicUnused, e)
        }
        withTopicBindingContext(e) {
          let s = this.state.topicContext
          this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null,
          }
          try {
            return e()
          } finally {
            this.state.topicContext = s
          }
        }
        withSmartMixTopicForbiddingContext(e) {
          if (this.hasPlugin(['pipelineOperator', { proposal: 'smart' }])) {
            let s = this.state.topicContext
            this.state.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null,
            }
            try {
              return e()
            } finally {
              this.state.topicContext = s
            }
          } else return e()
        }
        withSoloAwaitPermittingContext(e) {
          let s = this.state.soloAwait
          this.state.soloAwait = !0
          try {
            return e()
          } finally {
            this.state.soloAwait = s
          }
        }
        allowInAnd(e) {
          let s = this.prodParam.currentFlags()
          if (8 & ~s) {
            this.prodParam.enter(s | 8)
            try {
              return e()
            } finally {
              this.prodParam.exit()
            }
          }
          return e()
        }
        disallowInAnd(e) {
          let s = this.prodParam.currentFlags()
          if (8 & s) {
            this.prodParam.enter(s & ~8)
            try {
              return e()
            } finally {
              this.prodParam.exit()
            }
          }
          return e()
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1
        }
        topicReferenceWasUsedInCurrentContext() {
          return (
            this.state.topicContext.maxTopicIndex != null &&
            this.state.topicContext.maxTopicIndex >= 0
          )
        }
        parseFSharpPipelineBody(e) {
          let s = this.state.startLoc
          this.state.potentialArrowAt = this.state.start
          let i = this.state.inFSharpPipelineDirectBody
          this.state.inFSharpPipelineDirectBody = !0
          let r = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, e)
          return (this.state.inFSharpPipelineDirectBody = i), r
        }
        parseModuleExpression() {
          this.expectPlugin('moduleBlocks')
          let e = this.startNode()
          this.next(), this.match(5) || this.unexpected(null, 5)
          let s = this.startNodeAt(this.state.endLoc)
          this.next()
          let i = this.initializeScopes(!0)
          this.enterInitialScopes()
          try {
            e.body = this.parseProgram(s, 8, 'module')
          } finally {
            i()
          }
          return this.finishNode(e, 'ModuleExpression')
        }
        parsePropertyNamePrefixOperator(e) {}
      },
      Rh = { kind: 1 },
      Gv = { kind: 2 },
      Wv = /[\uD800-\uDFFF]/u,
      Lh = /in(?:stanceof)?/y
    function zv(t, e) {
      for (let s = 0; s < t.length; s++) {
        let i = t[s],
          { type: r } = i
        if (typeof r == 'number') {
          {
            if (r === 138) {
              let { loc: n, start: a, value: o, end: u } = i,
                l = a + 1,
                c = zt(n.start, 1)
              t.splice(
                s,
                1,
                new yi({
                  type: mi(27),
                  value: '#',
                  start: a,
                  end: l,
                  startLoc: n.start,
                  endLoc: c,
                }),
                new yi({
                  type: mi(132),
                  value: o,
                  start: l,
                  end: u,
                  startLoc: c,
                  endLoc: n.end,
                })
              ),
                s++
              continue
            }
            if (ku(r)) {
              let { loc: n, start: a, value: o, end: u } = i,
                l = a + 1,
                c = zt(n.start, 1),
                f
              e.charCodeAt(a) === 96
                ? (f = new yi({
                    type: mi(22),
                    value: '`',
                    start: a,
                    end: l,
                    startLoc: n.start,
                    endLoc: c,
                  }))
                : (f = new yi({
                    type: mi(8),
                    value: '}',
                    start: a,
                    end: l,
                    startLoc: n.start,
                    endLoc: c,
                  }))
              let h, p, m, y
              r === 24
                ? ((p = u - 1),
                  (m = zt(n.end, -1)),
                  (h = o === null ? null : o.slice(1, -1)),
                  (y = new yi({
                    type: mi(22),
                    value: '`',
                    start: p,
                    end: u,
                    startLoc: m,
                    endLoc: n.end,
                  })))
                : ((p = u - 2),
                  (m = zt(n.end, -2)),
                  (h = o === null ? null : o.slice(1, -2)),
                  (y = new yi({
                    type: mi(23),
                    value: '${',
                    start: p,
                    end: u,
                    startLoc: m,
                    endLoc: n.end,
                  }))),
                t.splice(
                  s,
                  1,
                  f,
                  new yi({
                    type: mi(20),
                    value: h,
                    start: l,
                    end: p,
                    startLoc: c,
                    endLoc: m,
                  }),
                  y
                ),
                (s += 2)
              continue
            }
          }
          i.type = mi(r)
        }
      }
      return t
    }
    var L1 = class extends R1 {
        parseTopLevel(e, s) {
          return (
            (e.program = this.parseProgram(s)),
            (e.comments = this.comments),
            this.options.tokens && (e.tokens = zv(this.tokens, this.input)),
            this.finishNode(e, 'File')
          )
        }
        parseProgram(e, s = 139, i = this.options.sourceType) {
          if (
            ((e.sourceType = i),
            (e.interpreter = this.parseInterpreterDirective()),
            this.parseBlockBody(e, !0, !0, s),
            this.inModule &&
              !this.options.allowUndeclaredExports &&
              this.scope.undefinedExports.size > 0)
          )
            for (let [n, a] of Array.from(this.scope.undefinedExports))
              this.raise(R.ModuleExportUndefined, a, { localName: n })
          let r
          return (
            s === 139
              ? (r = this.finishNode(e, 'Program'))
              : (r = this.finishNodeAt(
                  e,
                  'Program',
                  zt(this.state.startLoc, -1)
                )),
            r
          )
        }
        stmtToDirective(e) {
          let s = e
          ;(s.type = 'Directive'), (s.value = s.expression), delete s.expression
          let i = s.value,
            r = i.value,
            n = this.input.slice(i.start, i.end),
            a = (i.value = n.slice(1, -1))
          return (
            this.addExtra(i, 'raw', n),
            this.addExtra(i, 'rawValue', a),
            this.addExtra(i, 'expressionValue', r),
            (i.type = 'DirectiveLiteral'),
            s
          )
        }
        parseInterpreterDirective() {
          if (!this.match(28)) return null
          let e = this.startNode()
          return (
            (e.value = this.state.value),
            this.next(),
            this.finishNode(e, 'InterpreterDirective')
          )
        }
        isLet() {
          return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1
        }
        chStartsBindingIdentifier(e, s) {
          if (gi(e)) {
            if (((Lh.lastIndex = s), Lh.test(this.input))) {
              let i = this.codePointAtPos(Lh.lastIndex)
              if (!Fn(i) && i !== 92) return !1
            }
            return !0
          } else return e === 92
        }
        chStartsBindingPattern(e) {
          return e === 91 || e === 123
        }
        hasFollowingBindingAtom() {
          let e = this.nextTokenStart(),
            s = this.codePointAtPos(e)
          return (
            this.chStartsBindingPattern(s) ||
            this.chStartsBindingIdentifier(s, e)
          )
        }
        hasInLineFollowingBindingIdentifierOrBrace() {
          let e = this.nextTokenInLineStart(),
            s = this.codePointAtPos(e)
          return s === 123 || this.chStartsBindingIdentifier(s, e)
        }
        startsUsingForOf() {
          let { type: e, containsEsc: s } = this.lookahead()
          if (e === 102 && !s) return !1
          if (Ve(e) && !this.hasFollowingLineBreak())
            return this.expectPlugin('explicitResourceManagement'), !0
        }
        startsAwaitUsing() {
          let e = this.nextTokenInLineStart()
          if (this.isUnparsedContextual(e, 'using')) {
            e = this.nextTokenInLineStartSince(e + 5)
            let s = this.codePointAtPos(e)
            if (this.chStartsBindingIdentifier(s, e))
              return this.expectPlugin('explicitResourceManagement'), !0
          }
          return !1
        }
        parseModuleItem() {
          return this.parseStatementLike(1 | 2 | 4 | 8)
        }
        parseStatementListItem() {
          return this.parseStatementLike(
            2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8)
          )
        }
        parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
          let s = 0
          return (
            this.options.annexB &&
              !this.state.strict &&
              ((s |= 4), e && (s |= 8)),
            this.parseStatementLike(s)
          )
        }
        parseStatement() {
          return this.parseStatementLike(0)
        }
        parseStatementLike(e) {
          let s = null
          return (
            this.match(26) && (s = this.parseDecorators(!0)),
            this.parseStatementContent(e, s)
          )
        }
        parseStatementContent(e, s) {
          let i = this.state.type,
            r = this.startNode(),
            n = !!(e & 2),
            a = !!(e & 4),
            o = e & 1
          switch (i) {
            case 60:
              return this.parseBreakContinueStatement(r, !0)
            case 63:
              return this.parseBreakContinueStatement(r, !1)
            case 64:
              return this.parseDebuggerStatement(r)
            case 90:
              return this.parseDoWhileStatement(r)
            case 91:
              return this.parseForStatement(r)
            case 68:
              if (this.lookaheadCharCode() === 46) break
              return (
                a ||
                  this.raise(
                    this.state.strict
                      ? R.StrictFunction
                      : this.options.annexB
                      ? R.SloppyFunctionAnnexB
                      : R.SloppyFunction,
                    this.state.startLoc
                  ),
                this.parseFunctionStatement(r, !1, !n && a)
              )
            case 80:
              return (
                n || this.unexpected(),
                this.parseClass(this.maybeTakeDecorators(s, r), !0)
              )
            case 69:
              return this.parseIfStatement(r)
            case 70:
              return this.parseReturnStatement(r)
            case 71:
              return this.parseSwitchStatement(r)
            case 72:
              return this.parseThrowStatement(r)
            case 73:
              return this.parseTryStatement(r)
            case 96:
              if (!this.state.containsEsc && this.startsAwaitUsing())
                return (
                  this.isAwaitAllowed()
                    ? n || this.raise(R.UnexpectedLexicalDeclaration, r)
                    : this.raise(R.AwaitUsingNotInAsyncContext, r),
                  this.next(),
                  this.parseVarStatement(r, 'await using')
                )
              break
            case 107:
              if (
                this.state.containsEsc ||
                !this.hasInLineFollowingBindingIdentifierOrBrace()
              )
                break
              return (
                this.expectPlugin('explicitResourceManagement'),
                !this.scope.inModule && this.scope.inTopLevel
                  ? this.raise(
                      R.UnexpectedUsingDeclaration,
                      this.state.startLoc
                    )
                  : n ||
                    this.raise(
                      R.UnexpectedLexicalDeclaration,
                      this.state.startLoc
                    ),
                this.parseVarStatement(r, 'using')
              )
            case 100: {
              if (this.state.containsEsc) break
              let c = this.nextTokenStart(),
                f = this.codePointAtPos(c)
              if (
                f !== 91 &&
                ((!n && this.hasFollowingLineBreak()) ||
                  (!this.chStartsBindingIdentifier(f, c) && f !== 123))
              )
                break
            }
            case 75:
              n ||
                this.raise(R.UnexpectedLexicalDeclaration, this.state.startLoc)
            case 74: {
              let c = this.state.value
              return this.parseVarStatement(r, c)
            }
            case 92:
              return this.parseWhileStatement(r)
            case 76:
              return this.parseWithStatement(r)
            case 5:
              return this.parseBlock()
            case 13:
              return this.parseEmptyStatement(r)
            case 83: {
              let c = this.lookaheadCharCode()
              if (c === 40 || c === 46) break
            }
            case 82: {
              !this.options.allowImportExportEverywhere &&
                !o &&
                this.raise(R.UnexpectedImportExport, this.state.startLoc),
                this.next()
              let c
              return (
                i === 83
                  ? ((c = this.parseImport(r)),
                    c.type === 'ImportDeclaration' &&
                      (!c.importKind || c.importKind === 'value') &&
                      (this.sawUnambiguousESM = !0))
                  : ((c = this.parseExport(r, s)),
                    ((c.type === 'ExportNamedDeclaration' &&
                      (!c.exportKind || c.exportKind === 'value')) ||
                      (c.type === 'ExportAllDeclaration' &&
                        (!c.exportKind || c.exportKind === 'value')) ||
                      c.type === 'ExportDefaultDeclaration') &&
                      (this.sawUnambiguousESM = !0)),
                this.assertModuleNodeAllowed(c),
                c
              )
            }
            default:
              if (this.isAsyncFunction())
                return (
                  n ||
                    this.raise(
                      R.AsyncFunctionInSingleStatementContext,
                      this.state.startLoc
                    ),
                  this.next(),
                  this.parseFunctionStatement(r, !0, !n && a)
                )
          }
          let u = this.state.value,
            l = this.parseExpression()
          return Ve(i) && l.type === 'Identifier' && this.eat(14)
            ? this.parseLabeledStatement(r, u, l, e)
            : this.parseExpressionStatement(r, l, s)
        }
        assertModuleNodeAllowed(e) {
          !this.options.allowImportExportEverywhere &&
            !this.inModule &&
            this.raise(R.ImportOutsideModule, e)
        }
        decoratorsEnabledBeforeExport() {
          return this.hasPlugin('decorators-legacy')
            ? !0
            : this.hasPlugin('decorators') &&
                this.getPluginOption('decorators', 'decoratorsBeforeExport') !==
                  !1
        }
        maybeTakeDecorators(e, s, i) {
          return (
            e &&
              (s.decorators && s.decorators.length > 0
                ? (typeof this.getPluginOption(
                    'decorators',
                    'decoratorsBeforeExport'
                  ) != 'boolean' &&
                    this.raise(R.DecoratorsBeforeAfterExport, s.decorators[0]),
                  s.decorators.unshift(...e))
                : (s.decorators = e),
              this.resetStartLocationFromNode(s, e[0]),
              i && this.resetStartLocationFromNode(i, s)),
            s
          )
        }
        canHaveLeadingDecorator() {
          return this.match(80)
        }
        parseDecorators(e) {
          let s = []
          do s.push(this.parseDecorator())
          while (this.match(26))
          if (this.match(82))
            e || this.unexpected(),
              this.decoratorsEnabledBeforeExport() ||
                this.raise(R.DecoratorExportClass, this.state.startLoc)
          else if (!this.canHaveLeadingDecorator())
            throw this.raise(R.UnexpectedLeadingDecorator, this.state.startLoc)
          return s
        }
        parseDecorator() {
          this.expectOnePlugin(['decorators', 'decorators-legacy'])
          let e = this.startNode()
          if ((this.next(), this.hasPlugin('decorators'))) {
            let s = this.state.startLoc,
              i
            if (this.match(10)) {
              let r = this.state.startLoc
              this.next(),
                (i = this.parseExpression()),
                this.expect(11),
                (i = this.wrapParenthesis(r, i))
              let n = this.state.startLoc
              ;(e.expression = this.parseMaybeDecoratorArguments(i)),
                this.getPluginOption('decorators', 'allowCallParenthesized') ===
                  !1 &&
                  e.expression !== i &&
                  this.raise(R.DecoratorArgumentsOutsideParentheses, n)
            } else {
              for (i = this.parseIdentifier(!1); this.eat(16); ) {
                let r = this.startNodeAt(s)
                ;(r.object = i),
                  this.match(138)
                    ? (this.classScope.usePrivateName(
                        this.state.value,
                        this.state.startLoc
                      ),
                      (r.property = this.parsePrivateName()))
                    : (r.property = this.parseIdentifier(!0)),
                  (r.computed = !1),
                  (i = this.finishNode(r, 'MemberExpression'))
              }
              e.expression = this.parseMaybeDecoratorArguments(i)
            }
          } else e.expression = this.parseExprSubscripts()
          return this.finishNode(e, 'Decorator')
        }
        parseMaybeDecoratorArguments(e) {
          if (this.eat(10)) {
            let s = this.startNodeAtNode(e)
            return (
              (s.callee = e),
              (s.arguments = this.parseCallExpressionArguments(11, !1)),
              this.toReferencedList(s.arguments),
              this.finishNode(s, 'CallExpression')
            )
          }
          return e
        }
        parseBreakContinueStatement(e, s) {
          return (
            this.next(),
            this.isLineTerminator()
              ? (e.label = null)
              : ((e.label = this.parseIdentifier()), this.semicolon()),
            this.verifyBreakContinue(e, s),
            this.finishNode(e, s ? 'BreakStatement' : 'ContinueStatement')
          )
        }
        verifyBreakContinue(e, s) {
          let i
          for (i = 0; i < this.state.labels.length; ++i) {
            let r = this.state.labels[i]
            if (
              (e.label == null || r.name === e.label.name) &&
              ((r.kind != null && (s || r.kind === 1)) || (e.label && s))
            )
              break
          }
          if (i === this.state.labels.length) {
            let r = s ? 'BreakStatement' : 'ContinueStatement'
            this.raise(R.IllegalBreakContinue, e, { type: r })
          }
        }
        parseDebuggerStatement(e) {
          return (
            this.next(),
            this.semicolon(),
            this.finishNode(e, 'DebuggerStatement')
          )
        }
        parseHeaderExpression() {
          this.expect(10)
          let e = this.parseExpression()
          return this.expect(11), e
        }
        parseDoWhileStatement(e) {
          return (
            this.next(),
            this.state.labels.push(Rh),
            (e.body = this.withSmartMixTopicForbiddingContext(() =>
              this.parseStatement()
            )),
            this.state.labels.pop(),
            this.expect(92),
            (e.test = this.parseHeaderExpression()),
            this.eat(13),
            this.finishNode(e, 'DoWhileStatement')
          )
        }
        parseForStatement(e) {
          this.next(), this.state.labels.push(Rh)
          let s = null
          if (
            (this.isAwaitAllowed() &&
              this.eatContextual(96) &&
              (s = this.state.lastTokStartLoc),
            this.scope.enter(0),
            this.expect(10),
            this.match(13))
          )
            return s !== null && this.unexpected(s), this.parseFor(e, null)
          let i = this.isContextual(100)
          {
            let u = this.isContextual(96) && this.startsAwaitUsing(),
              l = u || (this.isContextual(107) && this.startsUsingForOf()),
              c = (i && this.hasFollowingBindingAtom()) || l
            if (this.match(74) || this.match(75) || c) {
              let f = this.startNode(),
                h
              u
                ? ((h = 'await using'),
                  this.isAwaitAllowed() ||
                    this.raise(
                      R.AwaitUsingNotInAsyncContext,
                      this.state.startLoc
                    ),
                  this.next())
                : (h = this.state.value),
                this.next(),
                this.parseVar(f, !0, h)
              let p = this.finishNode(f, 'VariableDeclaration'),
                m = this.match(58)
              return (
                m && l && this.raise(R.ForInUsing, p),
                (m || this.isContextual(102)) && p.declarations.length === 1
                  ? this.parseForIn(e, p, s)
                  : (s !== null && this.unexpected(s), this.parseFor(e, p))
              )
            }
          }
          let r = this.isContextual(95),
            n = new $a(),
            a = this.parseExpression(!0, n),
            o = this.isContextual(102)
          if (
            (o &&
              (i && this.raise(R.ForOfLet, a),
              s === null &&
                r &&
                a.type === 'Identifier' &&
                this.raise(R.ForOfAsync, a)),
            o || this.match(58))
          ) {
            this.checkDestructuringPrivate(n), this.toAssignable(a, !0)
            let u = o ? 'ForOfStatement' : 'ForInStatement'
            return (
              this.checkLVal(a, { in: { type: u } }), this.parseForIn(e, a, s)
            )
          } else this.checkExpressionErrors(n, !0)
          return s !== null && this.unexpected(s), this.parseFor(e, a)
        }
        parseFunctionStatement(e, s, i) {
          return (
            this.next(), this.parseFunction(e, 1 | (i ? 2 : 0) | (s ? 8 : 0))
          )
        }
        parseIfStatement(e) {
          return (
            this.next(),
            (e.test = this.parseHeaderExpression()),
            (e.consequent =
              this.parseStatementOrSloppyAnnexBFunctionDeclaration()),
            (e.alternate = this.eat(66)
              ? this.parseStatementOrSloppyAnnexBFunctionDeclaration()
              : null),
            this.finishNode(e, 'IfStatement')
          )
        }
        parseReturnStatement(e) {
          return (
            !this.prodParam.hasReturn &&
              !this.options.allowReturnOutsideFunction &&
              this.raise(R.IllegalReturn, this.state.startLoc),
            this.next(),
            this.isLineTerminator()
              ? (e.argument = null)
              : ((e.argument = this.parseExpression()), this.semicolon()),
            this.finishNode(e, 'ReturnStatement')
          )
        }
        parseSwitchStatement(e) {
          this.next(), (e.discriminant = this.parseHeaderExpression())
          let s = (e.cases = [])
          this.expect(5), this.state.labels.push(Gv), this.scope.enter(0)
          let i
          for (let r; !this.match(8); )
            if (this.match(61) || this.match(65)) {
              let n = this.match(61)
              i && this.finishNode(i, 'SwitchCase'),
                s.push((i = this.startNode())),
                (i.consequent = []),
                this.next(),
                n
                  ? (i.test = this.parseExpression())
                  : (r &&
                      this.raise(
                        R.MultipleDefaultsInSwitch,
                        this.state.lastTokStartLoc
                      ),
                    (r = !0),
                    (i.test = null)),
                this.expect(14)
            } else
              i
                ? i.consequent.push(this.parseStatementListItem())
                : this.unexpected()
          return (
            this.scope.exit(),
            i && this.finishNode(i, 'SwitchCase'),
            this.next(),
            this.state.labels.pop(),
            this.finishNode(e, 'SwitchStatement')
          )
        }
        parseThrowStatement(e) {
          return (
            this.next(),
            this.hasPrecedingLineBreak() &&
              this.raise(R.NewlineAfterThrow, this.state.lastTokEndLoc),
            (e.argument = this.parseExpression()),
            this.semicolon(),
            this.finishNode(e, 'ThrowStatement')
          )
        }
        parseCatchClauseParam() {
          let e = this.parseBindingAtom()
          return (
            this.scope.enter(
              this.options.annexB && e.type === 'Identifier' ? 8 : 0
            ),
            this.checkLVal(e, { in: { type: 'CatchClause' }, binding: 9 }),
            e
          )
        }
        parseTryStatement(e) {
          if (
            (this.next(),
            (e.block = this.parseBlock()),
            (e.handler = null),
            this.match(62))
          ) {
            let s = this.startNode()
            this.next(),
              this.match(10)
                ? (this.expect(10),
                  (s.param = this.parseCatchClauseParam()),
                  this.expect(11))
                : ((s.param = null), this.scope.enter(0)),
              (s.body = this.withSmartMixTopicForbiddingContext(() =>
                this.parseBlock(!1, !1)
              )),
              this.scope.exit(),
              (e.handler = this.finishNode(s, 'CatchClause'))
          }
          return (
            (e.finalizer = this.eat(67) ? this.parseBlock() : null),
            !e.handler && !e.finalizer && this.raise(R.NoCatchOrFinally, e),
            this.finishNode(e, 'TryStatement')
          )
        }
        parseVarStatement(e, s, i = !1) {
          return (
            this.next(),
            this.parseVar(e, !1, s, i),
            this.semicolon(),
            this.finishNode(e, 'VariableDeclaration')
          )
        }
        parseWhileStatement(e) {
          return (
            this.next(),
            (e.test = this.parseHeaderExpression()),
            this.state.labels.push(Rh),
            (e.body = this.withSmartMixTopicForbiddingContext(() =>
              this.parseStatement()
            )),
            this.state.labels.pop(),
            this.finishNode(e, 'WhileStatement')
          )
        }
        parseWithStatement(e) {
          return (
            this.state.strict && this.raise(R.StrictWith, this.state.startLoc),
            this.next(),
            (e.object = this.parseHeaderExpression()),
            (e.body = this.withSmartMixTopicForbiddingContext(() =>
              this.parseStatement()
            )),
            this.finishNode(e, 'WithStatement')
          )
        }
        parseEmptyStatement(e) {
          return this.next(), this.finishNode(e, 'EmptyStatement')
        }
        parseLabeledStatement(e, s, i, r) {
          for (let a of this.state.labels)
            a.name === s &&
              this.raise(R.LabelRedeclaration, i, { labelName: s })
          let n = YC(this.state.type) ? 1 : this.match(71) ? 2 : null
          for (let a = this.state.labels.length - 1; a >= 0; a--) {
            let o = this.state.labels[a]
            if (o.statementStart === e.start)
              (o.statementStart = this.state.start), (o.kind = n)
            else break
          }
          return (
            this.state.labels.push({
              name: s,
              kind: n,
              statementStart: this.state.start,
            }),
            (e.body =
              r & 8
                ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0)
                : this.parseStatement()),
            this.state.labels.pop(),
            (e.label = i),
            this.finishNode(e, 'LabeledStatement')
          )
        }
        parseExpressionStatement(e, s, i) {
          return (
            (e.expression = s),
            this.semicolon(),
            this.finishNode(e, 'ExpressionStatement')
          )
        }
        parseBlock(e = !1, s = !0, i) {
          let r = this.startNode()
          return (
            e && this.state.strictErrors.clear(),
            this.expect(5),
            s && this.scope.enter(0),
            this.parseBlockBody(r, e, !1, 8, i),
            s && this.scope.exit(),
            this.finishNode(r, 'BlockStatement')
          )
        }
        isValidDirective(e) {
          return (
            e.type === 'ExpressionStatement' &&
            e.expression.type === 'StringLiteral' &&
            !e.expression.extra.parenthesized
          )
        }
        parseBlockBody(e, s, i, r, n) {
          let a = (e.body = []),
            o = (e.directives = [])
          this.parseBlockOrModuleBlockBody(a, s ? o : void 0, i, r, n)
        }
        parseBlockOrModuleBlockBody(e, s, i, r, n) {
          let a = this.state.strict,
            o = !1,
            u = !1
          for (; !this.match(r); ) {
            let l = i ? this.parseModuleItem() : this.parseStatementListItem()
            if (s && !u) {
              if (this.isValidDirective(l)) {
                let c = this.stmtToDirective(l)
                s.push(c),
                  !o &&
                    c.value.value === 'use strict' &&
                    ((o = !0), this.setStrict(!0))
                continue
              }
              ;(u = !0), this.state.strictErrors.clear()
            }
            e.push(l)
          }
          n == null || n.call(this, o), a || this.setStrict(!1), this.next()
        }
        parseFor(e, s) {
          return (
            (e.init = s),
            this.semicolon(!1),
            (e.test = this.match(13) ? null : this.parseExpression()),
            this.semicolon(!1),
            (e.update = this.match(11) ? null : this.parseExpression()),
            this.expect(11),
            (e.body = this.withSmartMixTopicForbiddingContext(() =>
              this.parseStatement()
            )),
            this.scope.exit(),
            this.state.labels.pop(),
            this.finishNode(e, 'ForStatement')
          )
        }
        parseForIn(e, s, i) {
          let r = this.match(58)
          return (
            this.next(),
            r ? i !== null && this.unexpected(i) : (e.await = i !== null),
            s.type === 'VariableDeclaration' &&
              s.declarations[0].init != null &&
              (!r ||
                !this.options.annexB ||
                this.state.strict ||
                s.kind !== 'var' ||
                s.declarations[0].id.type !== 'Identifier') &&
              this.raise(R.ForInOfLoopInitializer, s, {
                type: r ? 'ForInStatement' : 'ForOfStatement',
              }),
            s.type === 'AssignmentPattern' &&
              this.raise(R.InvalidLhs, s, {
                ancestor: { type: 'ForStatement' },
              }),
            (e.left = s),
            (e.right = r
              ? this.parseExpression()
              : this.parseMaybeAssignAllowIn()),
            this.expect(11),
            (e.body = this.withSmartMixTopicForbiddingContext(() =>
              this.parseStatement()
            )),
            this.scope.exit(),
            this.state.labels.pop(),
            this.finishNode(e, r ? 'ForInStatement' : 'ForOfStatement')
          )
        }
        parseVar(e, s, i, r = !1) {
          let n = (e.declarations = [])
          for (e.kind = i; ; ) {
            let a = this.startNode()
            if (
              (this.parseVarId(a, i),
              (a.init = this.eat(29)
                ? s
                  ? this.parseMaybeAssignDisallowIn()
                  : this.parseMaybeAssignAllowIn()
                : null),
              a.init === null &&
                !r &&
                (a.id.type !== 'Identifier' &&
                !(s && (this.match(58) || this.isContextual(102)))
                  ? this.raise(
                      R.DeclarationMissingInitializer,
                      this.state.lastTokEndLoc,
                      { kind: 'destructuring' }
                    )
                  : (i === 'const' || i === 'using' || i === 'await using') &&
                    !(this.match(58) || this.isContextual(102)) &&
                    this.raise(
                      R.DeclarationMissingInitializer,
                      this.state.lastTokEndLoc,
                      { kind: i }
                    )),
              n.push(this.finishNode(a, 'VariableDeclarator')),
              !this.eat(12))
            )
              break
          }
          return e
        }
        parseVarId(e, s) {
          let i = this.parseBindingAtom()
          ;(s === 'using' || s === 'await using') &&
            (i.type === 'ArrayPattern' || i.type === 'ObjectPattern') &&
            this.raise(R.UsingDeclarationHasBindingPattern, i.loc.start),
            this.checkLVal(i, {
              in: { type: 'VariableDeclarator' },
              binding: s === 'var' ? 5 : 8201,
            }),
            (e.id = i)
        }
        parseAsyncFunctionExpression(e) {
          return this.parseFunction(e, 8)
        }
        parseFunction(e, s = 0) {
          let i = s & 2,
            r = !!(s & 1),
            n = r && !(s & 4),
            a = !!(s & 8)
          this.initFunction(e, a),
            this.match(55) &&
              (i &&
                this.raise(
                  R.GeneratorInSingleStatementContext,
                  this.state.startLoc
                ),
              this.next(),
              (e.generator = !0)),
            r && (e.id = this.parseFunctionId(n))
          let o = this.state.maybeInArrowParameters
          return (
            (this.state.maybeInArrowParameters = !1),
            this.scope.enter(2),
            this.prodParam.enter($u(a, e.generator)),
            r || (e.id = this.parseFunctionId()),
            this.parseFunctionParams(e, !1),
            this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(
                e,
                r ? 'FunctionDeclaration' : 'FunctionExpression'
              )
            }),
            this.prodParam.exit(),
            this.scope.exit(),
            r && !i && this.registerFunctionStatementId(e),
            (this.state.maybeInArrowParameters = o),
            e
          )
        }
        parseFunctionId(e) {
          return e || Ve(this.state.type) ? this.parseIdentifier() : null
        }
        parseFunctionParams(e, s) {
          this.expect(10),
            this.expressionScope.enter(Sv()),
            (e.params = this.parseBindingList(11, 41, 2 | (s ? 4 : 0))),
            this.expressionScope.exit()
        }
        registerFunctionStatementId(e) {
          !e.id ||
            this.scope.declareName(
              e.id.name,
              !this.options.annexB ||
                this.state.strict ||
                e.generator ||
                e.async
                ? this.scope.treatFunctionsAsVar
                  ? 5
                  : 8201
                : 17,
              e.id.loc.start
            )
        }
        parseClass(e, s, i) {
          this.next()
          let r = this.state.strict
          return (
            (this.state.strict = !0),
            this.parseClassId(e, s, i),
            this.parseClassSuper(e),
            (e.body = this.parseClassBody(!!e.superClass, r)),
            this.finishNode(e, s ? 'ClassDeclaration' : 'ClassExpression')
          )
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8)
        }
        isClassMethod() {
          return this.match(10)
        }
        nameIsConstructor(e) {
          return (
            (e.type === 'Identifier' && e.name === 'constructor') ||
            (e.type === 'StringLiteral' && e.value === 'constructor')
          )
        }
        isNonstaticConstructor(e) {
          return !e.computed && !e.static && this.nameIsConstructor(e.key)
        }
        parseClassBody(e, s) {
          this.classScope.enter()
          let i = { hadConstructor: !1, hadSuperClass: e },
            r = [],
            n = this.startNode()
          if (
            ((n.body = []),
            this.expect(5),
            this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (r.length > 0)
                    throw this.raise(
                      R.DecoratorSemicolon,
                      this.state.lastTokEndLoc
                    )
                  continue
                }
                if (this.match(26)) {
                  r.push(this.parseDecorator())
                  continue
                }
                let a = this.startNode()
                r.length &&
                  ((a.decorators = r),
                  this.resetStartLocationFromNode(a, r[0]),
                  (r = [])),
                  this.parseClassMember(n, a, i),
                  a.kind === 'constructor' &&
                    a.decorators &&
                    a.decorators.length > 0 &&
                    this.raise(R.DecoratorConstructor, a)
              }
            }),
            (this.state.strict = s),
            this.next(),
            r.length)
          )
            throw this.raise(R.TrailingDecorator, this.state.startLoc)
          return this.classScope.exit(), this.finishNode(n, 'ClassBody')
        }
        parseClassMemberFromModifier(e, s) {
          let i = this.parseIdentifier(!0)
          if (this.isClassMethod()) {
            let r = s
            return (
              (r.kind = 'method'),
              (r.computed = !1),
              (r.key = i),
              (r.static = !1),
              this.pushClassMethod(e, r, !1, !1, !1, !1),
              !0
            )
          } else if (this.isClassProperty()) {
            let r = s
            return (
              (r.computed = !1),
              (r.key = i),
              (r.static = !1),
              e.body.push(this.parseClassProperty(r)),
              !0
            )
          }
          return this.resetPreviousNodeTrailingComments(i), !1
        }
        parseClassMember(e, s, i) {
          let r = this.isContextual(106)
          if (r) {
            if (this.parseClassMemberFromModifier(e, s)) return
            if (this.eat(5)) {
              this.parseClassStaticBlock(e, s)
              return
            }
          }
          this.parseClassMemberWithIsStatic(e, s, i, r)
        }
        parseClassMemberWithIsStatic(e, s, i, r) {
          let n = s,
            a = s,
            o = s,
            u = s,
            l = s,
            c = n,
            f = n
          if (
            ((s.static = r),
            this.parsePropertyNamePrefixOperator(s),
            this.eat(55))
          ) {
            c.kind = 'method'
            let C = this.match(138)
            if ((this.parseClassElementName(c), C)) {
              this.pushClassPrivateMethod(e, a, !0, !1)
              return
            }
            this.isNonstaticConstructor(n) &&
              this.raise(R.ConstructorIsGenerator, n.key),
              this.pushClassMethod(e, n, !0, !1, !1, !1)
            return
          }
          let h = !this.state.containsEsc && Ve(this.state.type),
            p = this.parseClassElementName(s),
            m = h ? p.name : null,
            y = this.isPrivateName(p),
            x = this.state.startLoc
          if ((this.parsePostMemberNameModifiers(f), this.isClassMethod())) {
            if (((c.kind = 'method'), y)) {
              this.pushClassPrivateMethod(e, a, !1, !1)
              return
            }
            let C = this.isNonstaticConstructor(n),
              E = !1
            C &&
              ((n.kind = 'constructor'),
              i.hadConstructor &&
                !this.hasPlugin('typescript') &&
                this.raise(R.DuplicateConstructor, p),
              C &&
                this.hasPlugin('typescript') &&
                s.override &&
                this.raise(R.OverrideOnConstructor, p),
              (i.hadConstructor = !0),
              (E = i.hadSuperClass)),
              this.pushClassMethod(e, n, !1, !1, C, E)
          } else if (this.isClassProperty())
            y
              ? this.pushClassPrivateProperty(e, u)
              : this.pushClassProperty(e, o)
          else if (m === 'async' && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(p)
            let C = this.eat(55)
            f.optional && this.unexpected(x), (c.kind = 'method')
            let E = this.match(138)
            this.parseClassElementName(c),
              this.parsePostMemberNameModifiers(f),
              E
                ? this.pushClassPrivateMethod(e, a, C, !0)
                : (this.isNonstaticConstructor(n) &&
                    this.raise(R.ConstructorIsAsync, n.key),
                  this.pushClassMethod(e, n, C, !0, !1, !1))
          } else if (
            (m === 'get' || m === 'set') &&
            !(this.match(55) && this.isLineTerminator())
          ) {
            this.resetPreviousNodeTrailingComments(p), (c.kind = m)
            let C = this.match(138)
            this.parseClassElementName(n),
              C
                ? this.pushClassPrivateMethod(e, a, !1, !1)
                : (this.isNonstaticConstructor(n) &&
                    this.raise(R.ConstructorIsAccessor, n.key),
                  this.pushClassMethod(e, n, !1, !1, !1, !1)),
              this.checkGetterSetterParams(n)
          } else if (m === 'accessor' && !this.isLineTerminator()) {
            this.expectPlugin('decoratorAutoAccessors'),
              this.resetPreviousNodeTrailingComments(p)
            let C = this.match(138)
            this.parseClassElementName(o),
              this.pushClassAccessorProperty(e, l, C)
          } else
            this.isLineTerminator()
              ? y
                ? this.pushClassPrivateProperty(e, u)
                : this.pushClassProperty(e, o)
              : this.unexpected()
        }
        parseClassElementName(e) {
          let { type: s, value: i } = this.state
          if (
            ((s === 132 || s === 133) &&
              e.static &&
              i === 'prototype' &&
              this.raise(R.StaticPrototype, this.state.startLoc),
            s === 138)
          ) {
            i === 'constructor' &&
              this.raise(R.ConstructorClassPrivateField, this.state.startLoc)
            let r = this.parsePrivateName()
            return (e.key = r), r
          }
          return this.parsePropertyName(e), e.key
        }
        parseClassStaticBlock(e, s) {
          var i
          this.scope.enter(64 | 128 | 16)
          let r = this.state.labels
          ;(this.state.labels = []), this.prodParam.enter(0)
          let n = (s.body = [])
          this.parseBlockOrModuleBlockBody(n, void 0, !1, 8),
            this.prodParam.exit(),
            this.scope.exit(),
            (this.state.labels = r),
            e.body.push(this.finishNode(s, 'StaticBlock')),
            (i = s.decorators) != null &&
              i.length &&
              this.raise(R.DecoratorStaticBlock, s)
        }
        pushClassProperty(e, s) {
          !s.computed &&
            this.nameIsConstructor(s.key) &&
            this.raise(R.ConstructorClassField, s.key),
            e.body.push(this.parseClassProperty(s))
        }
        pushClassPrivateProperty(e, s) {
          let i = this.parseClassPrivateProperty(s)
          e.body.push(i),
            this.classScope.declarePrivateName(
              this.getPrivateNameSV(i.key),
              0,
              i.key.loc.start
            )
        }
        pushClassAccessorProperty(e, s, i) {
          !i &&
            !s.computed &&
            this.nameIsConstructor(s.key) &&
            this.raise(R.ConstructorClassField, s.key)
          let r = this.parseClassAccessorProperty(s)
          e.body.push(r),
            i &&
              this.classScope.declarePrivateName(
                this.getPrivateNameSV(r.key),
                0,
                r.key.loc.start
              )
        }
        pushClassMethod(e, s, i, r, n, a) {
          e.body.push(this.parseMethod(s, i, r, n, a, 'ClassMethod', !0))
        }
        pushClassPrivateMethod(e, s, i, r) {
          let n = this.parseMethod(s, i, r, !1, !1, 'ClassPrivateMethod', !0)
          e.body.push(n)
          let a =
            n.kind === 'get'
              ? n.static
                ? 6
                : 2
              : n.kind === 'set'
              ? n.static
                ? 5
                : 1
              : 0
          this.declareClassPrivateMethodInScope(n, a)
        }
        declareClassPrivateMethodInScope(e, s) {
          this.classScope.declarePrivateName(
            this.getPrivateNameSV(e.key),
            s,
            e.key.loc.start
          )
        }
        parsePostMemberNameModifiers(e) {}
        parseClassPrivateProperty(e) {
          return (
            this.parseInitializer(e),
            this.semicolon(),
            this.finishNode(e, 'ClassPrivateProperty')
          )
        }
        parseClassProperty(e) {
          return (
            this.parseInitializer(e),
            this.semicolon(),
            this.finishNode(e, 'ClassProperty')
          )
        }
        parseClassAccessorProperty(e) {
          return (
            this.parseInitializer(e),
            this.semicolon(),
            this.finishNode(e, 'ClassAccessorProperty')
          )
        }
        parseInitializer(e) {
          this.scope.enter(64 | 16),
            this.expressionScope.enter(g1()),
            this.prodParam.enter(0),
            (e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null),
            this.expressionScope.exit(),
            this.prodParam.exit(),
            this.scope.exit()
        }
        parseClassId(e, s, i, r = 8331) {
          if (Ve(this.state.type))
            (e.id = this.parseIdentifier()),
              s && this.declareNameFromIdentifier(e.id, r)
          else if (i || !s) e.id = null
          else throw this.raise(R.MissingClassName, this.state.startLoc)
        }
        parseClassSuper(e) {
          e.superClass = this.eat(81) ? this.parseExprSubscripts() : null
        }
        parseExport(e, s) {
          let i = this.parseMaybeImportPhase(e, !0),
            r = this.maybeParseExportDefaultSpecifier(e, i),
            n = !r || this.eat(12),
            a = n && this.eatExportStar(e),
            o = a && this.maybeParseExportNamespaceSpecifier(e),
            u = n && (!o || this.eat(12)),
            l = r || a
          if (a && !o) {
            if ((r && this.unexpected(), s))
              throw this.raise(R.UnsupportedDecoratorExport, e)
            return (
              this.parseExportFrom(e, !0),
              this.finishNode(e, 'ExportAllDeclaration')
            )
          }
          let c = this.maybeParseExportNamedSpecifiers(e)
          r && n && !a && !c && this.unexpected(null, 5),
            o && u && this.unexpected(null, 98)
          let f
          if (l || c) {
            if (((f = !1), s)) throw this.raise(R.UnsupportedDecoratorExport, e)
            this.parseExportFrom(e, l)
          } else f = this.maybeParseExportDeclaration(e)
          if (l || c || f) {
            var h
            let p = e
            if (
              (this.checkExport(p, !0, !1, !!p.source),
              ((h = p.declaration) == null ? void 0 : h.type) ===
                'ClassDeclaration')
            )
              this.maybeTakeDecorators(s, p.declaration, p)
            else if (s) throw this.raise(R.UnsupportedDecoratorExport, e)
            return this.finishNode(p, 'ExportNamedDeclaration')
          }
          if (this.eat(65)) {
            let p = e,
              m = this.parseExportDefaultExpression()
            if (((p.declaration = m), m.type === 'ClassDeclaration'))
              this.maybeTakeDecorators(s, m, p)
            else if (s) throw this.raise(R.UnsupportedDecoratorExport, e)
            return (
              this.checkExport(p, !0, !0),
              this.finishNode(p, 'ExportDefaultDeclaration')
            )
          }
          this.unexpected(null, 5)
        }
        eatExportStar(e) {
          return this.eat(55)
        }
        maybeParseExportDefaultSpecifier(e, s) {
          if (s || this.isExportDefaultSpecifier()) {
            this.expectPlugin(
              'exportDefaultFrom',
              s == null ? void 0 : s.loc.start
            )
            let i = s || this.parseIdentifier(!0),
              r = this.startNodeAtNode(i)
            return (
              (r.exported = i),
              (e.specifiers = [this.finishNode(r, 'ExportDefaultSpecifier')]),
              !0
            )
          }
          return !1
        }
        maybeParseExportNamespaceSpecifier(e) {
          if (this.isContextual(93)) {
            var s, i
            ;(i = (s = e).specifiers) != null || (s.specifiers = [])
            let r = this.startNodeAt(this.state.lastTokStartLoc)
            return (
              this.next(),
              (r.exported = this.parseModuleExportName()),
              e.specifiers.push(this.finishNode(r, 'ExportNamespaceSpecifier')),
              !0
            )
          }
          return !1
        }
        maybeParseExportNamedSpecifiers(e) {
          if (this.match(5)) {
            let s = e
            s.specifiers || (s.specifiers = [])
            let i = s.exportKind === 'type'
            return (
              s.specifiers.push(...this.parseExportSpecifiers(i)),
              (s.source = null),
              (s.declaration = null),
              this.hasPlugin('importAssertions') && (s.assertions = []),
              !0
            )
          }
          return !1
        }
        maybeParseExportDeclaration(e) {
          return this.shouldParseExportDeclaration()
            ? ((e.specifiers = []),
              (e.source = null),
              this.hasPlugin('importAssertions') && (e.assertions = []),
              (e.declaration = this.parseExportDeclaration(e)),
              !0)
            : !1
        }
        isAsyncFunction() {
          if (!this.isContextual(95)) return !1
          let e = this.nextTokenInLineStart()
          return this.isUnparsedContextual(e, 'function')
        }
        parseExportDefaultExpression() {
          let e = this.startNode()
          if (this.match(68)) return this.next(), this.parseFunction(e, 1 | 4)
          if (this.isAsyncFunction())
            return this.next(), this.next(), this.parseFunction(e, 1 | 4 | 8)
          if (this.match(80)) return this.parseClass(e, !0, !0)
          if (this.match(26))
            return (
              this.hasPlugin('decorators') &&
                this.getPluginOption('decorators', 'decoratorsBeforeExport') ===
                  !0 &&
                this.raise(R.DecoratorBeforeExport, this.state.startLoc),
              this.parseClass(
                this.maybeTakeDecorators(
                  this.parseDecorators(!1),
                  this.startNode()
                ),
                !0,
                !0
              )
            )
          if (this.match(75) || this.match(74) || this.isLet())
            throw this.raise(R.UnsupportedDefaultExport, this.state.startLoc)
          let s = this.parseMaybeAssignAllowIn()
          return this.semicolon(), s
        }
        parseExportDeclaration(e) {
          return this.match(80)
            ? this.parseClass(this.startNode(), !0, !1)
            : this.parseStatementListItem()
        }
        isExportDefaultSpecifier() {
          let { type: e } = this.state
          if (Ve(e)) {
            if ((e === 95 && !this.state.containsEsc) || e === 100) return !1
            if ((e === 130 || e === 129) && !this.state.containsEsc) {
              let { type: r } = this.lookahead()
              if ((Ve(r) && r !== 98) || r === 5)
                return this.expectOnePlugin(['flow', 'typescript']), !1
            }
          } else if (!this.match(65)) return !1
          let s = this.nextTokenStart(),
            i = this.isUnparsedContextual(s, 'from')
          if (this.input.charCodeAt(s) === 44 || (Ve(this.state.type) && i))
            return !0
          if (this.match(65) && i) {
            let r = this.input.charCodeAt(this.nextTokenStartSince(s + 4))
            return r === 34 || r === 39
          }
          return !1
        }
        parseExportFrom(e, s) {
          this.eatContextual(98)
            ? ((e.source = this.parseImportSource()),
              this.checkExport(e),
              this.maybeParseImportAttributes(e),
              this.checkJSONModuleImport(e))
            : s && this.unexpected(),
            this.semicolon()
        }
        shouldParseExportDeclaration() {
          let { type: e } = this.state
          return e === 26 &&
            (this.expectOnePlugin(['decorators', 'decorators-legacy']),
            this.hasPlugin('decorators'))
            ? (this.getPluginOption('decorators', 'decoratorsBeforeExport') ===
                !0 && this.raise(R.DecoratorBeforeExport, this.state.startLoc),
              !0)
            : this.isContextual(107)
            ? (this.raise(R.UsingDeclarationExport, this.state.startLoc), !0)
            : this.isContextual(96) && this.startsAwaitUsing()
            ? (this.raise(R.UsingDeclarationExport, this.state.startLoc), !0)
            : e === 74 ||
              e === 75 ||
              e === 68 ||
              e === 80 ||
              this.isLet() ||
              this.isAsyncFunction()
        }
        checkExport(e, s, i, r) {
          if (s) {
            var n
            if (i) {
              if (
                (this.checkDuplicateExports(e, 'default'),
                this.hasPlugin('exportDefaultFrom'))
              ) {
                var a
                let o = e.declaration
                o.type === 'Identifier' &&
                  o.name === 'from' &&
                  o.end - o.start == 4 &&
                  !((a = o.extra) != null && a.parenthesized) &&
                  this.raise(R.ExportDefaultFromAsIdentifier, o)
              }
            } else if ((n = e.specifiers) != null && n.length)
              for (let o of e.specifiers) {
                let { exported: u } = o,
                  l = u.type === 'Identifier' ? u.name : u.value
                if ((this.checkDuplicateExports(o, l), !r && o.local)) {
                  let { local: c } = o
                  c.type !== 'Identifier'
                    ? this.raise(R.ExportBindingIsString, o, {
                        localName: c.value,
                        exportName: l,
                      })
                    : (this.checkReservedWord(c.name, c.loc.start, !0, !1),
                      this.scope.checkLocalExport(c))
                }
              }
            else if (e.declaration) {
              let o = e.declaration
              if (
                o.type === 'FunctionDeclaration' ||
                o.type === 'ClassDeclaration'
              ) {
                let { id: u } = o
                if (!u) throw new Error('Assertion failure')
                this.checkDuplicateExports(e, u.name)
              } else if (o.type === 'VariableDeclaration')
                for (let u of o.declarations) this.checkDeclaration(u.id)
            }
          }
        }
        checkDeclaration(e) {
          if (e.type === 'Identifier') this.checkDuplicateExports(e, e.name)
          else if (e.type === 'ObjectPattern')
            for (let s of e.properties) this.checkDeclaration(s)
          else if (e.type === 'ArrayPattern')
            for (let s of e.elements) s && this.checkDeclaration(s)
          else
            e.type === 'ObjectProperty'
              ? this.checkDeclaration(e.value)
              : e.type === 'RestElement'
              ? this.checkDeclaration(e.argument)
              : e.type === 'AssignmentPattern' && this.checkDeclaration(e.left)
        }
        checkDuplicateExports(e, s) {
          this.exportedIdentifiers.has(s) &&
            (s === 'default'
              ? this.raise(R.DuplicateDefaultExport, e)
              : this.raise(R.DuplicateExport, e, { exportName: s })),
            this.exportedIdentifiers.add(s)
        }
        parseExportSpecifiers(e) {
          let s = [],
            i = !0
          for (this.expect(5); !this.eat(8); ) {
            if (i) i = !1
            else if ((this.expect(12), this.eat(8))) break
            let r = this.isContextual(130),
              n = this.match(133),
              a = this.startNode()
            ;(a.local = this.parseModuleExportName()),
              s.push(this.parseExportSpecifier(a, n, e, r))
          }
          return s
        }
        parseExportSpecifier(e, s, i, r) {
          return (
            this.eatContextual(93)
              ? (e.exported = this.parseModuleExportName())
              : s
              ? (e.exported = Av(e.local))
              : e.exported || (e.exported = bi(e.local)),
            this.finishNode(e, 'ExportSpecifier')
          )
        }
        parseModuleExportName() {
          if (this.match(133)) {
            let e = this.parseStringLiteral(this.state.value),
              s = Wv.exec(e.value)
            return (
              s &&
                this.raise(R.ModuleExportNameHasLoneSurrogate, e, {
                  surrogateCharCode: s[0].charCodeAt(0),
                }),
              e
            )
          }
          return this.parseIdentifier(!0)
        }
        isJSONModuleImport(e) {
          return e.assertions != null
            ? e.assertions.some(
                ({ key: s, value: i }) =>
                  i.value === 'json' &&
                  (s.type === 'Identifier'
                    ? s.name === 'type'
                    : s.value === 'type')
              )
            : !1
        }
        checkImportReflection(e) {
          let { specifiers: s } = e,
            i = s.length === 1 ? s[0].type : null
          if (e.phase === 'source')
            i !== 'ImportDefaultSpecifier' &&
              this.raise(R.SourcePhaseImportRequiresDefault, s[0].loc.start)
          else if (e.phase === 'defer')
            i !== 'ImportNamespaceSpecifier' &&
              this.raise(R.DeferImportRequiresNamespace, s[0].loc.start)
          else if (e.module) {
            var r
            i !== 'ImportDefaultSpecifier' &&
              this.raise(R.ImportReflectionNotBinding, s[0].loc.start),
              ((r = e.assertions) == null ? void 0 : r.length) > 0 &&
                this.raise(R.ImportReflectionHasAssertion, s[0].loc.start)
          }
        }
        checkJSONModuleImport(e) {
          if (this.isJSONModuleImport(e) && e.type !== 'ExportAllDeclaration') {
            let { specifiers: s } = e
            if (s != null) {
              let i = s.find((r) => {
                let n
                if (
                  (r.type === 'ExportSpecifier'
                    ? (n = r.local)
                    : r.type === 'ImportSpecifier' && (n = r.imported),
                  n !== void 0)
                )
                  return n.type === 'Identifier'
                    ? n.name !== 'default'
                    : n.value !== 'default'
              })
              i !== void 0 &&
                this.raise(R.ImportJSONBindingNotDefault, i.loc.start)
            }
          }
        }
        isPotentialImportPhase(e) {
          return e
            ? !1
            : this.isContextual(105) ||
                this.isContextual(97) ||
                this.isContextual(127)
        }
        applyImportPhase(e, s, i, r) {
          s ||
            (i === 'module'
              ? (this.expectPlugin('importReflection', r), (e.module = !0))
              : this.hasPlugin('importReflection') && (e.module = !1),
            i === 'source'
              ? (this.expectPlugin('sourcePhaseImports', r),
                (e.phase = 'source'))
              : i === 'defer'
              ? (this.expectPlugin('deferredImportEvaluation', r),
                (e.phase = 'defer'))
              : this.hasPlugin('sourcePhaseImports') && (e.phase = null))
        }
        parseMaybeImportPhase(e, s) {
          if (!this.isPotentialImportPhase(s))
            return this.applyImportPhase(e, s, null), null
          let i = this.parseIdentifier(!0),
            { type: r } = this.state
          return (
            Hs(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12
          )
            ? (this.resetPreviousIdentifierLeadingComments(i),
              this.applyImportPhase(e, s, i.name, i.loc.start),
              null)
            : (this.applyImportPhase(e, s, null), i)
        }
        isPrecedingIdImportPhase(e) {
          let { type: s } = this.state
          return Ve(s) ? s !== 98 || this.lookaheadCharCode() === 102 : s !== 12
        }
        parseImport(e) {
          return this.match(133)
            ? this.parseImportSourceAndAttributes(e)
            : this.parseImportSpecifiersAndAfter(
                e,
                this.parseMaybeImportPhase(e, !1)
              )
        }
        parseImportSpecifiersAndAfter(e, s) {
          e.specifiers = []
          let r = !this.maybeParseDefaultImportSpecifier(e, s) || this.eat(12),
            n = r && this.maybeParseStarImportSpecifier(e)
          return (
            r && !n && this.parseNamedImportSpecifiers(e),
            this.expectContextual(98),
            this.parseImportSourceAndAttributes(e)
          )
        }
        parseImportSourceAndAttributes(e) {
          var s
          return (
            (s = e.specifiers) != null || (e.specifiers = []),
            (e.source = this.parseImportSource()),
            this.maybeParseImportAttributes(e),
            this.checkImportReflection(e),
            this.checkJSONModuleImport(e),
            this.semicolon(),
            this.finishNode(e, 'ImportDeclaration')
          )
        }
        parseImportSource() {
          return this.match(133) || this.unexpected(), this.parseExprAtom()
        }
        parseImportSpecifierLocal(e, s, i) {
          ;(s.local = this.parseIdentifier()),
            e.specifiers.push(this.finishImportSpecifier(s, i))
        }
        finishImportSpecifier(e, s, i = 8201) {
          return (
            this.checkLVal(e.local, { in: { type: s }, binding: i }),
            this.finishNode(e, s)
          )
        }
        parseImportAttributes() {
          this.expect(5)
          let e = [],
            s = new Set()
          do {
            if (this.match(8)) break
            let i = this.startNode(),
              r = this.state.value
            if (
              (s.has(r) &&
                this.raise(
                  R.ModuleAttributesWithDuplicateKeys,
                  this.state.startLoc,
                  { key: r }
                ),
              s.add(r),
              this.match(133)
                ? (i.key = this.parseStringLiteral(r))
                : (i.key = this.parseIdentifier(!0)),
              this.expect(14),
              !this.match(133))
            )
              throw this.raise(
                R.ModuleAttributeInvalidValue,
                this.state.startLoc
              )
            ;(i.value = this.parseStringLiteral(this.state.value)),
              e.push(this.finishNode(i, 'ImportAttribute'))
          } while (this.eat(12))
          return this.expect(8), e
        }
        parseModuleAttributes() {
          let e = [],
            s = new Set()
          do {
            let i = this.startNode()
            if (
              ((i.key = this.parseIdentifier(!0)),
              i.key.name !== 'type' &&
                this.raise(R.ModuleAttributeDifferentFromType, i.key),
              s.has(i.key.name) &&
                this.raise(R.ModuleAttributesWithDuplicateKeys, i.key, {
                  key: i.key.name,
                }),
              s.add(i.key.name),
              this.expect(14),
              !this.match(133))
            )
              throw this.raise(
                R.ModuleAttributeInvalidValue,
                this.state.startLoc
              )
            ;(i.value = this.parseStringLiteral(this.state.value)),
              e.push(this.finishNode(i, 'ImportAttribute'))
          } while (this.eat(12))
          return e
        }
        maybeParseImportAttributes(e) {
          let s,
            i = !1
          if (this.match(76)) {
            if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
              return
            this.next(),
              this.hasPlugin('moduleAttributes')
                ? (s = this.parseModuleAttributes())
                : (this.expectImportAttributesPlugin(),
                  (s = this.parseImportAttributes())),
              (i = !0)
          } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
            this.hasPlugin('importAttributes')
              ? (this.getPluginOption(
                  'importAttributes',
                  'deprecatedAssertSyntax'
                ) !== !0 &&
                  this.raise(R.ImportAttributesUseAssert, this.state.startLoc),
                this.addExtra(e, 'deprecatedAssertSyntax', !0))
              : this.expectOnePlugin(['importAttributes', 'importAssertions']),
              this.next(),
              (s = this.parseImportAttributes())
          else if (
            this.hasPlugin('importAttributes') ||
            this.hasPlugin('importAssertions')
          )
            s = []
          else if (this.hasPlugin('moduleAttributes')) s = []
          else return
          !i && this.hasPlugin('importAssertions')
            ? (e.assertions = s)
            : (e.attributes = s)
        }
        maybeParseDefaultImportSpecifier(e, s) {
          if (s) {
            let i = this.startNodeAtNode(s)
            return (
              (i.local = s),
              e.specifiers.push(
                this.finishImportSpecifier(i, 'ImportDefaultSpecifier')
              ),
              !0
            )
          } else if (Hs(this.state.type))
            return (
              this.parseImportSpecifierLocal(
                e,
                this.startNode(),
                'ImportDefaultSpecifier'
              ),
              !0
            )
          return !1
        }
        maybeParseStarImportSpecifier(e) {
          if (this.match(55)) {
            let s = this.startNode()
            return (
              this.next(),
              this.expectContextual(93),
              this.parseImportSpecifierLocal(e, s, 'ImportNamespaceSpecifier'),
              !0
            )
          }
          return !1
        }
        parseNamedImportSpecifiers(e) {
          let s = !0
          for (this.expect(5); !this.eat(8); ) {
            if (s) s = !1
            else {
              if (this.eat(14))
                throw this.raise(R.DestructureNamedImport, this.state.startLoc)
              if ((this.expect(12), this.eat(8))) break
            }
            let i = this.startNode(),
              r = this.match(133),
              n = this.isContextual(130)
            i.imported = this.parseModuleExportName()
            let a = this.parseImportSpecifier(
              i,
              r,
              e.importKind === 'type' || e.importKind === 'typeof',
              n,
              void 0
            )
            e.specifiers.push(a)
          }
        }
        parseImportSpecifier(e, s, i, r, n) {
          if (this.eatContextual(93)) e.local = this.parseIdentifier()
          else {
            let { imported: a } = e
            if (s)
              throw this.raise(R.ImportBindingIsString, e, {
                importName: a.value,
              })
            this.checkReservedWord(a.name, e.loc.start, !0, !0),
              e.local || (e.local = bi(a))
          }
          return this.finishImportSpecifier(e, 'ImportSpecifier', n)
        }
        isThisParam(e) {
          return e.type === 'Identifier' && e.name === 'this'
        }
      },
      kh = class extends L1 {
        constructor(e, s) {
          e = Xv(e)
          super(e, s)
          ;(this.options = e),
            this.initializeScopes(),
            (this.plugins = Jv(this.options.plugins)),
            (this.filename = e.sourceFilename)
        }
        getScopeHandler() {
          return Fu
        }
        parse() {
          this.enterInitialScopes()
          let e = this.startNode(),
            s = this.startNode()
          return (
            this.nextToken(),
            (e.errors = null),
            this.parseTopLevel(e, s),
            (e.errors = this.state.errors),
            (e.comments.length = this.state.commentsLen),
            e
          )
        }
      }
    function Jv(t) {
      let e = new Map()
      for (let s of t) {
        let [i, r] = Array.isArray(s) ? s : [s, {}]
        e.has(i) || e.set(i, r || {})
      }
      return e
    }
    function Yv(t, e) {
      var s
      if (((s = e) == null ? void 0 : s.sourceType) === 'unambiguous') {
        e = Object.assign({}, e)
        try {
          e.sourceType = 'module'
          let i = qa(e, t),
            r = i.parse()
          if (i.sawUnambiguousESM) return r
          if (i.ambiguousScriptDifferentAst)
            try {
              return (e.sourceType = 'script'), qa(e, t).parse()
            } catch (n) {}
          else r.program.sourceType = 'script'
          return r
        } catch (i) {
          try {
            return (e.sourceType = 'script'), qa(e, t).parse()
          } catch (r) {}
          throw i
        }
      } else return qa(e, t).parse()
    }
    function Qv(t, e) {
      let s = qa(e, t)
      return s.options.strictMode && (s.state.strict = !0), s.getExpression()
    }
    function Zv(t) {
      let e = {}
      for (let s of Object.keys(t)) e[s] = mi(t[s])
      return e
    }
    var eN = Zv(GC)
    function qa(t, e) {
      let s = kh
      return (
        t != null && t.plugins && (qv(t.plugins), (s = tN(t.plugins))),
        new s(t, e)
      )
    }
    var k1 = {}
    function tN(t) {
      let e = Kv.filter((r) => yt(t, r)),
        s = e.join('/'),
        i = k1[s]
      if (!i) {
        i = kh
        for (let r of e) i = M1[r](i)
        k1[s] = i
      }
      return i
    }
    Ka.parse = Yv
    Ka.parseExpression = Qv
    Ka.tokTypes = eN
  })
  var Fh = Oe((ju, D1) => {
    ;(function (t, e) {
      typeof ju == 'object' && typeof D1 != 'undefined'
        ? e(ju)
        : typeof define == 'function' && define.amd
        ? define(['exports'], e)
        : ((t = t || self), e((t.estreeWalker = {})))
    })(ju, function (t) {
      'use strict'
      class e {
        constructor() {
          ;(this.should_skip = !1),
            (this.should_remove = !1),
            (this.replacement = null),
            (this.context = {
              skip: () => (this.should_skip = !0),
              remove: () => (this.should_remove = !0),
              replace: (o) => (this.replacement = o),
            })
        }
        replace(o, u, l, c) {
          o && (l !== null ? (o[u][l] = c) : (o[u] = c))
        }
        remove(o, u, l) {
          o && (l !== null ? o[u].splice(l, 1) : delete o[u])
        }
      }
      class s extends e {
        constructor(o, u) {
          super()
          ;(this.enter = o), (this.leave = u)
        }
        visit(o, u, l, c) {
          if (o) {
            if (this.enter) {
              let f = this.should_skip,
                h = this.should_remove,
                p = this.replacement
              ;(this.should_skip = !1),
                (this.should_remove = !1),
                (this.replacement = null),
                this.enter.call(this.context, o, u, l, c),
                this.replacement &&
                  ((o = this.replacement), this.replace(u, l, c, o)),
                this.should_remove && this.remove(u, l, c)
              let m = this.should_skip,
                y = this.should_remove
              if (
                ((this.should_skip = f),
                (this.should_remove = h),
                (this.replacement = p),
                m)
              )
                return o
              if (y) return null
            }
            for (let f in o) {
              let h = o[f]
              if (typeof h == 'object')
                if (Array.isArray(h))
                  for (let p = 0; p < h.length; p += 1)
                    h[p] !== null &&
                      typeof h[p].type == 'string' &&
                      (this.visit(h[p], o, f, p) || p--)
                else
                  h !== null &&
                    typeof h.type == 'string' &&
                    this.visit(h, o, f, null)
            }
            if (this.leave) {
              let f = this.replacement,
                h = this.should_remove
              ;(this.replacement = null),
                (this.should_remove = !1),
                this.leave.call(this.context, o, u, l, c),
                this.replacement &&
                  ((o = this.replacement), this.replace(u, l, c, o)),
                this.should_remove && this.remove(u, l, c)
              let p = this.should_remove
              if (((this.replacement = f), (this.should_remove = h), p))
                return null
            }
          }
          return o
        }
      }
      class i extends e {
        constructor(o, u) {
          super()
          ;(this.enter = o), (this.leave = u)
        }
        async visit(o, u, l, c) {
          if (o) {
            if (this.enter) {
              let f = this.should_skip,
                h = this.should_remove,
                p = this.replacement
              ;(this.should_skip = !1),
                (this.should_remove = !1),
                (this.replacement = null),
                await this.enter.call(this.context, o, u, l, c),
                this.replacement &&
                  ((o = this.replacement), this.replace(u, l, c, o)),
                this.should_remove && this.remove(u, l, c)
              let m = this.should_skip,
                y = this.should_remove
              if (
                ((this.should_skip = f),
                (this.should_remove = h),
                (this.replacement = p),
                m)
              )
                return o
              if (y) return null
            }
            for (let f in o) {
              let h = o[f]
              if (typeof h == 'object')
                if (Array.isArray(h))
                  for (let p = 0; p < h.length; p += 1)
                    h[p] !== null &&
                      typeof h[p].type == 'string' &&
                      ((await this.visit(h[p], o, f, p)) || p--)
                else
                  h !== null &&
                    typeof h.type == 'string' &&
                    (await this.visit(h, o, f, null))
            }
            if (this.leave) {
              let f = this.replacement,
                h = this.should_remove
              ;(this.replacement = null),
                (this.should_remove = !1),
                await this.leave.call(this.context, o, u, l, c),
                this.replacement &&
                  ((o = this.replacement), this.replace(u, l, c, o)),
                this.should_remove && this.remove(u, l, c)
              let p = this.should_remove
              if (((this.replacement = f), (this.should_remove = h), p))
                return null
            }
          }
          return o
        }
      }
      function r(a, { enter: o, leave: u }) {
        return new s(o, u).visit(a, null)
      }
      async function n(a, { enter: o, leave: u }) {
        return await new i(o, u).visit(a, null)
      }
      ;(t.asyncWalk = n),
        (t.walk = r),
        Object.defineProperty(t, '__esModule', { value: !0 })
    })
  })
  var B1 = Oe((Bh) => {
    var F1 =
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(
        ''
      )
    Bh.encode = function (t) {
      if (0 <= t && t < F1.length) return F1[t]
      throw new TypeError('Must be between 0 and 63: ' + t)
    }
    Bh.decode = function (t) {
      var e = 65,
        s = 90,
        i = 97,
        r = 122,
        n = 48,
        a = 57,
        o = 43,
        u = 47,
        l = 26,
        c = 52
      return e <= t && t <= s
        ? t - e
        : i <= t && t <= r
        ? t - i + l
        : n <= t && t <= a
        ? t - n + c
        : t == o
        ? 62
        : t == u
        ? 63
        : -1
    }
  })
  var Hh = Oe((Uh) => {
    var V1 = B1(),
      Vh = 5,
      U1 = 1 << Vh,
      H1 = U1 - 1,
      $1 = U1
    function sN(t) {
      return t < 0 ? (-t << 1) + 1 : (t << 1) + 0
    }
    function iN(t) {
      var e = (t & 1) == 1,
        s = t >> 1
      return e ? -s : s
    }
    Uh.encode = function (e) {
      var s = '',
        i,
        r = sN(e)
      do (i = r & H1), (r >>>= Vh), r > 0 && (i |= $1), (s += V1.encode(i))
      while (r > 0)
      return s
    }
    Uh.decode = function (e, s, i) {
      var r = e.length,
        n = 0,
        a = 0,
        o,
        u
      do {
        if (s >= r)
          throw new Error('Expected more digits in base 64 VLQ value.')
        if (((u = V1.decode(e.charCodeAt(s++))), u === -1))
          throw new Error('Invalid base64 digit: ' + e.charAt(s - 1))
        ;(o = !!(u & $1)), (u &= H1), (n = n + (u << a)), (a += Vh)
      } while (o)
      ;(i.value = iN(n)), (i.rest = s)
    }
  })
  var Un = Oe((Nt) => {
    function rN(t, e, s) {
      if (e in t) return t[e]
      if (arguments.length === 3) return s
      throw new Error('"' + e + '" is a required argument.')
    }
    Nt.getArg = rN
    var j1 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,
      nN = /^data:.+\,.+$/
    function Xa(t) {
      var e = t.match(j1)
      return e
        ? { scheme: e[1], auth: e[2], host: e[3], port: e[4], path: e[5] }
        : null
    }
    Nt.urlParse = Xa
    function Vn(t) {
      var e = ''
      return (
        t.scheme && (e += t.scheme + ':'),
        (e += '//'),
        t.auth && (e += t.auth + '@'),
        t.host && (e += t.host),
        t.port && (e += ':' + t.port),
        t.path && (e += t.path),
        e
      )
    }
    Nt.urlGenerate = Vn
    var aN = 32
    function oN(t) {
      var e = []
      return function (s) {
        for (var i = 0; i < e.length; i++)
          if (e[i].input === s) {
            var r = e[0]
            return (e[0] = e[i]), (e[i] = r), e[0].result
          }
        var n = t(s)
        return e.unshift({ input: s, result: n }), e.length > aN && e.pop(), n
      }
    }
    var $h = oN(function (e) {
      var s = e,
        i = Xa(e)
      if (i) {
        if (!i.path) return e
        s = i.path
      }
      for (var r = Nt.isAbsolute(s), n = [], a = 0, o = 0; ; )
        if (((a = o), (o = s.indexOf('/', a)), o === -1)) {
          n.push(s.slice(a))
          break
        } else for (n.push(s.slice(a, o)); o < s.length && s[o] === '/'; ) o++
      for (var u, l = 0, o = n.length - 1; o >= 0; o--)
        (u = n[o]),
          u === '.'
            ? n.splice(o, 1)
            : u === '..'
            ? l++
            : l > 0 &&
              (u === '' ? (n.splice(o + 1, l), (l = 0)) : (n.splice(o, 2), l--))
      return (
        (s = n.join('/')),
        s === '' && (s = r ? '/' : '.'),
        i ? ((i.path = s), Vn(i)) : s
      )
    })
    Nt.normalize = $h
    function q1(t, e) {
      t === '' && (t = '.'), e === '' && (e = '.')
      var s = Xa(e),
        i = Xa(t)
      if ((i && (t = i.path || '/'), s && !s.scheme))
        return i && (s.scheme = i.scheme), Vn(s)
      if (s || e.match(nN)) return e
      if (i && !i.host && !i.path) return (i.host = e), Vn(i)
      var r = e.charAt(0) === '/' ? e : $h(t.replace(/\/+$/, '') + '/' + e)
      return i ? ((i.path = r), Vn(i)) : r
    }
    Nt.join = q1
    Nt.isAbsolute = function (t) {
      return t.charAt(0) === '/' || j1.test(t)
    }
    function uN(t, e) {
      t === '' && (t = '.'), (t = t.replace(/\/$/, ''))
      for (var s = 0; e.indexOf(t + '/') !== 0; ) {
        var i = t.lastIndexOf('/')
        if (i < 0 || ((t = t.slice(0, i)), t.match(/^([^\/]+:\/)?\/*$/)))
          return e
        ++s
      }
      return Array(s + 1).join('../') + e.substr(t.length + 1)
    }
    Nt.relative = uN
    var K1 = (function () {
      var t = Object.create(null)
      return !('__proto__' in t)
    })()
    function X1(t) {
      return t
    }
    function lN(t) {
      return G1(t) ? '$' + t : t
    }
    Nt.toSetString = K1 ? X1 : lN
    function cN(t) {
      return G1(t) ? t.slice(1) : t
    }
    Nt.fromSetString = K1 ? X1 : cN
    function G1(t) {
      if (!t) return !1
      var e = t.length
      if (
        e < 9 ||
        t.charCodeAt(e - 1) !== 95 ||
        t.charCodeAt(e - 2) !== 95 ||
        t.charCodeAt(e - 3) !== 111 ||
        t.charCodeAt(e - 4) !== 116 ||
        t.charCodeAt(e - 5) !== 111 ||
        t.charCodeAt(e - 6) !== 114 ||
        t.charCodeAt(e - 7) !== 112 ||
        t.charCodeAt(e - 8) !== 95 ||
        t.charCodeAt(e - 9) !== 95
      )
        return !1
      for (var s = e - 10; s >= 0; s--) if (t.charCodeAt(s) !== 36) return !1
      return !0
    }
    function fN(t, e, s) {
      var i = Ei(t.source, e.source)
      return i !== 0 ||
        ((i = t.originalLine - e.originalLine), i !== 0) ||
        ((i = t.originalColumn - e.originalColumn), i !== 0 || s) ||
        ((i = t.generatedColumn - e.generatedColumn), i !== 0) ||
        ((i = t.generatedLine - e.generatedLine), i !== 0)
        ? i
        : Ei(t.name, e.name)
    }
    Nt.compareByOriginalPositions = fN
    function hN(t, e, s) {
      var i
      return (
        (i = t.originalLine - e.originalLine),
        i !== 0 ||
        ((i = t.originalColumn - e.originalColumn), i !== 0 || s) ||
        ((i = t.generatedColumn - e.generatedColumn), i !== 0) ||
        ((i = t.generatedLine - e.generatedLine), i !== 0)
          ? i
          : Ei(t.name, e.name)
      )
    }
    Nt.compareByOriginalPositionsNoSource = hN
    function pN(t, e, s) {
      var i = t.generatedLine - e.generatedLine
      return i !== 0 ||
        ((i = t.generatedColumn - e.generatedColumn), i !== 0 || s) ||
        ((i = Ei(t.source, e.source)), i !== 0) ||
        ((i = t.originalLine - e.originalLine), i !== 0) ||
        ((i = t.originalColumn - e.originalColumn), i !== 0)
        ? i
        : Ei(t.name, e.name)
    }
    Nt.compareByGeneratedPositionsDeflated = pN
    function dN(t, e, s) {
      var i = t.generatedColumn - e.generatedColumn
      return i !== 0 ||
        s ||
        ((i = Ei(t.source, e.source)), i !== 0) ||
        ((i = t.originalLine - e.originalLine), i !== 0) ||
        ((i = t.originalColumn - e.originalColumn), i !== 0)
        ? i
        : Ei(t.name, e.name)
    }
    Nt.compareByGeneratedPositionsDeflatedNoLine = dN
    function Ei(t, e) {
      return t === e ? 0 : t === null ? 1 : e === null ? -1 : t > e ? 1 : -1
    }
    function mN(t, e) {
      var s = t.generatedLine - e.generatedLine
      return s !== 0 ||
        ((s = t.generatedColumn - e.generatedColumn), s !== 0) ||
        ((s = Ei(t.source, e.source)), s !== 0) ||
        ((s = t.originalLine - e.originalLine), s !== 0) ||
        ((s = t.originalColumn - e.originalColumn), s !== 0)
        ? s
        : Ei(t.name, e.name)
    }
    Nt.compareByGeneratedPositionsInflated = mN
    function gN(t) {
      return JSON.parse(t.replace(/^\)]}'[^\n]*\n/, ''))
    }
    Nt.parseSourceMapInput = gN
    function yN(t, e, s) {
      if (
        ((e = e || ''),
        t &&
          (t[t.length - 1] !== '/' && e[0] !== '/' && (t += '/'), (e = t + e)),
        s)
      ) {
        var i = Xa(s)
        if (!i) throw new Error('sourceMapURL could not be parsed')
        if (i.path) {
          var r = i.path.lastIndexOf('/')
          r >= 0 && (i.path = i.path.substring(0, r + 1))
        }
        e = q1(Vn(i), e)
      }
      return $h(e)
    }
    Nt.computeSourceURL = yN
  })
  var Kh = Oe((W1) => {
    var jh = Un(),
      qh = Object.prototype.hasOwnProperty,
      qr = typeof Map != 'undefined'
    function Si() {
      ;(this._array = []), (this._set = qr ? new Map() : Object.create(null))
    }
    Si.fromArray = function (e, s) {
      for (var i = new Si(), r = 0, n = e.length; r < n; r++) i.add(e[r], s)
      return i
    }
    Si.prototype.size = function () {
      return qr ? this._set.size : Object.getOwnPropertyNames(this._set).length
    }
    Si.prototype.add = function (e, s) {
      var i = qr ? e : jh.toSetString(e),
        r = qr ? this.has(e) : qh.call(this._set, i),
        n = this._array.length
      ;(!r || s) && this._array.push(e),
        r || (qr ? this._set.set(e, n) : (this._set[i] = n))
    }
    Si.prototype.has = function (e) {
      if (qr) return this._set.has(e)
      var s = jh.toSetString(e)
      return qh.call(this._set, s)
    }
    Si.prototype.indexOf = function (e) {
      if (qr) {
        var s = this._set.get(e)
        if (s >= 0) return s
      } else {
        var i = jh.toSetString(e)
        if (qh.call(this._set, i)) return this._set[i]
      }
      throw new Error('"' + e + '" is not in the set.')
    }
    Si.prototype.at = function (e) {
      if (e >= 0 && e < this._array.length) return this._array[e]
      throw new Error('No element indexed by ' + e)
    }
    Si.prototype.toArray = function () {
      return this._array.slice()
    }
    W1.ArraySet = Si
  })
  var Y1 = Oe((J1) => {
    var z1 = Un()
    function bN(t, e) {
      var s = t.generatedLine,
        i = e.generatedLine,
        r = t.generatedColumn,
        n = e.generatedColumn
      return (
        i > s ||
        (i == s && n >= r) ||
        z1.compareByGeneratedPositionsInflated(t, e) <= 0
      )
    }
    function qu() {
      ;(this._array = []),
        (this._sorted = !0),
        (this._last = { generatedLine: -1, generatedColumn: 0 })
    }
    qu.prototype.unsortedForEach = function (e, s) {
      this._array.forEach(e, s)
    }
    qu.prototype.add = function (e) {
      bN(this._last, e)
        ? ((this._last = e), this._array.push(e))
        : ((this._sorted = !1), this._array.push(e))
    }
    qu.prototype.toArray = function () {
      return (
        this._sorted ||
          (this._array.sort(z1.compareByGeneratedPositionsInflated),
          (this._sorted = !0)),
        this._array
      )
    }
    J1.MappingList = qu
  })
  var Xh = Oe((Q1) => {
    var Ga = Hh(),
      pt = Un(),
      Ku = Kh().ArraySet,
      EN = Y1().MappingList
    function vs(t) {
      t || (t = {}),
        (this._file = pt.getArg(t, 'file', null)),
        (this._sourceRoot = pt.getArg(t, 'sourceRoot', null)),
        (this._skipValidation = pt.getArg(t, 'skipValidation', !1)),
        (this._ignoreInvalidMapping = pt.getArg(t, 'ignoreInvalidMapping', !1)),
        (this._sources = new Ku()),
        (this._names = new Ku()),
        (this._mappings = new EN()),
        (this._sourcesContents = null)
    }
    vs.prototype._version = 3
    vs.fromSourceMap = function (e, s) {
      var i = e.sourceRoot,
        r = new vs(Object.assign(s || {}, { file: e.file, sourceRoot: i }))
      return (
        e.eachMapping(function (n) {
          var a = {
            generated: { line: n.generatedLine, column: n.generatedColumn },
          }
          n.source != null &&
            ((a.source = n.source),
            i != null && (a.source = pt.relative(i, a.source)),
            (a.original = { line: n.originalLine, column: n.originalColumn }),
            n.name != null && (a.name = n.name)),
            r.addMapping(a)
        }),
        e.sources.forEach(function (n) {
          var a = n
          i !== null && (a = pt.relative(i, n)),
            r._sources.has(a) || r._sources.add(a)
          var o = e.sourceContentFor(n)
          o != null && r.setSourceContent(n, o)
        }),
        r
      )
    }
    vs.prototype.addMapping = function (e) {
      var s = pt.getArg(e, 'generated'),
        i = pt.getArg(e, 'original', null),
        r = pt.getArg(e, 'source', null),
        n = pt.getArg(e, 'name', null)
      ;(!this._skipValidation && this._validateMapping(s, i, r, n) === !1) ||
        (r != null &&
          ((r = String(r)), this._sources.has(r) || this._sources.add(r)),
        n != null &&
          ((n = String(n)), this._names.has(n) || this._names.add(n)),
        this._mappings.add({
          generatedLine: s.line,
          generatedColumn: s.column,
          originalLine: i != null && i.line,
          originalColumn: i != null && i.column,
          source: r,
          name: n,
        }))
    }
    vs.prototype.setSourceContent = function (e, s) {
      var i = e
      this._sourceRoot != null && (i = pt.relative(this._sourceRoot, i)),
        s != null
          ? (this._sourcesContents ||
              (this._sourcesContents = Object.create(null)),
            (this._sourcesContents[pt.toSetString(i)] = s))
          : this._sourcesContents &&
            (delete this._sourcesContents[pt.toSetString(i)],
            Object.keys(this._sourcesContents).length === 0 &&
              (this._sourcesContents = null))
    }
    vs.prototype.applySourceMap = function (e, s, i) {
      var r = s
      if (s == null) {
        if (e.file == null)
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          )
        r = e.file
      }
      var n = this._sourceRoot
      n != null && (r = pt.relative(n, r))
      var a = new Ku(),
        o = new Ku()
      this._mappings.unsortedForEach(function (u) {
        if (u.source === r && u.originalLine != null) {
          var l = e.originalPositionFor({
            line: u.originalLine,
            column: u.originalColumn,
          })
          l.source != null &&
            ((u.source = l.source),
            i != null && (u.source = pt.join(i, u.source)),
            n != null && (u.source = pt.relative(n, u.source)),
            (u.originalLine = l.line),
            (u.originalColumn = l.column),
            l.name != null && (u.name = l.name))
        }
        var c = u.source
        c != null && !a.has(c) && a.add(c)
        var f = u.name
        f != null && !o.has(f) && o.add(f)
      }, this),
        (this._sources = a),
        (this._names = o),
        e.sources.forEach(function (u) {
          var l = e.sourceContentFor(u)
          l != null &&
            (i != null && (u = pt.join(i, u)),
            n != null && (u = pt.relative(n, u)),
            this.setSourceContent(u, l))
        }, this)
    }
    vs.prototype._validateMapping = function (e, s, i, r) {
      if (s && typeof s.line != 'number' && typeof s.column != 'number') {
        var n =
          'original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.'
        if (this._ignoreInvalidMapping)
          return (
            typeof console != 'undefined' && console.warn && console.warn(n), !1
          )
        throw new Error(n)
      }
      if (
        !(
          e &&
          'line' in e &&
          'column' in e &&
          e.line > 0 &&
          e.column >= 0 &&
          !s &&
          !i &&
          !r
        )
      ) {
        if (
          e &&
          'line' in e &&
          'column' in e &&
          s &&
          'line' in s &&
          'column' in s &&
          e.line > 0 &&
          e.column >= 0 &&
          s.line > 0 &&
          s.column >= 0 &&
          i
        )
          return
        var n =
          'Invalid mapping: ' +
          JSON.stringify({ generated: e, source: i, original: s, name: r })
        if (this._ignoreInvalidMapping)
          return (
            typeof console != 'undefined' && console.warn && console.warn(n), !1
          )
        throw new Error(n)
      }
    }
    vs.prototype._serializeMappings = function () {
      for (
        var e = 0,
          s = 1,
          i = 0,
          r = 0,
          n = 0,
          a = 0,
          o = '',
          u,
          l,
          c,
          f,
          h = this._mappings.toArray(),
          p = 0,
          m = h.length;
        p < m;
        p++
      ) {
        if (((l = h[p]), (u = ''), l.generatedLine !== s))
          for (e = 0; l.generatedLine !== s; ) (u += ';'), s++
        else if (p > 0) {
          if (!pt.compareByGeneratedPositionsInflated(l, h[p - 1])) continue
          u += ','
        }
        ;(u += Ga.encode(l.generatedColumn - e)),
          (e = l.generatedColumn),
          l.source != null &&
            ((f = this._sources.indexOf(l.source)),
            (u += Ga.encode(f - a)),
            (a = f),
            (u += Ga.encode(l.originalLine - 1 - r)),
            (r = l.originalLine - 1),
            (u += Ga.encode(l.originalColumn - i)),
            (i = l.originalColumn),
            l.name != null &&
              ((c = this._names.indexOf(l.name)),
              (u += Ga.encode(c - n)),
              (n = c))),
          (o += u)
      }
      return o
    }
    vs.prototype._generateSourcesContent = function (e, s) {
      return e.map(function (i) {
        if (!this._sourcesContents) return null
        s != null && (i = pt.relative(s, i))
        var r = pt.toSetString(i)
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, r)
          ? this._sourcesContents[r]
          : null
      }, this)
    }
    vs.prototype.toJSON = function () {
      var e = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings(),
      }
      return (
        this._file != null && (e.file = this._file),
        this._sourceRoot != null && (e.sourceRoot = this._sourceRoot),
        this._sourcesContents &&
          (e.sourcesContent = this._generateSourcesContent(
            e.sources,
            e.sourceRoot
          )),
        e
      )
    }
    vs.prototype.toString = function () {
      return JSON.stringify(this.toJSON())
    }
    Q1.SourceMapGenerator = vs
  })
  var Z1 = Oe((Kr) => {
    Kr.GREATEST_LOWER_BOUND = 1
    Kr.LEAST_UPPER_BOUND = 2
    function Gh(t, e, s, i, r, n) {
      var a = Math.floor((e - t) / 2) + t,
        o = r(s, i[a], !0)
      return o === 0
        ? a
        : o > 0
        ? e - a > 1
          ? Gh(a, e, s, i, r, n)
          : n == Kr.LEAST_UPPER_BOUND
          ? e < i.length
            ? e
            : -1
          : a
        : a - t > 1
        ? Gh(t, a, s, i, r, n)
        : n == Kr.LEAST_UPPER_BOUND
        ? a
        : t < 0
        ? -1
        : t
    }
    Kr.search = function (e, s, i, r) {
      if (s.length === 0) return -1
      var n = Gh(-1, s.length, e, s, i, r || Kr.GREATEST_LOWER_BOUND)
      if (n < 0) return -1
      for (; n - 1 >= 0 && i(s[n], s[n - 1], !0) === 0; ) --n
      return n
    }
  })
  var sy = Oe((ty) => {
    function SN(t) {
      function e(r, n, a) {
        var o = r[n]
        ;(r[n] = r[a]), (r[a] = o)
      }
      function s(r, n) {
        return Math.round(r + Math.random() * (n - r))
      }
      function i(r, n, a, o) {
        if (a < o) {
          var u = s(a, o),
            l = a - 1
          e(r, u, o)
          for (var c = r[o], f = a; f < o; f++)
            n(r[f], c, !1) <= 0 && ((l += 1), e(r, l, f))
          e(r, l + 1, f)
          var h = l + 1
          i(r, n, a, h - 1), i(r, n, h + 1, o)
        }
      }
      return i
    }
    function TN(t) {
      let e = SN.toString()
      return new Function(`return ${e}`)()(t)
    }
    var ey = new WeakMap()
    ty.quickSort = function (t, e, s = 0) {
      let i = ey.get(e)
      i === void 0 && ((i = TN(e)), ey.set(e, i)), i(t, e, s, t.length - 1)
    }
  })
  var ny = Oe((Xu) => {
    var me = Un(),
      Wh = Z1(),
      Hn = Kh().ArraySet,
      _N = Hh(),
      Wa = sy().quickSort
    function Ye(t, e) {
      var s = t
      return (
        typeof t == 'string' && (s = me.parseSourceMapInput(t)),
        s.sections != null ? new $s(s, e) : new Mt(s, e)
      )
    }
    Ye.fromSourceMap = function (t, e) {
      return Mt.fromSourceMap(t, e)
    }
    Ye.prototype._version = 3
    Ye.prototype.__generatedMappings = null
    Object.defineProperty(Ye.prototype, '_generatedMappings', {
      configurable: !0,
      enumerable: !0,
      get: function () {
        return (
          this.__generatedMappings ||
            this._parseMappings(this._mappings, this.sourceRoot),
          this.__generatedMappings
        )
      },
    })
    Ye.prototype.__originalMappings = null
    Object.defineProperty(Ye.prototype, '_originalMappings', {
      configurable: !0,
      enumerable: !0,
      get: function () {
        return (
          this.__originalMappings ||
            this._parseMappings(this._mappings, this.sourceRoot),
          this.__originalMappings
        )
      },
    })
    Ye.prototype._charIsMappingSeparator = function (e, s) {
      var i = e.charAt(s)
      return i === ';' || i === ','
    }
    Ye.prototype._parseMappings = function (e, s) {
      throw new Error('Subclasses must implement _parseMappings')
    }
    Ye.GENERATED_ORDER = 1
    Ye.ORIGINAL_ORDER = 2
    Ye.GREATEST_LOWER_BOUND = 1
    Ye.LEAST_UPPER_BOUND = 2
    Ye.prototype.eachMapping = function (e, s, i) {
      var r = s || null,
        n = i || Ye.GENERATED_ORDER,
        a
      switch (n) {
        case Ye.GENERATED_ORDER:
          a = this._generatedMappings
          break
        case Ye.ORIGINAL_ORDER:
          a = this._originalMappings
          break
        default:
          throw new Error('Unknown order of iteration.')
      }
      for (
        var o = this.sourceRoot,
          u = e.bind(r),
          l = this._names,
          c = this._sources,
          f = this._sourceMapURL,
          h = 0,
          p = a.length;
        h < p;
        h++
      ) {
        var m = a[h],
          y = m.source === null ? null : c.at(m.source)
        ;(y = me.computeSourceURL(o, y, f)),
          u({
            source: y,
            generatedLine: m.generatedLine,
            generatedColumn: m.generatedColumn,
            originalLine: m.originalLine,
            originalColumn: m.originalColumn,
            name: m.name === null ? null : l.at(m.name),
          })
      }
    }
    Ye.prototype.allGeneratedPositionsFor = function (e) {
      var s = me.getArg(e, 'line'),
        i = {
          source: me.getArg(e, 'source'),
          originalLine: s,
          originalColumn: me.getArg(e, 'column', 0),
        }
      if (((i.source = this._findSourceIndex(i.source)), i.source < 0))
        return []
      var r = [],
        n = this._findMapping(
          i,
          this._originalMappings,
          'originalLine',
          'originalColumn',
          me.compareByOriginalPositions,
          Wh.LEAST_UPPER_BOUND
        )
      if (n >= 0) {
        var a = this._originalMappings[n]
        if (e.column === void 0)
          for (var o = a.originalLine; a && a.originalLine === o; )
            r.push({
              line: me.getArg(a, 'generatedLine', null),
              column: me.getArg(a, 'generatedColumn', null),
              lastColumn: me.getArg(a, 'lastGeneratedColumn', null),
            }),
              (a = this._originalMappings[++n])
        else
          for (
            var u = a.originalColumn;
            a && a.originalLine === s && a.originalColumn == u;

          )
            r.push({
              line: me.getArg(a, 'generatedLine', null),
              column: me.getArg(a, 'generatedColumn', null),
              lastColumn: me.getArg(a, 'lastGeneratedColumn', null),
            }),
              (a = this._originalMappings[++n])
      }
      return r
    }
    Xu.SourceMapConsumer = Ye
    function Mt(t, e) {
      var s = t
      typeof t == 'string' && (s = me.parseSourceMapInput(t))
      var i = me.getArg(s, 'version'),
        r = me.getArg(s, 'sources'),
        n = me.getArg(s, 'names', []),
        a = me.getArg(s, 'sourceRoot', null),
        o = me.getArg(s, 'sourcesContent', null),
        u = me.getArg(s, 'mappings'),
        l = me.getArg(s, 'file', null)
      if (i != this._version) throw new Error('Unsupported version: ' + i)
      a && (a = me.normalize(a)),
        (r = r
          .map(String)
          .map(me.normalize)
          .map(function (c) {
            return a && me.isAbsolute(a) && me.isAbsolute(c)
              ? me.relative(a, c)
              : c
          })),
        (this._names = Hn.fromArray(n.map(String), !0)),
        (this._sources = Hn.fromArray(r, !0)),
        (this._absoluteSources = this._sources.toArray().map(function (c) {
          return me.computeSourceURL(a, c, e)
        })),
        (this.sourceRoot = a),
        (this.sourcesContent = o),
        (this._mappings = u),
        (this._sourceMapURL = e),
        (this.file = l)
    }
    Mt.prototype = Object.create(Ye.prototype)
    Mt.prototype.consumer = Ye
    Mt.prototype._findSourceIndex = function (t) {
      var e = t
      if (
        (this.sourceRoot != null && (e = me.relative(this.sourceRoot, e)),
        this._sources.has(e))
      )
        return this._sources.indexOf(e)
      var s
      for (s = 0; s < this._absoluteSources.length; ++s)
        if (this._absoluteSources[s] == t) return s
      return -1
    }
    Mt.fromSourceMap = function (e, s) {
      var i = Object.create(Mt.prototype),
        r = (i._names = Hn.fromArray(e._names.toArray(), !0)),
        n = (i._sources = Hn.fromArray(e._sources.toArray(), !0))
      ;(i.sourceRoot = e._sourceRoot),
        (i.sourcesContent = e._generateSourcesContent(
          i._sources.toArray(),
          i.sourceRoot
        )),
        (i.file = e._file),
        (i._sourceMapURL = s),
        (i._absoluteSources = i._sources.toArray().map(function (p) {
          return me.computeSourceURL(i.sourceRoot, p, s)
        }))
      for (
        var a = e._mappings.toArray().slice(),
          o = (i.__generatedMappings = []),
          u = (i.__originalMappings = []),
          l = 0,
          c = a.length;
        l < c;
        l++
      ) {
        var f = a[l],
          h = new iy()
        ;(h.generatedLine = f.generatedLine),
          (h.generatedColumn = f.generatedColumn),
          f.source &&
            ((h.source = n.indexOf(f.source)),
            (h.originalLine = f.originalLine),
            (h.originalColumn = f.originalColumn),
            f.name && (h.name = r.indexOf(f.name)),
            u.push(h)),
          o.push(h)
      }
      return Wa(i.__originalMappings, me.compareByOriginalPositions), i
    }
    Mt.prototype._version = 3
    Object.defineProperty(Mt.prototype, 'sources', {
      get: function () {
        return this._absoluteSources.slice()
      },
    })
    function iy() {
      ;(this.generatedLine = 0),
        (this.generatedColumn = 0),
        (this.source = null),
        (this.originalLine = null),
        (this.originalColumn = null),
        (this.name = null)
    }
    var zh = me.compareByGeneratedPositionsDeflatedNoLine
    function ry(t, e) {
      let s = t.length,
        i = t.length - e
      if (!(i <= 1))
        if (i == 2) {
          let r = t[e],
            n = t[e + 1]
          zh(r, n) > 0 && ((t[e] = n), (t[e + 1] = r))
        } else if (i < 20)
          for (let r = e; r < s; r++)
            for (let n = r; n > e; n--) {
              let a = t[n - 1],
                o = t[n]
              if (zh(a, o) <= 0) break
              ;(t[n - 1] = o), (t[n] = a)
            }
        else Wa(t, zh, e)
    }
    Mt.prototype._parseMappings = function (e, s) {
      var i = 1,
        r = 0,
        n = 0,
        a = 0,
        o = 0,
        u = 0,
        l = e.length,
        c = 0,
        f = {},
        h = {},
        p = [],
        m = [],
        y,
        x,
        C,
        E,
        g
      let S = 0
      for (; c < l; )
        if (e.charAt(c) === ';') i++, c++, (r = 0), ry(m, S), (S = m.length)
        else if (e.charAt(c) === ',') c++
        else {
          for (
            y = new iy(), y.generatedLine = i, E = c;
            E < l && !this._charIsMappingSeparator(e, E);
            E++
          );
          for (x = e.slice(c, E), C = []; c < E; )
            _N.decode(e, c, h), (g = h.value), (c = h.rest), C.push(g)
          if (C.length === 2)
            throw new Error('Found a source, but no line and column')
          if (C.length === 3)
            throw new Error('Found a source and line, but no column')
          if (
            ((y.generatedColumn = r + C[0]),
            (r = y.generatedColumn),
            C.length > 1 &&
              ((y.source = o + C[1]),
              (o += C[1]),
              (y.originalLine = n + C[2]),
              (n = y.originalLine),
              (y.originalLine += 1),
              (y.originalColumn = a + C[3]),
              (a = y.originalColumn),
              C.length > 4 && ((y.name = u + C[4]), (u += C[4]))),
            m.push(y),
            typeof y.originalLine == 'number')
          ) {
            let I = y.source
            for (; p.length <= I; ) p.push(null)
            p[I] === null && (p[I] = []), p[I].push(y)
          }
        }
      ry(m, S), (this.__generatedMappings = m)
      for (var _ = 0; _ < p.length; _++)
        p[_] != null && Wa(p[_], me.compareByOriginalPositionsNoSource)
      this.__originalMappings = [].concat(...p)
    }
    Mt.prototype._findMapping = function (e, s, i, r, n, a) {
      if (e[i] <= 0)
        throw new TypeError(
          'Line must be greater than or equal to 1, got ' + e[i]
        )
      if (e[r] < 0)
        throw new TypeError(
          'Column must be greater than or equal to 0, got ' + e[r]
        )
      return Wh.search(e, s, n, a)
    }
    Mt.prototype.computeColumnSpans = function () {
      for (var e = 0; e < this._generatedMappings.length; ++e) {
        var s = this._generatedMappings[e]
        if (e + 1 < this._generatedMappings.length) {
          var i = this._generatedMappings[e + 1]
          if (s.generatedLine === i.generatedLine) {
            s.lastGeneratedColumn = i.generatedColumn - 1
            continue
          }
        }
        s.lastGeneratedColumn = 1 / 0
      }
    }
    Mt.prototype.originalPositionFor = function (e) {
      var s = {
          generatedLine: me.getArg(e, 'line'),
          generatedColumn: me.getArg(e, 'column'),
        },
        i = this._findMapping(
          s,
          this._generatedMappings,
          'generatedLine',
          'generatedColumn',
          me.compareByGeneratedPositionsDeflated,
          me.getArg(e, 'bias', Ye.GREATEST_LOWER_BOUND)
        )
      if (i >= 0) {
        var r = this._generatedMappings[i]
        if (r.generatedLine === s.generatedLine) {
          var n = me.getArg(r, 'source', null)
          n !== null &&
            ((n = this._sources.at(n)),
            (n = me.computeSourceURL(this.sourceRoot, n, this._sourceMapURL)))
          var a = me.getArg(r, 'name', null)
          return (
            a !== null && (a = this._names.at(a)),
            {
              source: n,
              line: me.getArg(r, 'originalLine', null),
              column: me.getArg(r, 'originalColumn', null),
              name: a,
            }
          )
        }
      }
      return { source: null, line: null, column: null, name: null }
    }
    Mt.prototype.hasContentsOfAllSources = function () {
      return this.sourcesContent
        ? this.sourcesContent.length >= this._sources.size() &&
            !this.sourcesContent.some(function (e) {
              return e == null
            })
        : !1
    }
    Mt.prototype.sourceContentFor = function (e, s) {
      if (!this.sourcesContent) return null
      var i = this._findSourceIndex(e)
      if (i >= 0) return this.sourcesContent[i]
      var r = e
      this.sourceRoot != null && (r = me.relative(this.sourceRoot, r))
      var n
      if (this.sourceRoot != null && (n = me.urlParse(this.sourceRoot))) {
        var a = r.replace(/^file:\/\//, '')
        if (n.scheme == 'file' && this._sources.has(a))
          return this.sourcesContent[this._sources.indexOf(a)]
        if ((!n.path || n.path == '/') && this._sources.has('/' + r))
          return this.sourcesContent[this._sources.indexOf('/' + r)]
      }
      if (s) return null
      throw new Error('"' + r + '" is not in the SourceMap.')
    }
    Mt.prototype.generatedPositionFor = function (e) {
      var s = me.getArg(e, 'source')
      if (((s = this._findSourceIndex(s)), s < 0))
        return { line: null, column: null, lastColumn: null }
      var i = {
          source: s,
          originalLine: me.getArg(e, 'line'),
          originalColumn: me.getArg(e, 'column'),
        },
        r = this._findMapping(
          i,
          this._originalMappings,
          'originalLine',
          'originalColumn',
          me.compareByOriginalPositions,
          me.getArg(e, 'bias', Ye.GREATEST_LOWER_BOUND)
        )
      if (r >= 0) {
        var n = this._originalMappings[r]
        if (n.source === i.source)
          return {
            line: me.getArg(n, 'generatedLine', null),
            column: me.getArg(n, 'generatedColumn', null),
            lastColumn: me.getArg(n, 'lastGeneratedColumn', null),
          }
      }
      return { line: null, column: null, lastColumn: null }
    }
    Xu.BasicSourceMapConsumer = Mt
    function $s(t, e) {
      var s = t
      typeof t == 'string' && (s = me.parseSourceMapInput(t))
      var i = me.getArg(s, 'version'),
        r = me.getArg(s, 'sections')
      if (i != this._version) throw new Error('Unsupported version: ' + i)
      ;(this._sources = new Hn()), (this._names = new Hn())
      var n = { line: -1, column: 0 }
      this._sections = r.map(function (a) {
        if (a.url)
          throw new Error('Support for url field in sections not implemented.')
        var o = me.getArg(a, 'offset'),
          u = me.getArg(o, 'line'),
          l = me.getArg(o, 'column')
        if (u < n.line || (u === n.line && l < n.column))
          throw new Error(
            'Section offsets must be ordered and non-overlapping.'
          )
        return (
          (n = o),
          {
            generatedOffset: { generatedLine: u + 1, generatedColumn: l + 1 },
            consumer: new Ye(me.getArg(a, 'map'), e),
          }
        )
      })
    }
    $s.prototype = Object.create(Ye.prototype)
    $s.prototype.constructor = Ye
    $s.prototype._version = 3
    Object.defineProperty($s.prototype, 'sources', {
      get: function () {
        for (var t = [], e = 0; e < this._sections.length; e++)
          for (var s = 0; s < this._sections[e].consumer.sources.length; s++)
            t.push(this._sections[e].consumer.sources[s])
        return t
      },
    })
    $s.prototype.originalPositionFor = function (e) {
      var s = {
          generatedLine: me.getArg(e, 'line'),
          generatedColumn: me.getArg(e, 'column'),
        },
        i = Wh.search(s, this._sections, function (n, a) {
          var o = n.generatedLine - a.generatedOffset.generatedLine
          return o || n.generatedColumn - a.generatedOffset.generatedColumn
        }),
        r = this._sections[i]
      return r
        ? r.consumer.originalPositionFor({
            line: s.generatedLine - (r.generatedOffset.generatedLine - 1),
            column:
              s.generatedColumn -
              (r.generatedOffset.generatedLine === s.generatedLine
                ? r.generatedOffset.generatedColumn - 1
                : 0),
            bias: e.bias,
          })
        : { source: null, line: null, column: null, name: null }
    }
    $s.prototype.hasContentsOfAllSources = function () {
      return this._sections.every(function (e) {
        return e.consumer.hasContentsOfAllSources()
      })
    }
    $s.prototype.sourceContentFor = function (e, s) {
      for (var i = 0; i < this._sections.length; i++) {
        var r = this._sections[i],
          n = r.consumer.sourceContentFor(e, !0)
        if (n || n === '') return n
      }
      if (s) return null
      throw new Error('"' + e + '" is not in the SourceMap.')
    }
    $s.prototype.generatedPositionFor = function (e) {
      for (var s = 0; s < this._sections.length; s++) {
        var i = this._sections[s]
        if (i.consumer._findSourceIndex(me.getArg(e, 'source')) !== -1) {
          var r = i.consumer.generatedPositionFor(e)
          if (r) {
            var n = {
              line: r.line + (i.generatedOffset.generatedLine - 1),
              column:
                r.column +
                (i.generatedOffset.generatedLine === r.line
                  ? i.generatedOffset.generatedColumn - 1
                  : 0),
            }
            return n
          }
        }
      }
      return { line: null, column: null }
    }
    $s.prototype._parseMappings = function (e, s) {
      ;(this.__generatedMappings = []), (this.__originalMappings = [])
      for (var i = 0; i < this._sections.length; i++)
        for (
          var r = this._sections[i], n = r.consumer._generatedMappings, a = 0;
          a < n.length;
          a++
        ) {
          var o = n[a],
            u = r.consumer._sources.at(o.source)
          ;(u = me.computeSourceURL(
            r.consumer.sourceRoot,
            u,
            this._sourceMapURL
          )),
            this._sources.add(u),
            (u = this._sources.indexOf(u))
          var l = null
          o.name &&
            ((l = r.consumer._names.at(o.name)),
            this._names.add(l),
            (l = this._names.indexOf(l)))
          var c = {
            source: u,
            generatedLine:
              o.generatedLine + (r.generatedOffset.generatedLine - 1),
            generatedColumn:
              o.generatedColumn +
              (r.generatedOffset.generatedLine === o.generatedLine
                ? r.generatedOffset.generatedColumn - 1
                : 0),
            originalLine: o.originalLine,
            originalColumn: o.originalColumn,
            name: l,
          }
          this.__generatedMappings.push(c),
            typeof c.originalLine == 'number' && this.__originalMappings.push(c)
        }
      Wa(this.__generatedMappings, me.compareByGeneratedPositionsDeflated),
        Wa(this.__originalMappings, me.compareByOriginalPositions)
    }
    Xu.IndexedSourceMapConsumer = $s
  })
  var oy = Oe((ay) => {
    var xN = Xh().SourceMapGenerator,
      Gu = Un(),
      AN = /(\r?\n)/,
      PN = 10,
      $n = '$$$isSourceNode$$$'
    function hs(t, e, s, i, r) {
      ;(this.children = []),
        (this.sourceContents = {}),
        (this.line = t == null ? null : t),
        (this.column = e == null ? null : e),
        (this.source = s == null ? null : s),
        (this.name = r == null ? null : r),
        (this[$n] = !0),
        i != null && this.add(i)
    }
    hs.fromStringWithSourceMap = function (e, s, i) {
      var r = new hs(),
        n = e.split(AN),
        a = 0,
        o = function () {
          var h = m(),
            p = m() || ''
          return h + p
          function m() {
            return a < n.length ? n[a++] : void 0
          }
        },
        u = 1,
        l = 0,
        c = null
      return (
        s.eachMapping(function (h) {
          if (c !== null)
            if (u < h.generatedLine) f(c, o()), u++, (l = 0)
            else {
              var p = n[a] || '',
                m = p.substr(0, h.generatedColumn - l)
              ;(n[a] = p.substr(h.generatedColumn - l)),
                (l = h.generatedColumn),
                f(c, m),
                (c = h)
              return
            }
          for (; u < h.generatedLine; ) r.add(o()), u++
          if (l < h.generatedColumn) {
            var p = n[a] || ''
            r.add(p.substr(0, h.generatedColumn)),
              (n[a] = p.substr(h.generatedColumn)),
              (l = h.generatedColumn)
          }
          c = h
        }, this),
        a < n.length && (c && f(c, o()), r.add(n.splice(a).join(''))),
        s.sources.forEach(function (h) {
          var p = s.sourceContentFor(h)
          p != null &&
            (i != null && (h = Gu.join(i, h)), r.setSourceContent(h, p))
        }),
        r
      )
      function f(h, p) {
        if (h === null || h.source === void 0) r.add(p)
        else {
          var m = i ? Gu.join(i, h.source) : h.source
          r.add(new hs(h.originalLine, h.originalColumn, m, p, h.name))
        }
      }
    }
    hs.prototype.add = function (e) {
      if (Array.isArray(e))
        e.forEach(function (s) {
          this.add(s)
        }, this)
      else if (e[$n] || typeof e == 'string') e && this.children.push(e)
      else
        throw new TypeError(
          'Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' +
            e
        )
      return this
    }
    hs.prototype.prepend = function (e) {
      if (Array.isArray(e))
        for (var s = e.length - 1; s >= 0; s--) this.prepend(e[s])
      else if (e[$n] || typeof e == 'string') this.children.unshift(e)
      else
        throw new TypeError(
          'Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' +
            e
        )
      return this
    }
    hs.prototype.walk = function (e) {
      for (var s, i = 0, r = this.children.length; i < r; i++)
        (s = this.children[i]),
          s[$n]
            ? s.walk(e)
            : s !== '' &&
              e(s, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name,
              })
    }
    hs.prototype.join = function (e) {
      var s,
        i,
        r = this.children.length
      if (r > 0) {
        for (s = [], i = 0; i < r - 1; i++) s.push(this.children[i]), s.push(e)
        s.push(this.children[i]), (this.children = s)
      }
      return this
    }
    hs.prototype.replaceRight = function (e, s) {
      var i = this.children[this.children.length - 1]
      return (
        i[$n]
          ? i.replaceRight(e, s)
          : typeof i == 'string'
          ? (this.children[this.children.length - 1] = i.replace(e, s))
          : this.children.push(''.replace(e, s)),
        this
      )
    }
    hs.prototype.setSourceContent = function (e, s) {
      this.sourceContents[Gu.toSetString(e)] = s
    }
    hs.prototype.walkSourceContents = function (e) {
      for (var s = 0, i = this.children.length; s < i; s++)
        this.children[s][$n] && this.children[s].walkSourceContents(e)
      for (
        var r = Object.keys(this.sourceContents), s = 0, i = r.length;
        s < i;
        s++
      )
        e(Gu.fromSetString(r[s]), this.sourceContents[r[s]])
    }
    hs.prototype.toString = function () {
      var e = ''
      return (
        this.walk(function (s) {
          e += s
        }),
        e
      )
    }
    hs.prototype.toStringWithSourceMap = function (e) {
      var s = { code: '', line: 1, column: 0 },
        i = new xN(e),
        r = !1,
        n = null,
        a = null,
        o = null,
        u = null
      return (
        this.walk(function (l, c) {
          ;(s.code += l),
            c.source !== null && c.line !== null && c.column !== null
              ? ((n !== c.source ||
                  a !== c.line ||
                  o !== c.column ||
                  u !== c.name) &&
                  i.addMapping({
                    source: c.source,
                    original: { line: c.line, column: c.column },
                    generated: { line: s.line, column: s.column },
                    name: c.name,
                  }),
                (n = c.source),
                (a = c.line),
                (o = c.column),
                (u = c.name),
                (r = !0))
              : r &&
                (i.addMapping({
                  generated: { line: s.line, column: s.column },
                }),
                (n = null),
                (r = !1))
          for (var f = 0, h = l.length; f < h; f++)
            l.charCodeAt(f) === PN
              ? (s.line++,
                (s.column = 0),
                f + 1 === h
                  ? ((n = null), (r = !1))
                  : r &&
                    i.addMapping({
                      source: c.source,
                      original: { line: c.line, column: c.column },
                      generated: { line: s.line, column: s.column },
                      name: c.name,
                    }))
              : s.column++
        }),
        this.walkSourceContents(function (l, c) {
          i.setSourceContent(l, c)
        }),
        { code: s.code, map: i }
      )
    }
    ay.SourceNode = hs
  })
  var Jh = Oe((Wu) => {
    Wu.SourceMapGenerator = Xh().SourceMapGenerator
    Wu.SourceMapConsumer = ny().SourceMapConsumer
    Wu.SourceNode = oy().SourceNode
  })
  var Ab = Oe((G) => {
    'use strict'
    Object.defineProperty(G, '__esModule', { value: !0 })
    var oe = fs(),
      Xr = dh(),
      za = Dh(),
      CN = Fh(),
      vN = Jh(),
      jn = Symbol(''),
      qn = Symbol(''),
      zu = Symbol(''),
      Ja = Symbol(''),
      Yh = Symbol(''),
      tr = Symbol(''),
      Qh = Symbol(''),
      Zh = Symbol(''),
      Ju = Symbol(''),
      Yu = Symbol(''),
      Kn = Symbol(''),
      Qu = Symbol(''),
      ep = Symbol(''),
      Ya = Symbol(''),
      Zu = Symbol(''),
      el = Symbol(''),
      tl = Symbol(''),
      sl = Symbol(''),
      il = Symbol(''),
      tp = Symbol(''),
      sp = Symbol(''),
      rl = Symbol(''),
      Qa = Symbol(''),
      nl = Symbol(''),
      al = Symbol(''),
      Xn = Symbol(''),
      Gn = Symbol(''),
      ol = Symbol(''),
      ul = Symbol(''),
      uy = Symbol(''),
      ll = Symbol(''),
      Za = Symbol(''),
      cl = Symbol(''),
      fl = Symbol(''),
      hl = Symbol(''),
      eo = Symbol(''),
      to = Symbol(''),
      pl = Symbol(''),
      ip = Symbol(''),
      is = {
        [jn]: 'Fragment',
        [qn]: 'Teleport',
        [zu]: 'Suspense',
        [Ja]: 'KeepAlive',
        [Yh]: 'BaseTransition',
        [tr]: 'openBlock',
        [Qh]: 'createBlock',
        [Zh]: 'createElementBlock',
        [Ju]: 'createVNode',
        [Yu]: 'createElementVNode',
        [Kn]: 'createCommentVNode',
        [Qu]: 'createTextVNode',
        [ep]: 'createStaticVNode',
        [Ya]: 'resolveComponent',
        [Zu]: 'resolveDynamicComponent',
        [el]: 'resolveDirective',
        [tl]: 'resolveFilter',
        [sl]: 'withDirectives',
        [il]: 'renderList',
        [tp]: 'renderSlot',
        [sp]: 'createSlots',
        [rl]: 'toDisplayString',
        [Qa]: 'mergeProps',
        [nl]: 'normalizeClass',
        [al]: 'normalizeStyle',
        [Xn]: 'normalizeProps',
        [Gn]: 'guardReactiveProps',
        [ol]: 'toHandlers',
        [ul]: 'camelize',
        [uy]: 'capitalize',
        [ll]: 'toHandlerKey',
        [Za]: 'setBlockTracking',
        [cl]: 'pushScopeId',
        [fl]: 'popScopeId',
        [hl]: 'withCtx',
        [eo]: 'unref',
        [to]: 'isRef',
        [pl]: 'withMemo',
        [ip]: 'isMemoSame',
      }
    function NN(t) {
      Object.getOwnPropertySymbols(t).forEach((e) => {
        is[e] = t[e]
      })
    }
    var IN = { HTML: 0, 0: 'HTML', SVG: 1, 1: 'SVG', MATH_ML: 2, 2: 'MATH_ML' },
      ON = {
        ROOT: 0,
        0: 'ROOT',
        ELEMENT: 1,
        1: 'ELEMENT',
        TEXT: 2,
        2: 'TEXT',
        COMMENT: 3,
        3: 'COMMENT',
        SIMPLE_EXPRESSION: 4,
        4: 'SIMPLE_EXPRESSION',
        INTERPOLATION: 5,
        5: 'INTERPOLATION',
        ATTRIBUTE: 6,
        6: 'ATTRIBUTE',
        DIRECTIVE: 7,
        7: 'DIRECTIVE',
        COMPOUND_EXPRESSION: 8,
        8: 'COMPOUND_EXPRESSION',
        IF: 9,
        9: 'IF',
        IF_BRANCH: 10,
        10: 'IF_BRANCH',
        FOR: 11,
        11: 'FOR',
        TEXT_CALL: 12,
        12: 'TEXT_CALL',
        VNODE_CALL: 13,
        13: 'VNODE_CALL',
        JS_CALL_EXPRESSION: 14,
        14: 'JS_CALL_EXPRESSION',
        JS_OBJECT_EXPRESSION: 15,
        15: 'JS_OBJECT_EXPRESSION',
        JS_PROPERTY: 16,
        16: 'JS_PROPERTY',
        JS_ARRAY_EXPRESSION: 17,
        17: 'JS_ARRAY_EXPRESSION',
        JS_FUNCTION_EXPRESSION: 18,
        18: 'JS_FUNCTION_EXPRESSION',
        JS_CONDITIONAL_EXPRESSION: 19,
        19: 'JS_CONDITIONAL_EXPRESSION',
        JS_CACHE_EXPRESSION: 20,
        20: 'JS_CACHE_EXPRESSION',
        JS_BLOCK_STATEMENT: 21,
        21: 'JS_BLOCK_STATEMENT',
        JS_TEMPLATE_LITERAL: 22,
        22: 'JS_TEMPLATE_LITERAL',
        JS_IF_STATEMENT: 23,
        23: 'JS_IF_STATEMENT',
        JS_ASSIGNMENT_EXPRESSION: 24,
        24: 'JS_ASSIGNMENT_EXPRESSION',
        JS_SEQUENCE_EXPRESSION: 25,
        25: 'JS_SEQUENCE_EXPRESSION',
        JS_RETURN_STATEMENT: 26,
        26: 'JS_RETURN_STATEMENT',
      },
      wN = {
        ELEMENT: 0,
        0: 'ELEMENT',
        COMPONENT: 1,
        1: 'COMPONENT',
        SLOT: 2,
        2: 'SLOT',
        TEMPLATE: 3,
        3: 'TEMPLATE',
      },
      MN = {
        NOT_CONSTANT: 0,
        0: 'NOT_CONSTANT',
        CAN_SKIP_PATCH: 1,
        1: 'CAN_SKIP_PATCH',
        CAN_HOIST: 2,
        2: 'CAN_HOIST',
        CAN_STRINGIFY: 3,
        3: 'CAN_STRINGIFY',
      },
      bt = {
        start: { line: 1, column: 1, offset: 0 },
        end: { line: 1, column: 1, offset: 0 },
        source: '',
      }
    function ly(t, e = '') {
      return {
        type: 0,
        source: e,
        children: t,
        helpers: new Set(),
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: void 0,
        loc: bt,
      }
    }
    function Wn(t, e, s, i, r, n, a, o = !1, u = !1, l = !1, c = bt) {
      return (
        t &&
          (o
            ? (t.helper(tr), t.helper(zr(t.inSSR, l)))
            : t.helper(Wr(t.inSSR, l)),
          a && t.helper(sl)),
        {
          type: 13,
          tag: e,
          props: s,
          children: i,
          patchFlag: r,
          dynamicProps: n,
          directives: a,
          isBlock: o,
          disableTracking: u,
          isComponent: l,
          loc: c,
        }
      )
    }
    function zn(t, e = bt) {
      return { type: 17, loc: e, elements: t }
    }
    function ps(t, e = bt) {
      return { type: 15, loc: e, properties: t }
    }
    function dt(t, e) {
      return {
        type: 16,
        loc: bt,
        key: oe.isString(t) ? Ae(t, !0) : t,
        value: e,
      }
    }
    function Ae(t, e = !1, s = bt, i = 0) {
      return { type: 4, loc: s, content: t, isStatic: e, constType: e ? 3 : i }
    }
    function RN(t, e) {
      return { type: 5, loc: e, content: oe.isString(t) ? Ae(t, !1, e) : t }
    }
    function ds(t, e = bt) {
      return { type: 8, loc: e, children: t }
    }
    function Rt(t, e = [], s = bt) {
      return { type: 14, loc: s, callee: t, arguments: e }
    }
    function Gr(t, e = void 0, s = !1, i = !1, r = bt) {
      return { type: 18, params: t, returns: e, newline: s, isSlot: i, loc: r }
    }
    function dl(t, e, s, i = !0) {
      return {
        type: 19,
        test: t,
        consequent: e,
        alternate: s,
        newline: i,
        loc: bt,
      }
    }
    function cy(t, e, s = !1) {
      return { type: 20, index: t, value: e, isVOnce: s, loc: bt }
    }
    function fy(t) {
      return { type: 21, body: t, loc: bt }
    }
    function LN(t) {
      return { type: 22, elements: t, loc: bt }
    }
    function kN(t, e, s) {
      return { type: 23, test: t, consequent: e, alternate: s, loc: bt }
    }
    function DN(t, e) {
      return { type: 24, left: t, right: e, loc: bt }
    }
    function FN(t) {
      return { type: 25, expressions: t, loc: bt }
    }
    function BN(t) {
      return { type: 26, returns: t, loc: bt }
    }
    function Wr(t, e) {
      return t || e ? Ju : Yu
    }
    function zr(t, e) {
      return t || e ? Qh : Zh
    }
    function ml(t, { helper: e, removeHelper: s, inSSR: i }) {
      t.isBlock ||
        ((t.isBlock = !0),
        s(Wr(i, t.isComponent)),
        e(tr),
        e(zr(i, t.isComponent)))
    }
    var hy = new Uint8Array([123, 123]),
      py = new Uint8Array([125, 125])
    function dy(t) {
      return (t >= 97 && t <= 122) || (t >= 65 && t <= 90)
    }
    function ms(t) {
      return t === 32 || t === 10 || t === 9 || t === 12 || t === 13
    }
    function sr(t) {
      return t === 47 || t === 62 || ms(t)
    }
    function gl(t) {
      let e = new Uint8Array(t.length)
      for (let s = 0; s < t.length; s++) e[s] = t.charCodeAt(s)
      return e
    }
    var Lt = {
        Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
        CdataEnd: new Uint8Array([93, 93, 62]),
        CommentEnd: new Uint8Array([45, 45, 62]),
        ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
        StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
        TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
        TextareaEnd: new Uint8Array([
          60, 47, 116, 101, 120, 116, 97, 114, 101, 97,
        ]),
      },
      my = class {
        constructor(e, s) {
          ;(this.stack = e),
            (this.cbs = s),
            (this.state = 1),
            (this.buffer = ''),
            (this.sectionStart = 0),
            (this.index = 0),
            (this.entityStart = 0),
            (this.baseState = 1),
            (this.inRCDATA = !1),
            (this.inXML = !1),
            (this.inVPre = !1),
            (this.newlines = []),
            (this.mode = 0),
            (this.delimiterOpen = hy),
            (this.delimiterClose = py),
            (this.delimiterIndex = -1),
            (this.currentSequence = void 0),
            (this.sequenceIndex = 0),
            (this.entityDecoder = new Xr.EntityDecoder(
              Xr.htmlDecodeTree,
              (i, r) => this.emitCodePoint(i, r)
            ))
        }
        get inSFCRoot() {
          return this.mode === 2 && this.stack.length === 0
        }
        reset() {
          ;(this.state = 1),
            (this.mode = 0),
            (this.buffer = ''),
            (this.sectionStart = 0),
            (this.index = 0),
            (this.baseState = 1),
            (this.inRCDATA = !1),
            (this.currentSequence = void 0),
            (this.newlines.length = 0),
            (this.delimiterOpen = hy),
            (this.delimiterClose = py)
        }
        getPos(e) {
          let s = 1,
            i = e + 1
          for (let r = this.newlines.length - 1; r >= 0; r--) {
            let n = this.newlines[r]
            if (e > n) {
              ;(s = r + 2), (i = e - n)
              break
            }
          }
          return { column: i, line: s, offset: e }
        }
        peek() {
          return this.buffer.charCodeAt(this.index + 1)
        }
        stateText(e) {
          e === 60
            ? (this.index > this.sectionStart &&
                this.cbs.ontext(this.sectionStart, this.index),
              (this.state = 5),
              (this.sectionStart = this.index))
            : e === 38
            ? this.startEntity()
            : !this.inVPre &&
              e === this.delimiterOpen[0] &&
              ((this.state = 2),
              (this.delimiterIndex = 0),
              this.stateInterpolationOpen(e))
        }
        stateInterpolationOpen(e) {
          if (e === this.delimiterOpen[this.delimiterIndex])
            if (this.delimiterIndex === this.delimiterOpen.length - 1) {
              let s = this.index + 1 - this.delimiterOpen.length
              s > this.sectionStart && this.cbs.ontext(this.sectionStart, s),
                (this.state = 3),
                (this.sectionStart = s)
            } else this.delimiterIndex++
          else
            this.inRCDATA
              ? ((this.state = 32), this.stateInRCDATA(e))
              : ((this.state = 1), this.stateText(e))
        }
        stateInterpolation(e) {
          e === this.delimiterClose[0] &&
            ((this.state = 4),
            (this.delimiterIndex = 0),
            this.stateInterpolationClose(e))
        }
        stateInterpolationClose(e) {
          e === this.delimiterClose[this.delimiterIndex]
            ? this.delimiterIndex === this.delimiterClose.length - 1
              ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1),
                this.inRCDATA ? (this.state = 32) : (this.state = 1),
                (this.sectionStart = this.index + 1))
              : this.delimiterIndex++
            : ((this.state = 3), this.stateInterpolation(e))
        }
        stateSpecialStartSequence(e) {
          let s = this.sequenceIndex === this.currentSequence.length
          if (
            !(s ? sr(e) : (e | 32) === this.currentSequence[this.sequenceIndex])
          )
            this.inRCDATA = !1
          else if (!s) {
            this.sequenceIndex++
            return
          }
          ;(this.sequenceIndex = 0), (this.state = 6), this.stateInTagName(e)
        }
        stateInRCDATA(e) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (e === 62 || ms(e)) {
              let s = this.index - this.currentSequence.length
              if (this.sectionStart < s) {
                let i = this.index
                ;(this.index = s),
                  this.cbs.ontext(this.sectionStart, s),
                  (this.index = i)
              }
              ;(this.sectionStart = s + 2),
                this.stateInClosingTagName(e),
                (this.inRCDATA = !1)
              return
            }
            this.sequenceIndex = 0
          }
          ;(e | 32) === this.currentSequence[this.sequenceIndex]
            ? (this.sequenceIndex += 1)
            : this.sequenceIndex === 0
            ? this.currentSequence === Lt.TitleEnd ||
              (this.currentSequence === Lt.TextareaEnd && !this.inSFCRoot)
              ? e === 38
                ? this.startEntity()
                : e === this.delimiterOpen[0] &&
                  ((this.state = 2),
                  (this.delimiterIndex = 0),
                  this.stateInterpolationOpen(e))
              : this.fastForwardTo(60) && (this.sequenceIndex = 1)
            : (this.sequenceIndex = Number(e === 60))
        }
        stateCDATASequence(e) {
          e === Lt.Cdata[this.sequenceIndex]
            ? ++this.sequenceIndex === Lt.Cdata.length &&
              ((this.state = 28),
              (this.currentSequence = Lt.CdataEnd),
              (this.sequenceIndex = 0),
              (this.sectionStart = this.index + 1))
            : ((this.sequenceIndex = 0),
              (this.state = 23),
              this.stateInDeclaration(e))
        }
        fastForwardTo(e) {
          for (; ++this.index < this.buffer.length; ) {
            let s = this.buffer.charCodeAt(this.index)
            if ((s === 10 && this.newlines.push(this.index), s === e)) return !0
          }
          return (this.index = this.buffer.length - 1), !1
        }
        stateInCommentLike(e) {
          e === this.currentSequence[this.sequenceIndex]
            ? ++this.sequenceIndex === this.currentSequence.length &&
              (this.currentSequence === Lt.CdataEnd
                ? this.cbs.oncdata(this.sectionStart, this.index - 2)
                : this.cbs.oncomment(this.sectionStart, this.index - 2),
              (this.sequenceIndex = 0),
              (this.sectionStart = this.index + 1),
              (this.state = 1))
            : this.sequenceIndex === 0
            ? this.fastForwardTo(this.currentSequence[0]) &&
              (this.sequenceIndex = 1)
            : e !== this.currentSequence[this.sequenceIndex - 1] &&
              (this.sequenceIndex = 0)
        }
        startSpecial(e, s) {
          this.enterRCDATA(e, s), (this.state = 31)
        }
        enterRCDATA(e, s) {
          ;(this.inRCDATA = !0),
            (this.currentSequence = e),
            (this.sequenceIndex = s)
        }
        stateBeforeTagName(e) {
          e === 33
            ? ((this.state = 22), (this.sectionStart = this.index + 1))
            : e === 63
            ? ((this.state = 24), (this.sectionStart = this.index + 1))
            : dy(e)
            ? ((this.sectionStart = this.index),
              this.mode === 0
                ? (this.state = 6)
                : this.inSFCRoot
                ? (this.state = 34)
                : this.inXML
                ? (this.state = 6)
                : e === 116
                ? (this.state = 30)
                : (this.state = e === 115 ? 29 : 6))
            : e === 47
            ? (this.state = 8)
            : ((this.state = 1), this.stateText(e))
        }
        stateInTagName(e) {
          sr(e) && this.handleTagName(e)
        }
        stateInSFCRootTagName(e) {
          if (sr(e)) {
            let s = this.buffer.slice(this.sectionStart, this.index)
            s !== 'template' && this.enterRCDATA(gl('</' + s), 0),
              this.handleTagName(e)
          }
        }
        handleTagName(e) {
          this.cbs.onopentagname(this.sectionStart, this.index),
            (this.sectionStart = -1),
            (this.state = 11),
            this.stateBeforeAttrName(e)
        }
        stateBeforeClosingTagName(e) {
          ms(e) ||
            (e === 62
              ? (this.cbs.onerr(14, this.index),
                (this.state = 1),
                (this.sectionStart = this.index + 1))
              : ((this.state = dy(e) ? 9 : 27),
                (this.sectionStart = this.index)))
        }
        stateInClosingTagName(e) {
          ;(e === 62 || ms(e)) &&
            (this.cbs.onclosetag(this.sectionStart, this.index),
            (this.sectionStart = -1),
            (this.state = 10),
            this.stateAfterClosingTagName(e))
        }
        stateAfterClosingTagName(e) {
          e === 62 && ((this.state = 1), (this.sectionStart = this.index + 1))
        }
        stateBeforeAttrName(e) {
          e === 62
            ? (this.cbs.onopentagend(this.index),
              this.inRCDATA ? (this.state = 32) : (this.state = 1),
              (this.sectionStart = this.index + 1))
            : e === 47
            ? ((this.state = 7),
              this.peek() !== 62 && this.cbs.onerr(22, this.index))
            : e === 60 && this.peek() === 47
            ? (this.cbs.onopentagend(this.index),
              (this.state = 5),
              (this.sectionStart = this.index))
            : ms(e) ||
              (e === 61 && this.cbs.onerr(19, this.index),
              this.handleAttrStart(e))
        }
        handleAttrStart(e) {
          e === 118 && this.peek() === 45
            ? ((this.state = 13), (this.sectionStart = this.index))
            : e === 46 || e === 58 || e === 64 || e === 35
            ? (this.cbs.ondirname(this.index, this.index + 1),
              (this.state = 14),
              (this.sectionStart = this.index + 1))
            : ((this.state = 12), (this.sectionStart = this.index))
        }
        stateInSelfClosingTag(e) {
          e === 62
            ? (this.cbs.onselfclosingtag(this.index),
              (this.state = 1),
              (this.sectionStart = this.index + 1),
              (this.inRCDATA = !1))
            : ms(e) || ((this.state = 11), this.stateBeforeAttrName(e))
        }
        stateInAttrName(e) {
          e === 61 || sr(e)
            ? (this.cbs.onattribname(this.sectionStart, this.index),
              this.handleAttrNameEnd(e))
            : (e === 34 || e === 39 || e === 60) &&
              this.cbs.onerr(17, this.index)
        }
        stateInDirName(e) {
          e === 61 || sr(e)
            ? (this.cbs.ondirname(this.sectionStart, this.index),
              this.handleAttrNameEnd(e))
            : e === 58
            ? (this.cbs.ondirname(this.sectionStart, this.index),
              (this.state = 14),
              (this.sectionStart = this.index + 1))
            : e === 46 &&
              (this.cbs.ondirname(this.sectionStart, this.index),
              (this.state = 16),
              (this.sectionStart = this.index + 1))
        }
        stateInDirArg(e) {
          e === 61 || sr(e)
            ? (this.cbs.ondirarg(this.sectionStart, this.index),
              this.handleAttrNameEnd(e))
            : e === 91
            ? (this.state = 15)
            : e === 46 &&
              (this.cbs.ondirarg(this.sectionStart, this.index),
              (this.state = 16),
              (this.sectionStart = this.index + 1))
        }
        stateInDynamicDirArg(e) {
          e === 93
            ? (this.state = 14)
            : (e === 61 || sr(e)) &&
              (this.cbs.ondirarg(this.sectionStart, this.index + 1),
              this.handleAttrNameEnd(e),
              this.cbs.onerr(27, this.index))
        }
        stateInDirModifier(e) {
          e === 61 || sr(e)
            ? (this.cbs.ondirmodifier(this.sectionStart, this.index),
              this.handleAttrNameEnd(e))
            : e === 46 &&
              (this.cbs.ondirmodifier(this.sectionStart, this.index),
              (this.sectionStart = this.index + 1))
        }
        handleAttrNameEnd(e) {
          ;(this.sectionStart = this.index),
            (this.state = 17),
            this.cbs.onattribnameend(this.index),
            this.stateAfterAttrName(e)
        }
        stateAfterAttrName(e) {
          e === 61
            ? (this.state = 18)
            : e === 47 || e === 62
            ? (this.cbs.onattribend(0, this.sectionStart),
              (this.sectionStart = -1),
              (this.state = 11),
              this.stateBeforeAttrName(e))
            : ms(e) ||
              (this.cbs.onattribend(0, this.sectionStart),
              this.handleAttrStart(e))
        }
        stateBeforeAttrValue(e) {
          e === 34
            ? ((this.state = 19), (this.sectionStart = this.index + 1))
            : e === 39
            ? ((this.state = 20), (this.sectionStart = this.index + 1))
            : ms(e) ||
              ((this.sectionStart = this.index),
              (this.state = 21),
              this.stateInAttrValueNoQuotes(e))
        }
        handleInAttrValue(e, s) {
          e === s
            ? (this.cbs.onattribdata(this.sectionStart, this.index),
              (this.sectionStart = -1),
              this.cbs.onattribend(s === 34 ? 3 : 2, this.index + 1),
              (this.state = 11))
            : e === 38 && this.startEntity()
        }
        stateInAttrValueDoubleQuotes(e) {
          this.handleInAttrValue(e, 34)
        }
        stateInAttrValueSingleQuotes(e) {
          this.handleInAttrValue(e, 39)
        }
        stateInAttrValueNoQuotes(e) {
          ms(e) || e === 62
            ? (this.cbs.onattribdata(this.sectionStart, this.index),
              (this.sectionStart = -1),
              this.cbs.onattribend(1, this.index),
              (this.state = 11),
              this.stateBeforeAttrName(e))
            : e === 34 || e === 39 || e === 60 || e === 61 || e === 96
            ? this.cbs.onerr(18, this.index)
            : e === 38 && this.startEntity()
        }
        stateBeforeDeclaration(e) {
          e === 91
            ? ((this.state = 26), (this.sequenceIndex = 0))
            : (this.state = e === 45 ? 25 : 23)
        }
        stateInDeclaration(e) {
          ;(e === 62 || this.fastForwardTo(62)) &&
            ((this.state = 1), (this.sectionStart = this.index + 1))
        }
        stateInProcessingInstruction(e) {
          ;(e === 62 || this.fastForwardTo(62)) &&
            (this.cbs.onprocessinginstruction(this.sectionStart, this.index),
            (this.state = 1),
            (this.sectionStart = this.index + 1))
        }
        stateBeforeComment(e) {
          e === 45
            ? ((this.state = 28),
              (this.currentSequence = Lt.CommentEnd),
              (this.sequenceIndex = 2),
              (this.sectionStart = this.index + 1))
            : (this.state = 23)
        }
        stateInSpecialComment(e) {
          ;(e === 62 || this.fastForwardTo(62)) &&
            (this.cbs.oncomment(this.sectionStart, this.index),
            (this.state = 1),
            (this.sectionStart = this.index + 1))
        }
        stateBeforeSpecialS(e) {
          e === Lt.ScriptEnd[3]
            ? this.startSpecial(Lt.ScriptEnd, 4)
            : e === Lt.StyleEnd[3]
            ? this.startSpecial(Lt.StyleEnd, 4)
            : ((this.state = 6), this.stateInTagName(e))
        }
        stateBeforeSpecialT(e) {
          e === Lt.TitleEnd[3]
            ? this.startSpecial(Lt.TitleEnd, 4)
            : e === Lt.TextareaEnd[3]
            ? this.startSpecial(Lt.TextareaEnd, 4)
            : ((this.state = 6), this.stateInTagName(e))
        }
        startEntity() {
          ;(this.baseState = this.state),
            (this.state = 33),
            (this.entityStart = this.index),
            this.entityDecoder.startEntity(
              this.baseState === 1 || this.baseState === 32
                ? Xr.DecodingMode.Legacy
                : Xr.DecodingMode.Attribute
            )
        }
        stateInEntity() {
          {
            let e = this.entityDecoder.write(this.buffer, this.index)
            e >= 0
              ? ((this.state = this.baseState),
                e === 0 && (this.index = this.entityStart))
              : (this.index = this.buffer.length - 1)
          }
        }
        parse(e) {
          for (this.buffer = e; this.index < this.buffer.length; ) {
            let s = this.buffer.charCodeAt(this.index)
            switch ((s === 10 && this.newlines.push(this.index), this.state)) {
              case 1: {
                this.stateText(s)
                break
              }
              case 2: {
                this.stateInterpolationOpen(s)
                break
              }
              case 3: {
                this.stateInterpolation(s)
                break
              }
              case 4: {
                this.stateInterpolationClose(s)
                break
              }
              case 31: {
                this.stateSpecialStartSequence(s)
                break
              }
              case 32: {
                this.stateInRCDATA(s)
                break
              }
              case 26: {
                this.stateCDATASequence(s)
                break
              }
              case 19: {
                this.stateInAttrValueDoubleQuotes(s)
                break
              }
              case 12: {
                this.stateInAttrName(s)
                break
              }
              case 13: {
                this.stateInDirName(s)
                break
              }
              case 14: {
                this.stateInDirArg(s)
                break
              }
              case 15: {
                this.stateInDynamicDirArg(s)
                break
              }
              case 16: {
                this.stateInDirModifier(s)
                break
              }
              case 28: {
                this.stateInCommentLike(s)
                break
              }
              case 27: {
                this.stateInSpecialComment(s)
                break
              }
              case 11: {
                this.stateBeforeAttrName(s)
                break
              }
              case 6: {
                this.stateInTagName(s)
                break
              }
              case 34: {
                this.stateInSFCRootTagName(s)
                break
              }
              case 9: {
                this.stateInClosingTagName(s)
                break
              }
              case 5: {
                this.stateBeforeTagName(s)
                break
              }
              case 17: {
                this.stateAfterAttrName(s)
                break
              }
              case 20: {
                this.stateInAttrValueSingleQuotes(s)
                break
              }
              case 18: {
                this.stateBeforeAttrValue(s)
                break
              }
              case 8: {
                this.stateBeforeClosingTagName(s)
                break
              }
              case 10: {
                this.stateAfterClosingTagName(s)
                break
              }
              case 29: {
                this.stateBeforeSpecialS(s)
                break
              }
              case 30: {
                this.stateBeforeSpecialT(s)
                break
              }
              case 21: {
                this.stateInAttrValueNoQuotes(s)
                break
              }
              case 7: {
                this.stateInSelfClosingTag(s)
                break
              }
              case 23: {
                this.stateInDeclaration(s)
                break
              }
              case 22: {
                this.stateBeforeDeclaration(s)
                break
              }
              case 25: {
                this.stateBeforeComment(s)
                break
              }
              case 24: {
                this.stateInProcessingInstruction(s)
                break
              }
              case 33: {
                this.stateInEntity()
                break
              }
            }
            this.index++
          }
          this.cleanup(), this.finish()
        }
        cleanup() {
          this.sectionStart !== this.index &&
            (this.state === 1 || (this.state === 32 && this.sequenceIndex === 0)
              ? (this.cbs.ontext(this.sectionStart, this.index),
                (this.sectionStart = this.index))
              : (this.state === 19 || this.state === 20 || this.state === 21) &&
                (this.cbs.onattribdata(this.sectionStart, this.index),
                (this.sectionStart = this.index)))
        }
        finish() {
          this.state === 33 &&
            (this.entityDecoder.end(), (this.state = this.baseState)),
            this.handleTrailingData(),
            this.cbs.onend()
        }
        handleTrailingData() {
          let e = this.buffer.length
          this.sectionStart >= e ||
            (this.state === 28
              ? this.currentSequence === Lt.CdataEnd
                ? this.cbs.oncdata(this.sectionStart, e)
                : this.cbs.oncomment(this.sectionStart, e)
              : this.state === 6 ||
                this.state === 11 ||
                this.state === 18 ||
                this.state === 17 ||
                this.state === 12 ||
                this.state === 13 ||
                this.state === 14 ||
                this.state === 15 ||
                this.state === 16 ||
                this.state === 20 ||
                this.state === 19 ||
                this.state === 21 ||
                this.state === 9 ||
                this.cbs.ontext(this.sectionStart, e))
        }
        emitCodePoint(e, s) {
          this.baseState !== 1 && this.baseState !== 32
            ? (this.sectionStart < this.entityStart &&
                this.cbs.onattribdata(this.sectionStart, this.entityStart),
              (this.sectionStart = this.entityStart + s),
              (this.index = this.sectionStart - 1),
              this.cbs.onattribentity(
                Xr.fromCodePoint(e),
                this.entityStart,
                this.sectionStart
              ))
            : (this.sectionStart < this.entityStart &&
                this.cbs.ontext(this.sectionStart, this.entityStart),
              (this.sectionStart = this.entityStart + s),
              (this.index = this.sectionStart - 1),
              this.cbs.ontextentity(
                Xr.fromCodePoint(e),
                this.entityStart,
                this.sectionStart
              ))
        }
      },
      VN = {
        COMPILER_IS_ON_ELEMENT: 'COMPILER_IS_ON_ELEMENT',
        COMPILER_V_BIND_SYNC: 'COMPILER_V_BIND_SYNC',
        COMPILER_V_BIND_OBJECT_ORDER: 'COMPILER_V_BIND_OBJECT_ORDER',
        COMPILER_V_ON_NATIVE: 'COMPILER_V_ON_NATIVE',
        COMPILER_V_IF_V_FOR_PRECEDENCE: 'COMPILER_V_IF_V_FOR_PRECEDENCE',
        COMPILER_NATIVE_TEMPLATE: 'COMPILER_NATIVE_TEMPLATE',
        COMPILER_INLINE_TEMPLATE: 'COMPILER_INLINE_TEMPLATE',
        COMPILER_FILTERS: 'COMPILER_FILTERS',
      },
      UN = {
        COMPILER_IS_ON_ELEMENT: {
          message:
            'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
          link: 'https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html',
        },
        COMPILER_V_BIND_SYNC: {
          message: (t) =>
            `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${t}.sync\` should be changed to \`v-model:${t}\`.`,
          link: 'https://v3-migration.vuejs.org/breaking-changes/v-model.html',
        },
        COMPILER_V_BIND_OBJECT_ORDER: {
          message:
            'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
          link: 'https://v3-migration.vuejs.org/breaking-changes/v-bind.html',
        },
        COMPILER_V_ON_NATIVE: {
          message:
            '.native modifier for v-on has been removed as is no longer necessary.',
          link: 'https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html',
        },
        COMPILER_V_IF_V_FOR_PRECEDENCE: {
          message:
            'v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.',
          link: 'https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html',
        },
        COMPILER_NATIVE_TEMPLATE: {
          message:
            '<template> with no special directives will render as a native template element instead of its inner content in Vue 3.',
        },
        COMPILER_INLINE_TEMPLATE: {
          message: '"inline-template" has been removed in Vue 3.',
          link: 'https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html',
        },
        COMPILER_FILTERS: {
          message:
            'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
          link: 'https://v3-migration.vuejs.org/breaking-changes/filters.html',
        },
      }
    function rp(t, { compatConfig: e }) {
      let s = e && e[t]
      return t === 'MODE' ? s || 3 : s
    }
    function Jr(t, e) {
      let s = rp('MODE', e),
        i = rp(t, e)
      return s === 3 ? i === !0 : i !== !1
    }
    function so(t, e, s, ...i) {
      return Jr(t, e)
    }
    function HN(t, e, s, ...i) {
      if (rp(t, e) === 'suppress-warning') return
      let { message: n, link: a } = UN[t],
        o = `(deprecation ${t}) ${typeof n == 'function' ? n(...i) : n}${
          a
            ? `
  Details: ${a}`
            : ''
        }`,
        u = new SyntaxError(o)
      ;(u.code = t), s && (u.loc = s), e.onWarn(u)
    }
    function np(t) {
      throw t
    }
    function gy(t) {}
    function Ge(t, e, s, i) {
      let r = (s || yy)[t] + (i || ''),
        n = new SyntaxError(String(r))
      return (n.code = t), (n.loc = e), n
    }
    var $N = {
        ABRUPT_CLOSING_OF_EMPTY_COMMENT: 0,
        0: 'ABRUPT_CLOSING_OF_EMPTY_COMMENT',
        CDATA_IN_HTML_CONTENT: 1,
        1: 'CDATA_IN_HTML_CONTENT',
        DUPLICATE_ATTRIBUTE: 2,
        2: 'DUPLICATE_ATTRIBUTE',
        END_TAG_WITH_ATTRIBUTES: 3,
        3: 'END_TAG_WITH_ATTRIBUTES',
        END_TAG_WITH_TRAILING_SOLIDUS: 4,
        4: 'END_TAG_WITH_TRAILING_SOLIDUS',
        EOF_BEFORE_TAG_NAME: 5,
        5: 'EOF_BEFORE_TAG_NAME',
        EOF_IN_CDATA: 6,
        6: 'EOF_IN_CDATA',
        EOF_IN_COMMENT: 7,
        7: 'EOF_IN_COMMENT',
        EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT: 8,
        8: 'EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT',
        EOF_IN_TAG: 9,
        9: 'EOF_IN_TAG',
        INCORRECTLY_CLOSED_COMMENT: 10,
        10: 'INCORRECTLY_CLOSED_COMMENT',
        INCORRECTLY_OPENED_COMMENT: 11,
        11: 'INCORRECTLY_OPENED_COMMENT',
        INVALID_FIRST_CHARACTER_OF_TAG_NAME: 12,
        12: 'INVALID_FIRST_CHARACTER_OF_TAG_NAME',
        MISSING_ATTRIBUTE_VALUE: 13,
        13: 'MISSING_ATTRIBUTE_VALUE',
        MISSING_END_TAG_NAME: 14,
        14: 'MISSING_END_TAG_NAME',
        MISSING_WHITESPACE_BETWEEN_ATTRIBUTES: 15,
        15: 'MISSING_WHITESPACE_BETWEEN_ATTRIBUTES',
        NESTED_COMMENT: 16,
        16: 'NESTED_COMMENT',
        UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME: 17,
        17: 'UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME',
        UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE: 18,
        18: 'UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE',
        UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME: 19,
        19: 'UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME',
        UNEXPECTED_NULL_CHARACTER: 20,
        20: 'UNEXPECTED_NULL_CHARACTER',
        UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME: 21,
        21: 'UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME',
        UNEXPECTED_SOLIDUS_IN_TAG: 22,
        22: 'UNEXPECTED_SOLIDUS_IN_TAG',
        X_INVALID_END_TAG: 23,
        23: 'X_INVALID_END_TAG',
        X_MISSING_END_TAG: 24,
        24: 'X_MISSING_END_TAG',
        X_MISSING_INTERPOLATION_END: 25,
        25: 'X_MISSING_INTERPOLATION_END',
        X_MISSING_DIRECTIVE_NAME: 26,
        26: 'X_MISSING_DIRECTIVE_NAME',
        X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END: 27,
        27: 'X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END',
        X_V_IF_NO_EXPRESSION: 28,
        28: 'X_V_IF_NO_EXPRESSION',
        X_V_IF_SAME_KEY: 29,
        29: 'X_V_IF_SAME_KEY',
        X_V_ELSE_NO_ADJACENT_IF: 30,
        30: 'X_V_ELSE_NO_ADJACENT_IF',
        X_V_FOR_NO_EXPRESSION: 31,
        31: 'X_V_FOR_NO_EXPRESSION',
        X_V_FOR_MALFORMED_EXPRESSION: 32,
        32: 'X_V_FOR_MALFORMED_EXPRESSION',
        X_V_FOR_TEMPLATE_KEY_PLACEMENT: 33,
        33: 'X_V_FOR_TEMPLATE_KEY_PLACEMENT',
        X_V_BIND_NO_EXPRESSION: 34,
        34: 'X_V_BIND_NO_EXPRESSION',
        X_V_ON_NO_EXPRESSION: 35,
        35: 'X_V_ON_NO_EXPRESSION',
        X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET: 36,
        36: 'X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET',
        X_V_SLOT_MIXED_SLOT_USAGE: 37,
        37: 'X_V_SLOT_MIXED_SLOT_USAGE',
        X_V_SLOT_DUPLICATE_SLOT_NAMES: 38,
        38: 'X_V_SLOT_DUPLICATE_SLOT_NAMES',
        X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN: 39,
        39: 'X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN',
        X_V_SLOT_MISPLACED: 40,
        40: 'X_V_SLOT_MISPLACED',
        X_V_MODEL_NO_EXPRESSION: 41,
        41: 'X_V_MODEL_NO_EXPRESSION',
        X_V_MODEL_MALFORMED_EXPRESSION: 42,
        42: 'X_V_MODEL_MALFORMED_EXPRESSION',
        X_V_MODEL_ON_SCOPE_VARIABLE: 43,
        43: 'X_V_MODEL_ON_SCOPE_VARIABLE',
        X_V_MODEL_ON_PROPS: 44,
        44: 'X_V_MODEL_ON_PROPS',
        X_INVALID_EXPRESSION: 45,
        45: 'X_INVALID_EXPRESSION',
        X_KEEP_ALIVE_INVALID_CHILDREN: 46,
        46: 'X_KEEP_ALIVE_INVALID_CHILDREN',
        X_PREFIX_ID_NOT_SUPPORTED: 47,
        47: 'X_PREFIX_ID_NOT_SUPPORTED',
        X_MODULE_MODE_NOT_SUPPORTED: 48,
        48: 'X_MODULE_MODE_NOT_SUPPORTED',
        X_CACHE_HANDLER_NOT_SUPPORTED: 49,
        49: 'X_CACHE_HANDLER_NOT_SUPPORTED',
        X_SCOPE_ID_NOT_SUPPORTED: 50,
        50: 'X_SCOPE_ID_NOT_SUPPORTED',
        X_VNODE_HOOKS: 51,
        51: 'X_VNODE_HOOKS',
        X_V_BIND_INVALID_SAME_NAME_ARGUMENT: 52,
        52: 'X_V_BIND_INVALID_SAME_NAME_ARGUMENT',
        __EXTEND_POINT__: 53,
        53: '__EXTEND_POINT__',
      },
      yy = {
        [0]: 'Illegal comment.',
        [1]: 'CDATA section is allowed only in XML context.',
        [2]: 'Duplicate attribute.',
        [3]: 'End tag cannot have attributes.',
        [4]: "Illegal '/' in tags.",
        [5]: 'Unexpected EOF in tag.',
        [6]: 'Unexpected EOF in CDATA section.',
        [7]: 'Unexpected EOF in comment.',
        [8]: 'Unexpected EOF in script.',
        [9]: 'Unexpected EOF in tag.',
        [10]: 'Incorrectly closed comment.',
        [11]: 'Incorrectly opened comment.',
        [12]: "Illegal tag name. Use '&lt;' to print '<'.",
        [13]: 'Attribute value was expected.',
        [14]: 'End tag name was expected.',
        [15]: 'Whitespace was expected.',
        [16]: "Unexpected '<!--' in comment.",
        [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
        [18]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
        [19]: "Attribute name cannot start with '='.",
        [21]: "'<?' is allowed only in XML context.",
        [20]: 'Unexpected null character.',
        [22]: "Illegal '/' in tags.",
        [23]: 'Invalid end tag.',
        [24]: 'Element is missing end tag.',
        [25]: 'Interpolation end sign was not found.',
        [27]: 'End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.',
        [26]: 'Legal directive name was expected.',
        [28]: 'v-if/v-else-if is missing expression.',
        [29]: 'v-if/else branches must use unique keys.',
        [30]: 'v-else/v-else-if has no adjacent v-if or v-else-if.',
        [31]: 'v-for is missing expression.',
        [32]: 'v-for has invalid expression.',
        [33]: '<template v-for> key should be placed on the <template> tag.',
        [34]: 'v-bind is missing expression.',
        [52]: 'v-bind with same-name shorthand only allows static argument.',
        [35]: 'v-on is missing expression.',
        [36]: 'Unexpected custom directive on <slot> outlet.',
        [37]: 'Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.',
        [38]: 'Duplicate slot names found. ',
        [39]: 'Extraneous children found when component already has explicitly named default slot. These children will be ignored.',
        [40]: 'v-slot can only be used on components or <template> tags.',
        [41]: 'v-model is missing expression.',
        [42]: 'v-model value must be a valid JavaScript member expression.',
        [43]: 'v-model cannot be used on v-for or v-slot scope variables because they are not writable.',
        [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
        [45]: 'Error parsing JavaScript expression: ',
        [46]: '<KeepAlive> expects exactly one child component.',
        [51]: '@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.',
        [47]: '"prefixIdentifiers" option is not supported in this build of compiler.',
        [48]: 'ES module mode is not supported in this build of compiler.',
        [49]: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
        [50]: '"scopeId" option is only supported in module mode.',
        [53]: '',
      }
    function by(t, e, s = !1, i = [], r = Object.create(null)) {
      let n =
        t.type === 'Program'
          ? t.body[0].type === 'ExpressionStatement' && t.body[0].expression
          : t
      CN.walk(t, {
        enter(a, o) {
          if (
            (o && i.push(o),
            o && o.type.startsWith('TS') && !lp.includes(o.type))
          )
            return this.skip()
          if (a.type === 'Identifier') {
            let u = !!r[a.name],
              l = Ey(a, o, i)
            ;(s || (l && !u)) && e(a, o, i, l, u)
          } else
            a.type === 'ObjectProperty' &&
            (o == null ? void 0 : o.type) === 'ObjectPattern'
              ? (a.inPattern = !0)
              : Ay(a)
              ? a.scopeIds
                ? a.scopeIds.forEach((u) => op(u, r))
                : Ty(a, (u) => xy(a, u, r))
              : a.type === 'BlockStatement' &&
                (a.scopeIds
                  ? a.scopeIds.forEach((u) => op(u, r))
                  : _y(a, (u) => xy(a, u, r)))
        },
        leave(a, o) {
          if ((o && i.pop(), a !== n && a.scopeIds))
            for (let u of a.scopeIds) r[u]--, r[u] === 0 && delete r[u]
        },
      })
    }
    function Ey(t, e, s) {
      if (!e) return !0
      if (t.name === 'arguments') return !1
      if (jN(t, e)) return !0
      switch (e.type) {
        case 'AssignmentExpression':
        case 'AssignmentPattern':
          return !0
        case 'ObjectPattern':
        case 'ArrayPattern':
          return ap(e, s)
      }
      return !1
    }
    function ap(t, e) {
      if (t && (t.type === 'ObjectProperty' || t.type === 'ArrayPattern')) {
        let s = e.length
        for (; s--; ) {
          let i = e[s]
          if (i.type === 'AssignmentExpression') return !0
          if (i.type !== 'ObjectProperty' && !i.type.endsWith('Pattern')) break
        }
      }
      return !1
    }
    function Sy(t) {
      let e = t.length
      for (; e--; ) {
        let s = t[e]
        if (s.type === 'NewExpression') return !0
        if (s.type !== 'MemberExpression') break
      }
      return !1
    }
    function Ty(t, e) {
      for (let s of t.params) for (let i of Ti(s)) e(i)
    }
    function _y(t, e) {
      for (let s of t.body)
        if (s.type === 'VariableDeclaration') {
          if (s.declare) continue
          for (let i of s.declarations) for (let r of Ti(i.id)) e(r)
        } else if (
          s.type === 'FunctionDeclaration' ||
          s.type === 'ClassDeclaration'
        ) {
          if (s.declare || !s.id) continue
          e(s.id)
        } else if (
          s.type === 'ForOfStatement' ||
          s.type === 'ForInStatement' ||
          s.type === 'ForStatement'
        ) {
          let i = s.type === 'ForStatement' ? s.init : s.left
          if (i && i.type === 'VariableDeclaration')
            for (let r of i.declarations) for (let n of Ti(r.id)) e(n)
        }
    }
    function Ti(t, e = []) {
      switch (t.type) {
        case 'Identifier':
          e.push(t)
          break
        case 'MemberExpression':
          let s = t
          for (; s.type === 'MemberExpression'; ) s = s.object
          e.push(s)
          break
        case 'ObjectPattern':
          for (let i of t.properties)
            i.type === 'RestElement' ? Ti(i.argument, e) : Ti(i.value, e)
          break
        case 'ArrayPattern':
          t.elements.forEach((i) => {
            i && Ti(i, e)
          })
          break
        case 'RestElement':
          Ti(t.argument, e)
          break
        case 'AssignmentPattern':
          Ti(t.left, e)
          break
      }
      return e
    }
    function op(t, e) {
      t in e ? e[t]++ : (e[t] = 1)
    }
    function xy(t, e, s) {
      let { name: i } = e
      ;(t.scopeIds && t.scopeIds.has(i)) ||
        (op(i, s), (t.scopeIds || (t.scopeIds = new Set())).add(i))
    }
    var Ay = (t) => /Function(?:Expression|Declaration)$|Method$/.test(t.type),
      up = (t) =>
        t &&
        (t.type === 'ObjectProperty' || t.type === 'ObjectMethod') &&
        !t.computed,
      Py = (t, e) => up(e) && e.key === t
    function jN(t, e, s) {
      switch (e.type) {
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return e.property === t ? !!e.computed : e.object === t
        case 'JSXMemberExpression':
          return e.object === t
        case 'VariableDeclarator':
          return e.init === t
        case 'ArrowFunctionExpression':
          return e.body === t
        case 'PrivateName':
          return !1
        case 'ClassMethod':
        case 'ClassPrivateMethod':
        case 'ObjectMethod':
          return e.key === t ? !!e.computed : !1
        case 'ObjectProperty':
          return e.key === t ? !!e.computed : !s
        case 'ClassProperty':
          return e.key === t ? !!e.computed : !0
        case 'ClassPrivateProperty':
          return e.key !== t
        case 'ClassDeclaration':
        case 'ClassExpression':
          return e.superClass === t
        case 'AssignmentExpression':
          return e.right === t
        case 'AssignmentPattern':
          return e.right === t
        case 'LabeledStatement':
          return !1
        case 'CatchClause':
          return !1
        case 'RestElement':
          return !1
        case 'BreakStatement':
        case 'ContinueStatement':
          return !1
        case 'FunctionDeclaration':
        case 'FunctionExpression':
          return !1
        case 'ExportNamespaceSpecifier':
        case 'ExportDefaultSpecifier':
          return !1
        case 'ExportSpecifier':
          return e.local === t
        case 'ImportDefaultSpecifier':
        case 'ImportNamespaceSpecifier':
        case 'ImportSpecifier':
          return !1
        case 'ImportAttribute':
          return !1
        case 'JSXAttribute':
          return !1
        case 'ObjectPattern':
        case 'ArrayPattern':
          return !1
        case 'MetaProperty':
          return !1
        case 'ObjectTypeProperty':
          return e.key !== t
        case 'TSEnumMember':
          return e.id !== t
        case 'TSPropertySignature':
          return e.key === t ? !!e.computed : !0
      }
      return !0
    }
    var lp = [
      'TSAsExpression',
      'TSTypeAssertion',
      'TSNonNullExpression',
      'TSInstantiationExpression',
      'TSSatisfiesExpression',
    ]
    function cp(t) {
      return lp.includes(t.type) ? cp(t.expression) : t
    }
    var js = (t) => t.type === 4 && t.isStatic
    function fp(t) {
      switch (t) {
        case 'Teleport':
        case 'teleport':
          return qn
        case 'Suspense':
        case 'suspense':
          return zu
        case 'KeepAlive':
        case 'keep-alive':
          return Ja
        case 'BaseTransition':
        case 'base-transition':
          return Yh
      }
    }
    var qN = /^\d|[^\$\w\xA0-\uFFFF]/,
      _i = (t) => !qN.test(t),
      KN = /[A-Za-z_$\xA0-\uFFFF]/,
      XN = /[\.\?\w$\xA0-\uFFFF]/,
      GN = /\s+[.[]\s*|\s*[.[]\s+/g,
      WN = (t) => {
        t = t.trim().replace(GN, (a) => a.trim())
        let e = 0,
          s = [],
          i = 0,
          r = 0,
          n = null
        for (let a = 0; a < t.length; a++) {
          let o = t.charAt(a)
          switch (e) {
            case 0:
              if (o === '[') s.push(e), (e = 1), i++
              else if (o === '(') s.push(e), (e = 2), r++
              else if (!(a === 0 ? KN : XN).test(o)) return !1
              break
            case 1:
              o === "'" || o === '"' || o === '`'
                ? (s.push(e), (e = 3), (n = o))
                : o === '['
                ? i++
                : o === ']' && (--i || (e = s.pop()))
              break
            case 2:
              if (o === "'" || o === '"' || o === '`')
                s.push(e), (e = 3), (n = o)
              else if (o === '(') r++
              else if (o === ')') {
                if (a === t.length - 1) return !1
                --r || (e = s.pop())
              }
              break
            case 3:
              o === n && ((e = s.pop()), (n = null))
              break
          }
        }
        return !i && !r
      },
      Cy = (t, e) => {
        try {
          let s = za.parseExpression(t, { plugins: e.expressionPlugins })
          return (
            (s = cp(s)),
            s.type === 'MemberExpression' ||
              s.type === 'OptionalMemberExpression' ||
              (s.type === 'Identifier' && s.name !== 'undefined')
          )
        } catch (s) {
          return !1
        }
      },
      hp = Cy
    function pp(t, e, s = e.length) {
      return dp({ offset: t.offset, line: t.line, column: t.column }, e, s)
    }
    function dp(t, e, s = e.length) {
      let i = 0,
        r = -1
      for (let n = 0; n < s; n++) e.charCodeAt(n) === 10 && (i++, (r = n))
      return (
        (t.offset += s),
        (t.line += i),
        (t.column = r === -1 ? t.column + s : s - r),
        t
      )
    }
    function zN(t, e) {
      if (!t) throw new Error(e || 'unexpected compiler condition')
    }
    function gs(t, e, s = !1) {
      for (let i = 0; i < t.props.length; i++) {
        let r = t.props[i]
        if (
          r.type === 7 &&
          (s || r.exp) &&
          (oe.isString(e) ? r.name === e : e.test(r.name))
        )
          return r
      }
    }
    function io(t, e, s = !1, i = !1) {
      for (let r = 0; r < t.props.length; r++) {
        let n = t.props[r]
        if (n.type === 6) {
          if (s) continue
          if (n.name === e && (n.value || i)) return n
        } else if (n.name === 'bind' && (n.exp || i) && ir(n.arg, e)) return n
      }
    }
    function ir(t, e) {
      return !!(t && js(t) && t.content === e)
    }
    function JN(t) {
      return t.props.some(
        (e) =>
          e.type === 7 &&
          e.name === 'bind' &&
          (!e.arg || e.arg.type !== 4 || !e.arg.isStatic)
      )
    }
    function yl(t) {
      return t.type === 5 || t.type === 2
    }
    function mp(t) {
      return t.type === 7 && t.name === 'slot'
    }
    function Jn(t) {
      return t.type === 1 && t.tagType === 3
    }
    function ro(t) {
      return t.type === 1 && t.tagType === 2
    }
    var YN = new Set([Xn, Gn])
    function vy(t, e = []) {
      if (t && !oe.isString(t) && t.type === 14) {
        let s = t.callee
        if (!oe.isString(s) && YN.has(s)) return vy(t.arguments[0], e.concat(t))
      }
      return [t, e]
    }
    function no(t, e, s) {
      let i,
        r = t.type === 13 ? t.props : t.arguments[2],
        n = [],
        a
      if (r && !oe.isString(r) && r.type === 14) {
        let o = vy(r)
        ;(r = o[0]), (n = o[1]), (a = n[n.length - 1])
      }
      if (r == null || oe.isString(r)) i = ps([e])
      else if (r.type === 14) {
        let o = r.arguments[0]
        !oe.isString(o) && o.type === 15
          ? Ny(e, o) || o.properties.unshift(e)
          : r.callee === ol
          ? (i = Rt(s.helper(Qa), [ps([e]), r]))
          : r.arguments.unshift(ps([e])),
          !i && (i = r)
      } else
        r.type === 15
          ? (Ny(e, r) || r.properties.unshift(e), (i = r))
          : ((i = Rt(s.helper(Qa), [ps([e]), r])),
            a && a.callee === Gn && (a = n[n.length - 2]))
      t.type === 13
        ? a
          ? (a.arguments[0] = i)
          : (t.props = i)
        : a
        ? (a.arguments[0] = i)
        : (t.arguments[2] = i)
    }
    function Ny(t, e) {
      let s = !1
      if (t.key.type === 4) {
        let i = t.key.content
        s = e.properties.some((r) => r.key.type === 4 && r.key.content === i)
      }
      return s
    }
    function Yr(t, e) {
      return `_${e}_${t.replace(/[^\w]/g, (s, i) =>
        s === '-' ? '_' : t.charCodeAt(i).toString()
      )}`
    }
    function rs(t, e) {
      if (!t || Object.keys(e).length === 0) return !1
      switch (t.type) {
        case 1:
          for (let s = 0; s < t.props.length; s++) {
            let i = t.props[s]
            if (i.type === 7 && (rs(i.arg, e) || rs(i.exp, e))) return !0
          }
          return t.children.some((s) => rs(s, e))
        case 11:
          return rs(t.source, e) ? !0 : t.children.some((s) => rs(s, e))
        case 9:
          return t.branches.some((s) => rs(s, e))
        case 10:
          return rs(t.condition, e) ? !0 : t.children.some((s) => rs(s, e))
        case 4:
          return !t.isStatic && _i(t.content) && !!e[t.content]
        case 8:
          return t.children.some((s) => oe.isObject(s) && rs(s, e))
        case 5:
        case 12:
          return rs(t.content, e)
        case 2:
        case 3:
          return !1
        default:
          return !1
      }
    }
    function Iy(t) {
      return t.type === 14 && t.callee === pl ? t.arguments[1].returns : t
    }
    var Oy = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/,
      wy = {
        parseMode: 'base',
        ns: 0,
        delimiters: ['{{', '}}'],
        getNamespace: () => 0,
        isVoidTag: oe.NO,
        isPreTag: oe.NO,
        isCustomElement: oe.NO,
        onError: np,
        onWarn: gy,
        comments: !1,
        prefixIdentifiers: !1,
      },
      je = wy,
      ao = null,
      xi = '',
      Ht = null,
      Me = null,
      Ns = '',
      Ai = -1,
      Qr = -1,
      bl = 0,
      rr = !1,
      gp = null,
      ct = [],
      ze = new my(ct, {
        onerr: Yt,
        ontext(t, e) {
          El(kt(t, e), t, e)
        },
        ontextentity(t, e, s) {
          El(t, e, s)
        },
        oninterpolation(t, e) {
          if (rr) return El(kt(t, e), t, e)
          let s = t + ze.delimiterOpen.length,
            i = e - ze.delimiterClose.length
          for (; ms(xi.charCodeAt(s)); ) s++
          for (; ms(xi.charCodeAt(i - 1)); ) i--
          let r = kt(s, i)
          r.includes('&') && (r = Xr.decodeHTML(r)),
            yp({ type: 5, content: Tl(r, !1, Tt(s, i)), loc: Tt(t, e) })
        },
        onopentagname(t, e) {
          let s = kt(t, e)
          Ht = {
            type: 1,
            tag: s,
            ns: je.getNamespace(s, ct[0], je.ns),
            tagType: 0,
            props: [],
            children: [],
            loc: Tt(t - 1, e),
            codegenNode: void 0,
          }
        },
        onopentagend(t) {
          Ry(t)
        },
        onclosetag(t, e) {
          let s = kt(t, e)
          if (!je.isVoidTag(s)) {
            let i = !1
            for (let r = 0; r < ct.length; r++)
              if (ct[r].tag.toLowerCase() === s.toLowerCase()) {
                ;(i = !0), r > 0 && Yt(24, ct[0].loc.start.offset)
                for (let a = 0; a <= r; a++) {
                  let o = ct.shift()
                  Sl(o, e, a < r)
                }
                break
              }
            i || Yt(23, Ly(t, 60))
          }
        },
        onselfclosingtag(t) {
          let e = Ht.tag
          ;(Ht.isSelfClosing = !0),
            Ry(t),
            ct[0] && ct[0].tag === e && Sl(ct.shift(), t)
        },
        onattribname(t, e) {
          Me = {
            type: 6,
            name: kt(t, e),
            nameLoc: Tt(t, e),
            value: void 0,
            loc: Tt(t),
          }
        },
        ondirname(t, e) {
          let s = kt(t, e),
            i =
              s === '.' || s === ':'
                ? 'bind'
                : s === '@'
                ? 'on'
                : s === '#'
                ? 'slot'
                : s.slice(2)
          if ((!rr && i === '' && Yt(26, t), rr || i === ''))
            Me = {
              type: 6,
              name: s,
              nameLoc: Tt(t, e),
              value: void 0,
              loc: Tt(t),
            }
          else if (
            ((Me = {
              type: 7,
              name: i,
              rawName: s,
              exp: void 0,
              arg: void 0,
              modifiers: s === '.' ? ['prop'] : [],
              loc: Tt(t),
            }),
            i === 'pre')
          ) {
            ;(rr = ze.inVPre = !0), (gp = Ht)
            let r = Ht.props
            for (let n = 0; n < r.length; n++)
              r[n].type === 7 && (r[n] = oI(r[n]))
          }
        },
        ondirarg(t, e) {
          if (t === e) return
          let s = kt(t, e)
          if (rr) (Me.name += s), Zr(Me.nameLoc, e)
          else {
            let i = s[0] !== '['
            Me.arg = Tl(i ? s : s.slice(1, -1), i, Tt(t, e), i ? 3 : 0)
          }
        },
        ondirmodifier(t, e) {
          let s = kt(t, e)
          if (rr) (Me.name += '.' + s), Zr(Me.nameLoc, e)
          else if (Me.name === 'slot') {
            let i = Me.arg
            i && ((i.content += '.' + s), Zr(i.loc, e))
          } else Me.modifiers.push(s)
        },
        onattribdata(t, e) {
          ;(Ns += kt(t, e)), Ai < 0 && (Ai = t), (Qr = e)
        },
        onattribentity(t, e, s) {
          ;(Ns += t), Ai < 0 && (Ai = e), (Qr = s)
        },
        onattribnameend(t) {
          let e = Me.loc.start.offset,
            s = kt(e, t)
          Me.type === 7 && (Me.rawName = s),
            Ht.props.some((i) => (i.type === 7 ? i.rawName : i.name) === s) &&
              Yt(2, e)
        },
        onattribend(t, e) {
          if (Ht && Me) {
            if ((Zr(Me.loc, e), t !== 0))
              if (Me.type === 6)
                Me.name === 'class' && (Ns = Fy(Ns).trim()),
                  t === 1 && !Ns && Yt(13, e),
                  (Me.value = {
                    type: 2,
                    content: Ns,
                    loc: t === 1 ? Tt(Ai, Qr) : Tt(Ai - 1, Qr + 1),
                  }),
                  ze.inSFCRoot &&
                    Ht.tag === 'template' &&
                    Me.name === 'lang' &&
                    Ns &&
                    Ns !== 'html' &&
                    ze.enterRCDATA(gl('</template'), 0)
              else {
                let s = 0
                Me.name === 'for'
                  ? (s = 3)
                  : Me.name === 'slot'
                  ? (s = 1)
                  : Me.name === 'on' && Ns.includes(';') && (s = 2),
                  (Me.exp = Tl(Ns, !1, Tt(Ai, Qr), 0, s)),
                  Me.name === 'for' && (Me.forParseResult = ZN(Me.exp))
                let i = -1
                Me.name === 'bind' &&
                  (i = Me.modifiers.indexOf('sync')) > -1 &&
                  so('COMPILER_V_BIND_SYNC', je, Me.loc, Me.rawName) &&
                  ((Me.name = 'model'), Me.modifiers.splice(i, 1))
              }
            ;(Me.type !== 7 || Me.name !== 'pre') && Ht.props.push(Me)
          }
          ;(Ns = ''), (Ai = Qr = -1)
        },
        oncomment(t, e) {
          je.comments &&
            yp({ type: 3, content: kt(t, e), loc: Tt(t - 4, e + 3) })
        },
        onend() {
          let t = xi.length
          if (ze.state !== 1)
            switch (ze.state) {
              case 5:
              case 8:
                Yt(5, t)
                break
              case 3:
              case 4:
                Yt(25, ze.sectionStart)
                break
              case 28:
                ze.currentSequence === Lt.CdataEnd ? Yt(6, t) : Yt(7, t)
                break
              case 6:
              case 7:
              case 9:
              case 11:
              case 12:
              case 13:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
                Yt(9, t)
                break
            }
          for (let e = 0; e < ct.length; e++)
            Sl(ct[e], t - 1), Yt(24, ct[e].loc.start.offset)
        },
        oncdata(t, e) {
          ct[0].ns !== 0 ? El(kt(t, e), t, e) : Yt(1, t - 9)
        },
        onprocessinginstruction(t) {
          ;(ct[0] ? ct[0].ns : je.ns) === 0 && Yt(21, t - 1)
        },
      }),
      My = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
      QN = /^\(|\)$/g
    function ZN(t) {
      let e = t.loc,
        s = t.content,
        i = s.match(Oy)
      if (!i) return
      let [, r, n] = i,
        a = (f, h, p = !1) => {
          let m = e.start.offset + h,
            y = m + f.length
          return Tl(f, !1, Tt(m, y), 0, p ? 1 : 0)
        },
        o = {
          source: a(n.trim(), s.indexOf(n, r.length)),
          value: void 0,
          key: void 0,
          index: void 0,
          finalized: !1,
        },
        u = r.trim().replace(QN, '').trim(),
        l = r.indexOf(u),
        c = u.match(My)
      if (c) {
        u = u.replace(My, '').trim()
        let f = c[1].trim(),
          h
        if (
          (f && ((h = s.indexOf(f, l + u.length)), (o.key = a(f, h, !0))), c[2])
        ) {
          let p = c[2].trim()
          p &&
            (o.index = a(
              p,
              s.indexOf(p, o.key ? h + f.length : l + u.length),
              !0
            ))
        }
      }
      return u && (o.value = a(u, l, !0)), o
    }
    function kt(t, e) {
      return xi.slice(t, e)
    }
    function Ry(t) {
      ze.inSFCRoot && (Ht.innerLoc = Tt(t + 1, t + 1)), yp(Ht)
      let { tag: e, ns: s } = Ht
      s === 0 && je.isPreTag(e) && bl++,
        je.isVoidTag(e)
          ? Sl(Ht, t)
          : (ct.unshift(Ht), (s === 1 || s === 2) && (ze.inXML = !0)),
        (Ht = null)
    }
    function El(t, e, s) {
      let i = ct[0] || ao,
        r = i.children[i.children.length - 1]
      r && r.type === 2
        ? ((r.content += t), Zr(r.loc, s))
        : i.children.push({ type: 2, content: t, loc: Tt(e, s) })
    }
    function Sl(t, e, s = !1) {
      s ? Zr(t.loc, Ly(e, 60)) : Zr(t.loc, eI(e, 62) + 1),
        ze.inSFCRoot &&
          (t.children.length
            ? (t.innerLoc.end = oe.extend(
                {},
                t.children[t.children.length - 1].loc.end
              ))
            : (t.innerLoc.end = oe.extend({}, t.innerLoc.start)),
          (t.innerLoc.source = kt(
            t.innerLoc.start.offset,
            t.innerLoc.end.offset
          )))
      let { tag: i, ns: r } = t
      rr ||
        (i === 'slot'
          ? (t.tagType = 2)
          : ky(t)
          ? (t.tagType = 3)
          : sI(t) && (t.tagType = 1)),
        ze.inRCDATA || (t.children = Dy(t.children, t.tag)),
        r === 0 && je.isPreTag(i) && bl--,
        gp === t && ((rr = ze.inVPre = !1), (gp = null)),
        ze.inXML && (ct[0] ? ct[0].ns : je.ns) === 0 && (ze.inXML = !1)
      {
        let n = t.props
        if (
          !ze.inSFCRoot &&
          Jr('COMPILER_NATIVE_TEMPLATE', je) &&
          t.tag === 'template' &&
          !ky(t)
        ) {
          let o = ct[0] || ao,
            u = o.children.indexOf(t)
          o.children.splice(u, 1, ...t.children)
        }
        let a = n.find((o) => o.type === 6 && o.name === 'inline-template')
        a &&
          so('COMPILER_INLINE_TEMPLATE', je, a.loc) &&
          t.children.length &&
          (a.value = {
            type: 2,
            content: kt(
              t.children[0].loc.start.offset,
              t.children[t.children.length - 1].loc.end.offset
            ),
            loc: a.loc,
          })
      }
    }
    function eI(t, e) {
      let s = t
      for (; xi.charCodeAt(s) !== e && s < xi.length - 1; ) s++
      return s
    }
    function Ly(t, e) {
      let s = t
      for (; xi.charCodeAt(s) !== e && s >= 0; ) s--
      return s
    }
    var tI = new Set(['if', 'else', 'else-if', 'for', 'slot'])
    function ky({ tag: t, props: e }) {
      if (t === 'template') {
        for (let s = 0; s < e.length; s++)
          if (e[s].type === 7 && tI.has(e[s].name)) return !0
      }
      return !1
    }
    function sI({ tag: t, props: e }) {
      if (je.isCustomElement(t)) return !1
      if (
        t === 'component' ||
        iI(t.charCodeAt(0)) ||
        fp(t) ||
        (je.isBuiltInComponent && je.isBuiltInComponent(t)) ||
        (je.isNativeTag && !je.isNativeTag(t))
      )
        return !0
      for (let s = 0; s < e.length; s++) {
        let i = e[s]
        if (i.type === 6) {
          if (i.name === 'is' && i.value) {
            if (i.value.content.startsWith('vue:')) return !0
            if (so('COMPILER_IS_ON_ELEMENT', je, i.loc)) return !0
          }
        } else if (
          i.name === 'bind' &&
          ir(i.arg, 'is') &&
          so('COMPILER_IS_ON_ELEMENT', je, i.loc)
        )
          return !0
      }
      return !1
    }
    function iI(t) {
      return t > 64 && t < 91
    }
    var rI = /\r\n/g
    function Dy(t, e) {
      let s = je.whitespace !== 'preserve',
        i = !1
      for (let r = 0; r < t.length; r++) {
        let n = t[r]
        if (n.type === 2)
          if (bl)
            n.content = n.content.replace(
              rI,
              `
`
            )
          else if (nI(n.content)) {
            let a = t[r - 1] && t[r - 1].type,
              o = t[r + 1] && t[r + 1].type
            !a ||
            !o ||
            (s &&
              ((a === 3 && (o === 3 || o === 1)) ||
                (a === 1 && (o === 3 || (o === 1 && aI(n.content))))))
              ? ((i = !0), (t[r] = null))
              : (n.content = ' ')
          } else s && (n.content = Fy(n.content))
      }
      if (bl && e && je.isPreTag(e)) {
        let r = t[0]
        r && r.type === 2 && (r.content = r.content.replace(/^\r?\n/, ''))
      }
      return i ? t.filter(Boolean) : t
    }
    function nI(t) {
      for (let e = 0; e < t.length; e++) if (!ms(t.charCodeAt(e))) return !1
      return !0
    }
    function aI(t) {
      for (let e = 0; e < t.length; e++) {
        let s = t.charCodeAt(e)
        if (s === 10 || s === 13) return !0
      }
      return !1
    }
    function Fy(t) {
      let e = '',
        s = !1
      for (let i = 0; i < t.length; i++)
        ms(t.charCodeAt(i))
          ? s || ((e += ' '), (s = !0))
          : ((e += t[i]), (s = !1))
      return e
    }
    function yp(t) {
      ;(ct[0] || ao).children.push(t)
    }
    function Tt(t, e) {
      return {
        start: ze.getPos(t),
        end: e == null ? e : ze.getPos(e),
        source: e == null ? e : kt(t, e),
      }
    }
    function Zr(t, e) {
      ;(t.end = ze.getPos(e)), (t.source = kt(t.start.offset, e))
    }
    function oI(t) {
      let e = {
        type: 6,
        name: t.rawName,
        nameLoc: Tt(t.loc.start.offset, t.loc.start.offset + t.rawName.length),
        value: void 0,
        loc: t.loc,
      }
      if (t.exp) {
        let s = t.exp.loc
        s.end.offset < t.loc.end.offset &&
          (s.start.offset--, s.start.column--, s.end.offset++, s.end.column++),
          (e.value = { type: 2, content: t.exp.content, loc: s })
      }
      return e
    }
    function Tl(t, e = !1, s, i = 0, r = 0) {
      let n = Ae(t, e, s, i)
      if (!e && je.prefixIdentifiers && r !== 3 && t.trim()) {
        if (_i(t)) return (n.ast = null), n
        try {
          let a = je.expressionPlugins,
            o = { plugins: a ? [...a, 'typescript'] : ['typescript'] }
          r === 2
            ? (n.ast = za.parse(` ${t} `, o).program)
            : r === 1
            ? (n.ast = za.parseExpression(`(${t})=>{}`, o))
            : (n.ast = za.parseExpression(`(${t})`, o))
        } catch (a) {
          ;(n.ast = !1), Yt(45, s.start.offset, a.message)
        }
      }
      return n
    }
    function Yt(t, e, s) {
      je.onError(Ge(t, Tt(e, e), void 0, s))
    }
    function uI() {
      ze.reset(),
        (Ht = null),
        (Me = null),
        (Ns = ''),
        (Ai = -1),
        (Qr = -1),
        (ct.length = 0)
    }
    function By(t, e) {
      if ((uI(), (xi = t), (je = oe.extend({}, wy)), e)) {
        let r
        for (r in e) e[r] != null && (je[r] = e[r])
      }
      ;(ze.mode = je.parseMode === 'html' ? 1 : je.parseMode === 'sfc' ? 2 : 0),
        (ze.inXML = je.ns === 1 || je.ns === 2)
      let s = e && e.delimiters
      s && ((ze.delimiterOpen = gl(s[0])), (ze.delimiterClose = gl(s[1])))
      let i = (ao = ly([], t))
      return (
        ze.parse(xi),
        (i.loc = Tt(0, t.length)),
        (i.children = Dy(i.children)),
        (ao = null),
        i
      )
    }
    function lI(t, e) {
      _l(t, e, Vy(t, t.children[0]))
    }
    function Vy(t, e) {
      let { children: s } = t
      return s.length === 1 && e.type === 1 && !ro(e)
    }
    function _l(t, e, s = !1) {
      let { children: i } = t,
        r = i.length,
        n = 0
      for (let a = 0; a < i.length; a++) {
        let o = i[a]
        if (o.type === 1 && o.tagType === 0) {
          let u = s ? 0 : Is(o, e)
          if (u > 0) {
            if (u >= 2) {
              ;(o.codegenNode.patchFlag = -1),
                (o.codegenNode = e.hoist(o.codegenNode)),
                n++
              continue
            }
          } else {
            let l = o.codegenNode
            if (l.type === 13) {
              let c = l.patchFlag
              if ((c === void 0 || c === 512 || c === 1) && Hy(o, e) >= 2) {
                let f = $y(o)
                f && (l.props = e.hoist(f))
              }
              l.dynamicProps && (l.dynamicProps = e.hoist(l.dynamicProps))
            }
          }
        }
        if (o.type === 1) {
          let u = o.tagType === 1
          u && e.scopes.vSlot++, _l(o, e), u && e.scopes.vSlot--
        } else if (o.type === 11) _l(o, e, o.children.length === 1)
        else if (o.type === 9)
          for (let u = 0; u < o.branches.length; u++)
            _l(o.branches[u], e, o.branches[u].children.length === 1)
      }
      if (
        (n && e.transformHoist && e.transformHoist(i, e, t),
        n &&
          n === r &&
          t.type === 1 &&
          t.tagType === 0 &&
          t.codegenNode &&
          t.codegenNode.type === 13 &&
          oe.isArray(t.codegenNode.children))
      ) {
        let a = e.hoist(zn(t.codegenNode.children))
        e.hmr && (a.content = `[...${a.content}]`), (t.codegenNode.children = a)
      }
    }
    function Is(t, e) {
      let { constantCache: s } = e
      switch (t.type) {
        case 1:
          if (t.tagType !== 0) return 0
          let i = s.get(t)
          if (i !== void 0) return i
          let r = t.codegenNode
          if (
            r.type !== 13 ||
            (r.isBlock &&
              t.tag !== 'svg' &&
              t.tag !== 'foreignObject' &&
              t.tag !== 'math')
          )
            return 0
          if (r.patchFlag === void 0) {
            let a = 3,
              o = Hy(t, e)
            if (o === 0) return s.set(t, 0), 0
            o < a && (a = o)
            for (let u = 0; u < t.children.length; u++) {
              let l = Is(t.children[u], e)
              if (l === 0) return s.set(t, 0), 0
              l < a && (a = l)
            }
            if (a > 1)
              for (let u = 0; u < t.props.length; u++) {
                let l = t.props[u]
                if (l.type === 7 && l.name === 'bind' && l.exp) {
                  let c = Is(l.exp, e)
                  if (c === 0) return s.set(t, 0), 0
                  c < a && (a = c)
                }
              }
            if (r.isBlock) {
              for (let u = 0; u < t.props.length; u++)
                if (t.props[u].type === 7) return s.set(t, 0), 0
              e.removeHelper(tr),
                e.removeHelper(zr(e.inSSR, r.isComponent)),
                (r.isBlock = !1),
                e.helper(Wr(e.inSSR, r.isComponent))
            }
            return s.set(t, a), a
          } else return s.set(t, 0), 0
        case 2:
        case 3:
          return 3
        case 9:
        case 11:
        case 10:
          return 0
        case 5:
        case 12:
          return Is(t.content, e)
        case 4:
          return t.constType
        case 8:
          let n = 3
          for (let a = 0; a < t.children.length; a++) {
            let o = t.children[a]
            if (oe.isString(o) || oe.isSymbol(o)) continue
            let u = Is(o, e)
            if (u === 0) return 0
            u < n && (n = u)
          }
          return n
        default:
          return 0
      }
    }
    var cI = new Set([nl, al, Xn, Gn])
    function Uy(t, e) {
      if (t.type === 14 && !oe.isString(t.callee) && cI.has(t.callee)) {
        let s = t.arguments[0]
        if (s.type === 4) return Is(s, e)
        if (s.type === 14) return Uy(s, e)
      }
      return 0
    }
    function Hy(t, e) {
      let s = 3,
        i = $y(t)
      if (i && i.type === 15) {
        let { properties: r } = i
        for (let n = 0; n < r.length; n++) {
          let { key: a, value: o } = r[n],
            u = Is(a, e)
          if (u === 0) return u
          u < s && (s = u)
          let l
          if (
            (o.type === 4
              ? (l = Is(o, e))
              : o.type === 14
              ? (l = Uy(o, e))
              : (l = 0),
            l === 0)
          )
            return l
          l < s && (s = l)
        }
      }
      return s
    }
    function $y(t) {
      let e = t.codegenNode
      if (e.type === 13) return e.props
    }
    function jy(
      t,
      {
        filename: e = '',
        prefixIdentifiers: s = !1,
        hoistStatic: i = !1,
        hmr: r = !1,
        cacheHandlers: n = !1,
        nodeTransforms: a = [],
        directiveTransforms: o = {},
        transformHoist: u = null,
        isBuiltInComponent: l = oe.NOOP,
        isCustomElement: c = oe.NOOP,
        expressionPlugins: f = [],
        scopeId: h = null,
        slotted: p = !0,
        ssr: m = !1,
        inSSR: y = !1,
        ssrCssVars: x = '',
        bindingMetadata: C = oe.EMPTY_OBJ,
        inline: E = !1,
        isTS: g = !1,
        onError: S = np,
        onWarn: _ = gy,
        compatConfig: I,
      }
    ) {
      let k = e.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/),
        L = {
          filename: e,
          selfName: k && oe.capitalize(oe.camelize(k[1])),
          prefixIdentifiers: s,
          hoistStatic: i,
          hmr: r,
          cacheHandlers: n,
          nodeTransforms: a,
          directiveTransforms: o,
          transformHoist: u,
          isBuiltInComponent: l,
          isCustomElement: c,
          expressionPlugins: f,
          scopeId: h,
          slotted: p,
          ssr: m,
          inSSR: y,
          ssrCssVars: x,
          bindingMetadata: C,
          inline: E,
          isTS: g,
          onError: S,
          onWarn: _,
          compatConfig: I,
          root: t,
          helpers: new Map(),
          components: new Set(),
          directives: new Set(),
          hoists: [],
          imports: [],
          constantCache: new WeakMap(),
          temps: 0,
          cached: 0,
          identifiers: Object.create(null),
          scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 },
          parent: null,
          grandParent: null,
          currentNode: t,
          childIndex: 0,
          inVOnce: !1,
          helper(v) {
            let A = L.helpers.get(v) || 0
            return L.helpers.set(v, A + 1), v
          },
          removeHelper(v) {
            let A = L.helpers.get(v)
            if (A) {
              let V = A - 1
              V ? L.helpers.set(v, V) : L.helpers.delete(v)
            }
          },
          helperString(v) {
            return `_${is[L.helper(v)]}`
          },
          replaceNode(v) {
            L.parent.children[L.childIndex] = L.currentNode = v
          },
          removeNode(v) {
            let A = L.parent.children,
              V = v ? A.indexOf(v) : L.currentNode ? L.childIndex : -1
            !v || v === L.currentNode
              ? ((L.currentNode = null), L.onNodeRemoved())
              : L.childIndex > V && (L.childIndex--, L.onNodeRemoved()),
              L.parent.children.splice(V, 1)
          },
          onNodeRemoved: oe.NOOP,
          addIdentifiers(v) {
            oe.isString(v)
              ? N(v)
              : v.identifiers
              ? v.identifiers.forEach(N)
              : v.type === 4 && N(v.content)
          },
          removeIdentifiers(v) {
            oe.isString(v)
              ? O(v)
              : v.identifiers
              ? v.identifiers.forEach(O)
              : v.type === 4 && O(v.content)
          },
          hoist(v) {
            oe.isString(v) && (v = Ae(v)), L.hoists.push(v)
            let A = Ae(`_hoisted_${L.hoists.length}`, !1, v.loc, 2)
            return (A.hoisted = v), A
          },
          cache(v, A = !1) {
            return cy(L.cached++, v, A)
          },
        }
      L.filters = new Set()
      function N(v) {
        let { identifiers: A } = L
        A[v] === void 0 && (A[v] = 0), A[v]++
      }
      function O(v) {
        L.identifiers[v]--
      }
      return L
    }
    function qy(t, e) {
      let s = jy(t, e)
      oo(t, s),
        e.hoistStatic && lI(t, s),
        e.ssr || fI(t, s),
        (t.helpers = new Set([...s.helpers.keys()])),
        (t.components = [...s.components]),
        (t.directives = [...s.directives]),
        (t.imports = s.imports),
        (t.hoists = s.hoists),
        (t.temps = s.temps),
        (t.cached = s.cached),
        (t.transformed = !0),
        (t.filters = [...s.filters])
    }
    function fI(t, e) {
      let { helper: s } = e,
        { children: i } = t
      if (i.length === 1) {
        let r = i[0]
        if (Vy(t, r) && r.codegenNode) {
          let n = r.codegenNode
          n.type === 13 && ml(n, e), (t.codegenNode = n)
        } else t.codegenNode = r
      } else if (i.length > 1) {
        let r = 64
        oe.PatchFlagNames[64],
          (t.codegenNode = Wn(
            e,
            s(jn),
            void 0,
            t.children,
            r,
            void 0,
            void 0,
            !0,
            void 0,
            !1
          ))
      }
    }
    function hI(t, e) {
      let s = 0,
        i = () => {
          s--
        }
      for (; s < t.children.length; s++) {
        let r = t.children[s]
        oe.isString(r) ||
          ((e.grandParent = e.parent),
          (e.parent = t),
          (e.childIndex = s),
          (e.onNodeRemoved = i),
          oo(r, e))
      }
    }
    function oo(t, e) {
      e.currentNode = t
      let { nodeTransforms: s } = e,
        i = []
      for (let n = 0; n < s.length; n++) {
        let a = s[n](t, e)
        if ((a && (oe.isArray(a) ? i.push(...a) : i.push(a)), e.currentNode))
          t = e.currentNode
        else return
      }
      switch (t.type) {
        case 3:
          e.ssr || e.helper(Kn)
          break
        case 5:
          e.ssr || e.helper(rl)
          break
        case 9:
          for (let n = 0; n < t.branches.length; n++) oo(t.branches[n], e)
          break
        case 10:
        case 11:
        case 1:
        case 0:
          hI(t, e)
          break
      }
      e.currentNode = t
      let r = i.length
      for (; r--; ) i[r]()
    }
    function bp(t, e) {
      let s = oe.isString(t) ? (i) => i === t : (i) => t.test(i)
      return (i, r) => {
        if (i.type === 1) {
          let { props: n } = i
          if (i.tagType === 3 && n.some(mp)) return
          let a = []
          for (let o = 0; o < n.length; o++) {
            let u = n[o]
            if (u.type === 7 && s(u.name)) {
              n.splice(o, 1), o--
              let l = e(i, u, r)
              l && a.push(l)
            }
          }
          return a
        }
      }
    }
    var uo = '/*#__PURE__*/',
      xl = (t) => `${is[t]}: _${is[t]}`
    function Ky(
      t,
      {
        mode: e = 'function',
        prefixIdentifiers: s = e === 'module',
        sourceMap: i = !1,
        filename: r = 'template.vue.html',
        scopeId: n = null,
        optimizeImports: a = !1,
        runtimeGlobalName: o = 'Vue',
        runtimeModuleName: u = 'vue',
        ssrRuntimeModuleName: l = 'vue/server-renderer',
        ssr: c = !1,
        isTS: f = !1,
        inSSR: h = !1,
      }
    ) {
      let p = {
        mode: e,
        prefixIdentifiers: s,
        sourceMap: i,
        filename: r,
        scopeId: n,
        optimizeImports: a,
        runtimeGlobalName: o,
        runtimeModuleName: u,
        ssrRuntimeModuleName: l,
        ssr: c,
        isTS: f,
        inSSR: h,
        source: t.source,
        code: '',
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: !1,
        map: void 0,
        helper(x) {
          return `_${is[x]}`
        },
        push(x, C = -2, E) {
          if (((p.code += x), p.map)) {
            if (E) {
              let g
              if (E.type === 4 && !E.isStatic) {
                let S = E.content.replace(/^_ctx\./, '')
                S !== E.content && _i(S) && (g = S)
              }
              y(E.loc.start, g)
            }
            C === -3
              ? dp(p, x)
              : ((p.offset += x.length),
                C === -2
                  ? (p.column += x.length)
                  : (C === -1 && (C = x.length - 1),
                    p.line++,
                    (p.column = x.length - C))),
              E && E.loc !== bt && y(E.loc.end)
          }
        },
        indent() {
          m(++p.indentLevel)
        },
        deindent(x = !1) {
          x ? --p.indentLevel : m(--p.indentLevel)
        },
        newline() {
          m(p.indentLevel)
        },
      }
      function m(x) {
        p.push(
          `
` + '  '.repeat(x),
          0
        )
      }
      function y(x, C = null) {
        let { _names: E, _mappings: g } = p.map
        C !== null && !E.has(C) && E.add(C),
          g.add({
            originalLine: x.line,
            originalColumn: x.column - 1,
            generatedLine: p.line,
            generatedColumn: p.column - 1,
            source: r,
            name: C,
          })
      }
      return (
        i &&
          ((p.map = new vN.SourceMapGenerator()),
          p.map.setSourceContent(r, p.source),
          p.map._sources.add(r)),
        p
      )
    }
    function Xy(t, e = {}) {
      let s = Ky(t, e)
      e.onContextCreated && e.onContextCreated(s)
      let {
          mode: i,
          push: r,
          prefixIdentifiers: n,
          indent: a,
          deindent: o,
          newline: u,
          scopeId: l,
          ssr: c,
        } = s,
        f = Array.from(t.helpers),
        h = f.length > 0,
        p = !n && i !== 'module',
        m = l != null && i === 'module',
        y = !!e.inline,
        x = y ? Ky(t, e) : s
      i === 'module' ? dI(t, x, m, y) : pI(t, x)
      let C = c ? 'ssrRender' : 'render',
        E = c ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']
      e.bindingMetadata &&
        !e.inline &&
        E.push('$props', '$setup', '$data', '$options')
      let g = e.isTS ? E.map((S) => `${S}: any`).join(',') : E.join(', ')
      if (
        (r(y ? `(${g}) => {` : `function ${C}(${g}) {`),
        a(),
        p &&
          (r('with (_ctx) {'),
          a(),
          h &&
            (r(
              `const { ${f.map(xl).join(', ')} } = _Vue
`,
              -1
            ),
            u())),
        t.components.length &&
          (Ep(t.components, 'component', s),
          (t.directives.length || t.temps > 0) && u()),
        t.directives.length &&
          (Ep(t.directives, 'directive', s), t.temps > 0 && u()),
        t.filters && t.filters.length && (u(), Ep(t.filters, 'filter', s), u()),
        t.temps > 0)
      ) {
        r('let ')
        for (let S = 0; S < t.temps; S++) r(`${S > 0 ? ', ' : ''}_temp${S}`)
      }
      return (
        (t.components.length || t.directives.length || t.temps) &&
          (r(
            `
`,
            0
          ),
          u()),
        c || r('return '),
        t.codegenNode ? et(t.codegenNode, s) : r('null'),
        p && (o(), r('}')),
        o(),
        r('}'),
        {
          ast: t,
          code: s.code,
          preamble: y ? x.code : '',
          map: s.map ? s.map.toJSON() : void 0,
        }
      )
    }
    function pI(t, e) {
      let {
          ssr: s,
          prefixIdentifiers: i,
          push: r,
          newline: n,
          runtimeModuleName: a,
          runtimeGlobalName: o,
          ssrRuntimeModuleName: u,
        } = e,
        l = s ? `require(${JSON.stringify(a)})` : o,
        c = Array.from(t.helpers)
      if (c.length > 0) {
        if (i)
          r(
            `const { ${c.map(xl).join(', ')} } = ${l}
`,
            -1
          )
        else if (
          (r(
            `const _Vue = ${l}
`,
            -1
          ),
          t.hoists.length)
        ) {
          let f = [Ju, Yu, Kn, Qu, ep]
            .filter((h) => c.includes(h))
            .map(xl)
            .join(', ')
          r(
            `const { ${f} } = _Vue
`,
            -1
          )
        }
      }
      t.ssrHelpers &&
        t.ssrHelpers.length &&
        r(
          `const { ${t.ssrHelpers.map(xl).join(', ')} } = require("${u}")
`,
          -1
        ),
        Gy(t.hoists, e),
        n(),
        r('return ')
    }
    function dI(t, e, s, i) {
      let {
        push: r,
        newline: n,
        optimizeImports: a,
        runtimeModuleName: o,
        ssrRuntimeModuleName: u,
      } = e
      if (
        (s && t.hoists.length && (t.helpers.add(cl), t.helpers.add(fl)),
        t.helpers.size)
      ) {
        let l = Array.from(t.helpers)
        a
          ? (r(
              `import { ${l
                .map((c) => is[c])
                .join(', ')} } from ${JSON.stringify(o)}
`,
              -1
            ),
            r(
              `
// Binding optimization for webpack code-split
const ${l.map((c) => `_${is[c]} = ${is[c]}`).join(', ')}
`,
              -1
            ))
          : r(
              `import { ${l
                .map((c) => `${is[c]} as _${is[c]}`)
                .join(', ')} } from ${JSON.stringify(o)}
`,
              -1
            )
      }
      t.ssrHelpers &&
        t.ssrHelpers.length &&
        r(
          `import { ${t.ssrHelpers
            .map((l) => `${is[l]} as _${is[l]}`)
            .join(', ')} } from "${u}"
`,
          -1
        ),
        t.imports.length && (mI(t.imports, e), n()),
        Gy(t.hoists, e),
        n(),
        i || r('export ')
    }
    function Ep(t, e, { helper: s, push: i, newline: r, isTS: n }) {
      let a = s(e === 'filter' ? tl : e === 'component' ? Ya : el)
      for (let o = 0; o < t.length; o++) {
        let u = t[o],
          l = u.endsWith('__self')
        l && (u = u.slice(0, -6)),
          i(
            `const ${Yr(u, e)} = ${a}(${JSON.stringify(u)}${
              l ? ', true' : ''
            })${n ? '!' : ''}`
          ),
          o < t.length - 1 && r()
      }
    }
    function Gy(t, e) {
      if (!t.length) return
      e.pure = !0
      let { push: s, newline: i, helper: r, scopeId: n, mode: a } = e,
        o = n != null && a !== 'function'
      if ((i(), o)) {
        let u = e.isTS ? '(n: any)' : 'n'
        s(`const _withScopeId = ${u} => (${r(cl)}("${n}"),n=n(),${r(fl)}(),n)`),
          i()
      }
      for (let u = 0; u < t.length; u++) {
        let l = t[u]
        if (l) {
          let c = o && l.type === 13
          s(
            `const _hoisted_${u + 1} = ${c ? `${uo} _withScopeId(() => ` : ''}`
          ),
            et(l, e),
            c && s(')'),
            i()
        }
      }
      e.pure = !1
    }
    function mI(t, e) {
      !t.length ||
        t.forEach((s) => {
          e.push('import '),
            et(s.exp, e),
            e.push(` from '${s.path}'`),
            e.newline()
        })
    }
    function gI(t) {
      return (
        oe.isString(t) ||
        t.type === 4 ||
        t.type === 2 ||
        t.type === 5 ||
        t.type === 8
      )
    }
    function Al(t, e) {
      let s = t.length > 3 || t.some((i) => oe.isArray(i) || !gI(i))
      e.push('['), s && e.indent(), Yn(t, e, s), s && e.deindent(), e.push(']')
    }
    function Yn(t, e, s = !1, i = !0) {
      let { push: r, newline: n } = e
      for (let a = 0; a < t.length; a++) {
        let o = t[a]
        oe.isString(o) ? r(o, -3) : oe.isArray(o) ? Al(o, e) : et(o, e),
          a < t.length - 1 && (s ? (i && r(','), n()) : i && r(', '))
      }
    }
    function et(t, e) {
      if (oe.isString(t)) {
        e.push(t, -3)
        return
      }
      if (oe.isSymbol(t)) {
        e.push(e.helper(t))
        return
      }
      switch (t.type) {
        case 1:
        case 9:
        case 11:
          et(t.codegenNode, e)
          break
        case 2:
          yI(t, e)
          break
        case 4:
          Wy(t, e)
          break
        case 5:
          bI(t, e)
          break
        case 12:
          et(t.codegenNode, e)
          break
        case 8:
          zy(t, e)
          break
        case 3:
          SI(t, e)
          break
        case 13:
          TI(t, e)
          break
        case 14:
          xI(t, e)
          break
        case 15:
          AI(t, e)
          break
        case 17:
          PI(t, e)
          break
        case 18:
          CI(t, e)
          break
        case 19:
          vI(t, e)
          break
        case 20:
          NI(t, e)
          break
        case 21:
          Yn(t.body, e, !0, !1)
          break
        case 22:
          II(t, e)
          break
        case 23:
          Jy(t, e)
          break
        case 24:
          OI(t, e)
          break
        case 25:
          wI(t, e)
          break
        case 26:
          MI(t, e)
          break
      }
    }
    function yI(t, e) {
      e.push(JSON.stringify(t.content), -3, t)
    }
    function Wy(t, e) {
      let { content: s, isStatic: i } = t
      e.push(i ? JSON.stringify(s) : s, -3, t)
    }
    function bI(t, e) {
      let { push: s, helper: i, pure: r } = e
      r && s(uo), s(`${i(rl)}(`), et(t.content, e), s(')')
    }
    function zy(t, e) {
      for (let s = 0; s < t.children.length; s++) {
        let i = t.children[s]
        oe.isString(i) ? e.push(i, -3) : et(i, e)
      }
    }
    function EI(t, e) {
      let { push: s } = e
      if (t.type === 8) s('['), zy(t, e), s(']')
      else if (t.isStatic) {
        let i = _i(t.content) ? t.content : JSON.stringify(t.content)
        s(i, -2, t)
      } else s(`[${t.content}]`, -3, t)
    }
    function SI(t, e) {
      let { push: s, helper: i, pure: r } = e
      r && s(uo), s(`${i(Kn)}(${JSON.stringify(t.content)})`, -3, t)
    }
    function TI(t, e) {
      let { push: s, helper: i, pure: r } = e,
        {
          tag: n,
          props: a,
          children: o,
          patchFlag: u,
          dynamicProps: l,
          directives: c,
          isBlock: f,
          disableTracking: h,
          isComponent: p,
        } = t,
        m
      u && (m = String(u)),
        c && s(i(sl) + '('),
        f && s(`(${i(tr)}(${h ? 'true' : ''}), `),
        r && s(uo)
      let y = f ? zr(e.inSSR, p) : Wr(e.inSSR, p)
      s(i(y) + '(', -2, t),
        Yn(_I([n, a, o, m, l]), e),
        s(')'),
        f && s(')'),
        c && (s(', '), et(c, e), s(')'))
    }
    function _I(t) {
      let e = t.length
      for (; e-- && t[e] == null; );
      return t.slice(0, e + 1).map((s) => s || 'null')
    }
    function xI(t, e) {
      let { push: s, helper: i, pure: r } = e,
        n = oe.isString(t.callee) ? t.callee : i(t.callee)
      r && s(uo), s(n + '(', -2, t), Yn(t.arguments, e), s(')')
    }
    function AI(t, e) {
      let { push: s, indent: i, deindent: r, newline: n } = e,
        { properties: a } = t
      if (!a.length) {
        s('{}', -2, t)
        return
      }
      let o = a.length > 1 || a.some((u) => u.value.type !== 4)
      s(o ? '{' : '{ '), o && i()
      for (let u = 0; u < a.length; u++) {
        let { key: l, value: c } = a[u]
        EI(l, e), s(': '), et(c, e), u < a.length - 1 && (s(','), n())
      }
      o && r(), s(o ? '}' : ' }')
    }
    function PI(t, e) {
      Al(t.elements, e)
    }
    function CI(t, e) {
      let { push: s, indent: i, deindent: r } = e,
        { params: n, returns: a, body: o, newline: u, isSlot: l } = t
      l && s(`_${is[hl]}(`),
        s('(', -2, t),
        oe.isArray(n) ? Yn(n, e) : n && et(n, e),
        s(') => '),
        (u || o) && (s('{'), i()),
        a
          ? (u && s('return '), oe.isArray(a) ? Al(a, e) : et(a, e))
          : o && et(o, e),
        (u || o) && (r(), s('}')),
        l && (t.isNonScopedSlot && s(', undefined, true'), s(')'))
    }
    function vI(t, e) {
      let { test: s, consequent: i, alternate: r, newline: n } = t,
        { push: a, indent: o, deindent: u, newline: l } = e
      if (s.type === 4) {
        let f = !_i(s.content)
        f && a('('), Wy(s, e), f && a(')')
      } else a('('), et(s, e), a(')')
      n && o(),
        e.indentLevel++,
        n || a(' '),
        a('? '),
        et(i, e),
        e.indentLevel--,
        n && l(),
        n || a(' '),
        a(': ')
      let c = r.type === 19
      c || e.indentLevel++, et(r, e), c || e.indentLevel--, n && u(!0)
    }
    function NI(t, e) {
      let { push: s, helper: i, indent: r, deindent: n, newline: a } = e
      s(`_cache[${t.index}] || (`),
        t.isVOnce && (r(), s(`${i(Za)}(-1),`), a(), s('(')),
        s(`_cache[${t.index}] = `),
        et(t.value, e),
        t.isVOnce &&
          (s(`).cacheIndex = ${t.index},`),
          a(),
          s(`${i(Za)}(1),`),
          a(),
          s(`_cache[${t.index}]`),
          n()),
        s(')')
    }
    function II(t, e) {
      let { push: s, indent: i, deindent: r } = e
      s('`')
      let n = t.elements.length,
        a = n > 3
      for (let o = 0; o < n; o++) {
        let u = t.elements[o]
        oe.isString(u)
          ? s(u.replace(/(`|\$|\\)/g, '\\$1'), -3)
          : (s('${'), a && i(), et(u, e), a && r(), s('}'))
      }
      s('`')
    }
    function Jy(t, e) {
      let { push: s, indent: i, deindent: r } = e,
        { test: n, consequent: a, alternate: o } = t
      s('if ('),
        et(n, e),
        s(') {'),
        i(),
        et(a, e),
        r(),
        s('}'),
        o &&
          (s(' else '),
          o.type === 23 ? Jy(o, e) : (s('{'), i(), et(o, e), r(), s('}')))
    }
    function OI(t, e) {
      et(t.left, e), e.push(' = '), et(t.right, e)
    }
    function wI(t, e) {
      e.push('('), Yn(t.expressions, e), e.push(')')
    }
    function MI({ returns: t }, e) {
      e.push('return '), oe.isArray(t) ? Al(t, e) : et(t, e)
    }
    var RI = oe.makeMap('true,false,null,this'),
      Yy = (t, e) => {
        if (t.type === 5) t.content = $t(t.content, e)
        else if (t.type === 1)
          for (let s = 0; s < t.props.length; s++) {
            let i = t.props[s]
            if (i.type === 7 && i.name !== 'for') {
              let r = i.exp,
                n = i.arg
              r &&
                r.type === 4 &&
                !(i.name === 'on' && n) &&
                (i.exp = $t(r, e, i.name === 'slot')),
                n && n.type === 4 && !n.isStatic && (i.arg = $t(n, e))
            }
          }
      }
    function $t(t, e, s = !1, i = !1, r = Object.create(e.identifiers)) {
      if (!e.prefixIdentifiers || !t.content.trim()) return t
      let { inline: n, bindingMetadata: a } = e,
        o = (y, x, C) => {
          let E = oe.hasOwn(a, y) && a[y]
          if (n) {
            let g = x && x.type === 'AssignmentExpression' && x.left === C,
              S = x && x.type === 'UpdateExpression' && x.argument === C,
              _ = x && ap(x, f),
              I = x && Sy(f),
              k = (L) => {
                let N = `${e.helperString(eo)}(${L})`
                return I ? `(${N})` : N
              }
            if (Qy(E) || E === 'setup-reactive-const' || r[y]) return y
            if (E === 'setup-ref') return `${y}.value`
            if (E === 'setup-maybe-ref')
              return g || S || _ ? `${y}.value` : k(y)
            if (E === 'setup-let')
              if (g) {
                let { right: L, operator: N } = x,
                  O = u.slice(L.start - 1, L.end - 1),
                  v = Sp($t(Ae(O, !1), e, !1, !1, h))
                return `${e.helperString(to)}(${y})${
                  e.isTS
                    ? ` //@ts-ignore
`
                    : ''
                } ? ${y}.value ${N} ${v} : ${y}`
              } else if (S) {
                ;(C.start = x.start), (C.end = x.end)
                let { prefix: L, operator: N } = x,
                  O = L ? N : '',
                  v = L ? '' : N
                return `${e.helperString(to)}(${y})${
                  e.isTS
                    ? ` //@ts-ignore
`
                    : ''
                } ? ${O}${y}.value${v} : ${O}${y}${v}`
              } else return _ ? y : k(y)
            else {
              if (E === 'props') return oe.genPropsAccessExp(y)
              if (E === 'props-aliased')
                return oe.genPropsAccessExp(a.__propsAliases[y])
            }
          } else {
            if ((E && E.startsWith('setup')) || E === 'literal-const')
              return `$setup.${y}`
            if (E === 'props-aliased') return `$props['${a.__propsAliases[y]}']`
            if (E) return `$${E}.${y}`
          }
          return `_ctx.${y}`
        },
        u = t.content,
        l = t.ast
      if (l === !1) return t
      if (l === null || (!l && _i(u))) {
        let y = e.identifiers[u],
          x = oe.isGloballyAllowed(u),
          C = RI(u)
        return (
          !s && !y && !C && (!x || a[u])
            ? (Qy(a[u]) && (t.constType = 1), (t.content = o(u)))
            : y || (C ? (t.constType = 3) : (t.constType = 2)),
          t
        )
      }
      if (!l) {
        let y = i ? ` ${u} ` : `(${u})${s ? '=>{}' : ''}`
        try {
          l = za.parseExpression(y, {
            sourceType: 'module',
            plugins: e.expressionPlugins,
          })
        } catch (x) {
          return e.onError(Ge(45, t.loc, void 0, x.message)), t
        }
      }
      let c = [],
        f = [],
        h = Object.create(e.identifiers)
      by(
        l,
        (y, x, C, E, g) => {
          if (Py(y, x) || y.name.startsWith('_filter_')) return
          let S = E && LI(y)
          S && !g
            ? (up(x) && x.shorthand && (y.prefix = `${y.name}: `),
              (y.name = o(y.name, x, y)),
              c.push(y))
            : (!(S && g) &&
                (!x ||
                  (x.type !== 'CallExpression' &&
                    x.type !== 'NewExpression' &&
                    x.type !== 'MemberExpression')) &&
                (y.isConstant = !0),
              c.push(y))
        },
        !0,
        f,
        h
      )
      let p = []
      c.sort((y, x) => y.start - x.start),
        c.forEach((y, x) => {
          let C = y.start - 1,
            E = y.end - 1,
            g = c[x - 1],
            S = u.slice(g ? g.end - 1 : 0, C)
          ;(S.length || y.prefix) && p.push(S + (y.prefix || ''))
          let _ = u.slice(C, E)
          p.push(
            Ae(
              y.name,
              !1,
              {
                start: pp(t.loc.start, _, C),
                end: pp(t.loc.start, _, E),
                source: _,
              },
              y.isConstant ? 3 : 0
            )
          ),
            x === c.length - 1 && E < u.length && p.push(u.slice(E))
        })
      let m
      return (
        p.length
          ? ((m = ds(p, t.loc)), (m.ast = l))
          : ((m = t), (m.constType = 3)),
        (m.identifiers = Object.keys(h)),
        m
      )
    }
    function LI(t) {
      return !(oe.isGloballyAllowed(t.name) || t.name === 'require')
    }
    function Sp(t) {
      return oe.isString(t)
        ? t
        : t.type === 4
        ? t.content
        : t.children.map(Sp).join('')
    }
    function Qy(t) {
      return t === 'setup-const' || t === 'literal-const'
    }
    var kI = bp(/^(if|else|else-if)$/, (t, e, s) =>
      Zy(t, e, s, (i, r, n) => {
        let a = s.parent.children,
          o = a.indexOf(i),
          u = 0
        for (; o-- >= 0; ) {
          let l = a[o]
          l && l.type === 9 && (u += l.branches.length)
        }
        return () => {
          if (n) i.codegenNode = tb(r, u, s)
          else {
            let l = FI(i.codegenNode)
            l.alternate = tb(r, u + i.branches.length - 1, s)
          }
        }
      })
    )
    function Zy(t, e, s, i) {
      if (e.name !== 'else' && (!e.exp || !e.exp.content.trim())) {
        let r = e.exp ? e.exp.loc : t.loc
        s.onError(Ge(28, e.loc)), (e.exp = Ae('true', !1, r))
      }
      if (
        (s.prefixIdentifiers && e.exp && (e.exp = $t(e.exp, s)),
        e.name === 'if')
      ) {
        let r = eb(t, e),
          n = { type: 9, loc: t.loc, branches: [r] }
        if ((s.replaceNode(n), i)) return i(n, r, !0)
      } else {
        let r = s.parent.children,
          n = r.indexOf(t)
        for (; n-- >= -1; ) {
          let a = r[n]
          if (a && a.type === 3) {
            s.removeNode(a)
            continue
          }
          if (a && a.type === 2 && !a.content.trim().length) {
            s.removeNode(a)
            continue
          }
          if (a && a.type === 9) {
            e.name === 'else-if' &&
              a.branches[a.branches.length - 1].condition === void 0 &&
              s.onError(Ge(30, t.loc)),
              s.removeNode()
            let o = eb(t, e)
            {
              let l = o.userKey
              l &&
                a.branches.forEach(({ userKey: c }) => {
                  DI(c, l) && s.onError(Ge(29, o.userKey.loc))
                })
            }
            a.branches.push(o)
            let u = i && i(a, o, !1)
            oo(o, s), u && u(), (s.currentNode = null)
          } else s.onError(Ge(30, t.loc))
          break
        }
      }
    }
    function eb(t, e) {
      let s = t.tagType === 3
      return {
        type: 10,
        loc: t.loc,
        condition: e.name === 'else' ? void 0 : e.exp,
        children: s && !gs(t, 'for') ? t.children : [t],
        userKey: io(t, 'key'),
        isTemplateIf: s,
      }
    }
    function tb(t, e, s) {
      return t.condition
        ? dl(t.condition, sb(t, e, s), Rt(s.helper(Kn), ['""', 'true']))
        : sb(t, e, s)
    }
    function sb(t, e, s) {
      let { helper: i } = s,
        r = dt('key', Ae(`${e}`, !1, bt, 2)),
        { children: n } = t,
        a = n[0]
      if (n.length !== 1 || a.type !== 1)
        if (n.length === 1 && a.type === 11) {
          let u = a.codegenNode
          return no(u, r, s), u
        } else {
          let u = 64
          return (
            oe.PatchFlagNames[64],
            Wn(s, i(jn), ps([r]), n, u, void 0, void 0, !0, !1, !1, t.loc)
          )
        }
      else {
        let u = a.codegenNode,
          l = Iy(u)
        return l.type === 13 && ml(l, s), no(l, r, s), u
      }
    }
    function DI(t, e) {
      if (!t || t.type !== e.type) return !1
      if (t.type === 6) {
        if (t.value.content !== e.value.content) return !1
      } else {
        let s = t.exp,
          i = e.exp
        if (
          s.type !== i.type ||
          s.type !== 4 ||
          s.isStatic !== i.isStatic ||
          s.content !== i.content
        )
          return !1
      }
      return !0
    }
    function FI(t) {
      for (;;)
        if (t.type === 19)
          if (t.alternate.type === 19) t = t.alternate
          else return t
        else t.type === 20 && (t = t.value)
    }
    var ib = (t, e, s) => {
        let { modifiers: i, loc: r } = t,
          n = t.arg,
          { exp: a } = t
        if (a && a.type === 4 && !a.content.trim())
          return s.onError(Ge(34, r)), { props: [dt(n, Ae('', !0, r))] }
        if (!a) {
          if (n.type !== 4 || !n.isStatic)
            return s.onError(Ge(52, n.loc)), { props: [dt(n, Ae('', !0, r))] }
          rb(t, s), (a = t.exp)
        }
        return (
          n.type !== 4
            ? (n.children.unshift('('), n.children.push(') || ""'))
            : n.isStatic || (n.content = `${n.content} || ""`),
          i.includes('camel') &&
            (n.type === 4
              ? n.isStatic
                ? (n.content = oe.camelize(n.content))
                : (n.content = `${s.helperString(ul)}(${n.content})`)
              : (n.children.unshift(`${s.helperString(ul)}(`),
                n.children.push(')'))),
          s.inSSR ||
            (i.includes('prop') && nb(n, '.'),
            i.includes('attr') && nb(n, '^')),
          { props: [dt(n, a)] }
        )
      },
      rb = (t, e) => {
        let s = t.arg,
          i = oe.camelize(s.content)
        ;(t.exp = Ae(i, !1, s.loc)), (t.exp = $t(t.exp, e))
      },
      nb = (t, e) => {
        t.type === 4
          ? t.isStatic
            ? (t.content = e + t.content)
            : (t.content = `\`${e}\${${t.content}}\``)
          : (t.children.unshift(`'${e}' + (`), t.children.push(')'))
      },
      BI = bp('for', (t, e, s) => {
        let { helper: i, removeHelper: r } = s
        return ab(t, e, s, (n) => {
          let a = Rt(i(il), [n.source]),
            o = Jn(t),
            u = gs(t, 'memo'),
            l = io(t, 'key', !1, !0)
          l && l.type === 7 && !l.exp && rb(l, s)
          let c =
              l &&
              (l.type === 6
                ? l.value
                  ? Ae(l.value.content, !0)
                  : void 0
                : l.exp),
            f = l && c ? dt('key', c) : null
          o &&
            (u && (u.exp = $t(u.exp, s)),
            f && l.type !== 6 && (f.value = $t(f.value, s)))
          let h = n.source.type === 4 && n.source.constType > 0,
            p = h ? 64 : l ? 128 : 256
          return (
            (n.codegenNode = Wn(
              s,
              i(jn),
              void 0,
              a,
              p,
              void 0,
              void 0,
              !0,
              !h,
              !1,
              t.loc
            )),
            () => {
              let m,
                { children: y } = n
              o &&
                t.children.some((E) => {
                  if (E.type === 1) {
                    let g = io(E, 'key')
                    if (g) return s.onError(Ge(33, g.loc)), !0
                  }
                })
              let x = y.length !== 1 || y[0].type !== 1,
                C = ro(t)
                  ? t
                  : o && t.children.length === 1 && ro(t.children[0])
                  ? t.children[0]
                  : null
              if (
                (C
                  ? ((m = C.codegenNode), o && f && no(m, f, s))
                  : x
                  ? (m = Wn(
                      s,
                      i(jn),
                      f ? ps([f]) : void 0,
                      t.children,
                      64,
                      void 0,
                      void 0,
                      !0,
                      void 0,
                      !1
                    ))
                  : ((m = y[0].codegenNode),
                    o && f && no(m, f, s),
                    m.isBlock !== !h &&
                      (m.isBlock
                        ? (r(tr), r(zr(s.inSSR, m.isComponent)))
                        : r(Wr(s.inSSR, m.isComponent))),
                    (m.isBlock = !h),
                    m.isBlock
                      ? (i(tr), i(zr(s.inSSR, m.isComponent)))
                      : i(Wr(s.inSSR, m.isComponent))),
                u)
              ) {
                let E = Gr(Pl(n.parseResult, [Ae('_cached')]))
                ;(E.body = fy([
                  ds(['const _memo = (', u.exp, ')']),
                  ds([
                    'if (_cached',
                    ...(c ? [' && _cached.key === ', c] : []),
                    ` && ${s.helperString(ip)}(_cached, _memo)) return _cached`,
                  ]),
                  ds(['const _item = ', m]),
                  Ae('_item.memo = _memo'),
                  Ae('return _item'),
                ])),
                  a.arguments.push(E, Ae('_cache'), Ae(String(s.cached++)))
              } else a.arguments.push(Gr(Pl(n.parseResult), m, !0))
            }
          )
        })
      })
    function ab(t, e, s, i) {
      if (!e.exp) {
        s.onError(Ge(31, e.loc))
        return
      }
      let r = e.forParseResult
      if (!r) {
        s.onError(Ge(32, e.loc))
        return
      }
      Tp(r, s)
      let { addIdentifiers: n, removeIdentifiers: a, scopes: o } = s,
        { source: u, value: l, key: c, index: f } = r,
        h = {
          type: 11,
          loc: e.loc,
          source: u,
          valueAlias: l,
          keyAlias: c,
          objectIndexAlias: f,
          parseResult: r,
          children: Jn(t) ? t.children : [t],
        }
      s.replaceNode(h),
        o.vFor++,
        s.prefixIdentifiers && (l && n(l), c && n(c), f && n(f))
      let p = i && i(h)
      return () => {
        o.vFor--,
          s.prefixIdentifiers && (l && a(l), c && a(c), f && a(f)),
          p && p()
      }
    }
    function Tp(t, e) {
      t.finalized ||
        (e.prefixIdentifiers &&
          ((t.source = $t(t.source, e)),
          t.key && (t.key = $t(t.key, e, !0)),
          t.index && (t.index = $t(t.index, e, !0)),
          t.value && (t.value = $t(t.value, e, !0))),
        (t.finalized = !0))
    }
    function Pl({ value: t, key: e, index: s }, i = []) {
      return VI([t, e, s, ...i])
    }
    function VI(t) {
      let e = t.length
      for (; e-- && !t[e]; );
      return t.slice(0, e + 1).map((s, i) => s || Ae('_'.repeat(i + 1), !1))
    }
    var ob = Ae('undefined', !1),
      ub = (t, e) => {
        if (t.type === 1 && (t.tagType === 1 || t.tagType === 3)) {
          let s = gs(t, 'slot')
          if (s) {
            let i = s.exp
            return (
              e.prefixIdentifiers && i && e.addIdentifiers(i),
              e.scopes.vSlot++,
              () => {
                e.prefixIdentifiers && i && e.removeIdentifiers(i),
                  e.scopes.vSlot--
              }
            )
          }
        }
      },
      lb = (t, e) => {
        let s
        if (Jn(t) && t.props.some(mp) && (s = gs(t, 'for'))) {
          let i = s.forParseResult
          if (i) {
            Tp(i, e)
            let { value: r, key: n, index: a } = i,
              { addIdentifiers: o, removeIdentifiers: u } = e
            return (
              r && o(r),
              n && o(n),
              a && o(a),
              () => {
                r && u(r), n && u(n), a && u(a)
              }
            )
          }
        }
      },
      UI = (t, e, s, i) => Gr(t, s, !1, !0, s.length ? s[0].loc : i)
    function cb(t, e, s = UI) {
      e.helper(hl)
      let { children: i, loc: r } = t,
        n = [],
        a = [],
        o = e.scopes.vSlot > 0 || e.scopes.vFor > 0
      !e.ssr && e.prefixIdentifiers && (o = rs(t, e.identifiers))
      let u = gs(t, 'slot', !0)
      if (u) {
        let { arg: x, exp: C } = u
        x && !js(x) && (o = !0),
          n.push(dt(x || Ae('default', !0), s(C, void 0, i, r)))
      }
      let l = !1,
        c = !1,
        f = [],
        h = new Set(),
        p = 0
      for (let x = 0; x < i.length; x++) {
        let C = i[x],
          E
        if (!Jn(C) || !(E = gs(C, 'slot', !0))) {
          C.type !== 3 && f.push(C)
          continue
        }
        if (u) {
          e.onError(Ge(37, E.loc))
          break
        }
        l = !0
        let { children: g, loc: S } = C,
          { arg: _ = Ae('default', !0), exp: I, loc: k } = E,
          L
        js(_) ? (L = _ ? _.content : 'default') : (o = !0)
        let N = gs(C, 'for'),
          O = s(I, N, g, S),
          v,
          A
        if ((v = gs(C, 'if'))) (o = !0), a.push(dl(v.exp, Cl(_, O, p++), ob))
        else if ((A = gs(C, /^else(-if)?$/, !0))) {
          let V = x,
            se
          for (; V-- && ((se = i[V]), se.type === 3); );
          if (se && Jn(se) && gs(se, /^(else-)?if$/)) {
            let Y = a[a.length - 1]
            for (; Y.alternate.type === 19; ) Y = Y.alternate
            Y.alternate = A.exp ? dl(A.exp, Cl(_, O, p++), ob) : Cl(_, O, p++)
          } else e.onError(Ge(30, A.loc))
        } else if (N) {
          o = !0
          let V = N.forParseResult
          V
            ? (Tp(V, e),
              a.push(Rt(e.helper(il), [V.source, Gr(Pl(V), Cl(_, O), !0)])))
            : e.onError(Ge(32, N.loc))
        } else {
          if (L) {
            if (h.has(L)) {
              e.onError(Ge(38, k))
              continue
            }
            h.add(L), L === 'default' && (c = !0)
          }
          n.push(dt(_, O))
        }
      }
      if (!u) {
        let x = (C, E) => {
          let g = s(C, void 0, E, r)
          return e.compatConfig && (g.isNonScopedSlot = !0), dt('default', g)
        }
        l
          ? f.length &&
            f.some((C) => fb(C)) &&
            (c ? e.onError(Ge(39, f[0].loc)) : n.push(x(void 0, f)))
          : n.push(x(void 0, i))
      }
      let m = o ? 2 : vl(t.children) ? 3 : 1,
        y = ps(n.concat(dt('_', Ae(m + '', !1))), r)
      return (
        a.length && (y = Rt(e.helper(sp), [y, zn(a)])),
        { slots: y, hasDynamicSlots: o }
      )
    }
    function Cl(t, e, s) {
      let i = [dt('name', t), dt('fn', e)]
      return s != null && i.push(dt('key', Ae(String(s), !0))), ps(i)
    }
    function vl(t) {
      for (let e = 0; e < t.length; e++) {
        let s = t[e]
        switch (s.type) {
          case 1:
            if (s.tagType === 2 || vl(s.children)) return !0
            break
          case 9:
            if (vl(s.branches)) return !0
            break
          case 10:
          case 11:
            if (vl(s.children)) return !0
            break
        }
      }
      return !1
    }
    function fb(t) {
      return t.type !== 2 && t.type !== 12
        ? !0
        : t.type === 2
        ? !!t.content.trim()
        : fb(t.content)
    }
    var hb = new WeakMap(),
      pb = (t, e) =>
        function () {
          if (
            ((t = e.currentNode),
            !(t.type === 1 && (t.tagType === 0 || t.tagType === 1)))
          )
            return
          let { tag: i, props: r } = t,
            n = t.tagType === 1,
            a = n ? db(t, e) : `"${i}"`,
            o = oe.isObject(a) && a.callee === Zu,
            u,
            l,
            c = 0,
            f,
            h,
            p,
            m =
              o ||
              a === qn ||
              a === zu ||
              (!n && (i === 'svg' || i === 'foreignObject' || i === 'math'))
          if (r.length > 0) {
            let y = xp(t, e, void 0, n, o)
            ;(u = y.props), (c = y.patchFlag), (h = y.dynamicPropNames)
            let x = y.directives
            ;(p = x && x.length ? zn(x.map((C) => gb(C, e))) : void 0),
              y.shouldUseBlock && (m = !0)
          }
          if (t.children.length > 0)
            if (
              (a === Ja && ((m = !0), (c |= 1024)), n && a !== qn && a !== Ja)
            ) {
              let { slots: x, hasDynamicSlots: C } = cb(t, e)
              ;(l = x), C && (c |= 1024)
            } else if (t.children.length === 1 && a !== qn) {
              let x = t.children[0],
                C = x.type,
                E = C === 5 || C === 8
              E && Is(x, e) === 0 && (c |= 1),
                E || C === 2 ? (l = x) : (l = t.children)
            } else l = t.children
          h && h.length && (f = $I(h)),
            (t.codegenNode = Wn(
              e,
              a,
              u,
              l,
              c === 0 ? void 0 : c,
              f,
              p,
              !!m,
              !1,
              n,
              t.loc
            ))
        }
    function db(t, e, s = !1) {
      let { tag: i } = t,
        r = Ap(i),
        n = io(t, 'is', !1, !0)
      if (n)
        if (r || Jr('COMPILER_IS_ON_ELEMENT', e)) {
          let o
          if (
            (n.type === 6
              ? (o = n.value && Ae(n.value.content, !0))
              : ((o = n.exp),
                o || ((o = Ae('is', !1, n.loc)), (o = n.exp = $t(o, e)))),
            o)
          )
            return Rt(e.helper(Zu), [o])
        } else
          n.type === 6 &&
            n.value.content.startsWith('vue:') &&
            (i = n.value.content.slice(4))
      let a = fp(i) || e.isBuiltInComponent(i)
      if (a) return s || e.helper(a), a
      {
        let o = _p(i, e)
        if (o) return o
        let u = i.indexOf('.')
        if (u > 0) {
          let l = _p(i.slice(0, u), e)
          if (l) return l + i.slice(u)
        }
      }
      return e.selfName && oe.capitalize(oe.camelize(i)) === e.selfName
        ? (e.helper(Ya), e.components.add(i + '__self'), Yr(i, 'component'))
        : (e.helper(Ya), e.components.add(i), Yr(i, 'component'))
    }
    function _p(t, e) {
      let s = e.bindingMetadata
      if (!s || s.__isScriptSetup === !1) return
      let i = oe.camelize(t),
        r = oe.capitalize(i),
        n = (l) => {
          if (s[t] === l) return t
          if (s[i] === l) return i
          if (s[r] === l) return r
        },
        a = n('setup-const') || n('setup-reactive-const') || n('literal-const')
      if (a) return e.inline ? a : `$setup[${JSON.stringify(a)}]`
      let o = n('setup-let') || n('setup-ref') || n('setup-maybe-ref')
      if (o)
        return e.inline
          ? `${e.helperString(eo)}(${o})`
          : `$setup[${JSON.stringify(o)}]`
      let u = n('props')
      if (u)
        return `${e.helperString(eo)}(${
          e.inline ? '__props' : '$props'
        }[${JSON.stringify(u)}])`
    }
    function xp(t, e, s = t.props, i, r, n = !1) {
      let { tag: a, loc: o, children: u } = t,
        l = [],
        c = [],
        f = [],
        h = u.length > 0,
        p = !1,
        m = 0,
        y = !1,
        x = !1,
        C = !1,
        E = !1,
        g = !1,
        S = !1,
        _ = [],
        I = (O) => {
          l.length && (c.push(ps(mb(l), o)), (l = [])), O && c.push(O)
        },
        k = () => {
          e.scopes.vFor > 0 && l.push(dt(Ae('ref_for', !0), Ae('true')))
        },
        L = ({ key: O, value: v }) => {
          if (js(O)) {
            let A = O.content,
              V = oe.isOn(A)
            if (
              (V &&
                (!i || r) &&
                A.toLowerCase() !== 'onclick' &&
                A !== 'onUpdate:modelValue' &&
                !oe.isReservedProp(A) &&
                (E = !0),
              V && oe.isReservedProp(A) && (S = !0),
              V && v.type === 14 && (v = v.arguments[0]),
              v.type === 20 || ((v.type === 4 || v.type === 8) && Is(v, e) > 0))
            )
              return
            A === 'ref'
              ? (y = !0)
              : A === 'class'
              ? (x = !0)
              : A === 'style'
              ? (C = !0)
              : A !== 'key' && !_.includes(A) && _.push(A),
              i &&
                (A === 'class' || A === 'style') &&
                !_.includes(A) &&
                _.push(A)
          } else g = !0
        }
      for (let O = 0; O < s.length; O++) {
        let v = s[O]
        if (v.type === 6) {
          let { loc: A, name: V, nameLoc: se, value: Y } = v,
            q = !0
          if (V === 'ref' && ((y = !0), k(), Y && e.inline)) {
            let ee = e.bindingMetadata[Y.content]
            ;(ee === 'setup-let' ||
              ee === 'setup-ref' ||
              ee === 'setup-maybe-ref') &&
              ((q = !1),
              l.push(dt(Ae('ref_key', !0), Ae(Y.content, !0, Y.loc))))
          }
          if (
            V === 'is' &&
            (Ap(a) ||
              (Y && Y.content.startsWith('vue:')) ||
              Jr('COMPILER_IS_ON_ELEMENT', e))
          )
            continue
          l.push(dt(Ae(V, !0, se), Ae(Y ? Y.content : '', q, Y ? Y.loc : A)))
        } else {
          let { name: A, arg: V, exp: se, loc: Y, modifiers: q } = v,
            ee = A === 'bind',
            z = A === 'on'
          if (A === 'slot') {
            i || e.onError(Ge(40, Y))
            continue
          }
          if (
            A === 'once' ||
            A === 'memo' ||
            A === 'is' ||
            (ee && ir(V, 'is') && (Ap(a) || Jr('COMPILER_IS_ON_ELEMENT', e))) ||
            (z && n)
          )
            continue
          if (
            (((ee && ir(V, 'key')) || (z && h && ir(V, 'vue:before-update'))) &&
              (p = !0),
            ee && ir(V, 'ref') && k(),
            !V && (ee || z))
          ) {
            if (((g = !0), se))
              if (ee) {
                if ((k(), I(), Jr('COMPILER_V_BIND_OBJECT_ORDER', e))) {
                  c.unshift(se)
                  continue
                }
                c.push(se)
              } else
                I({
                  type: 14,
                  loc: Y,
                  callee: e.helper(ol),
                  arguments: i ? [se] : [se, 'true'],
                })
            else e.onError(Ge(ee ? 34 : 35, Y))
            continue
          }
          ee && q.includes('prop') && (m |= 32)
          let He = e.directiveTransforms[A]
          if (He) {
            let { props: St, needRuntime: Ze } = He(v, t, e)
            !n && St.forEach(L),
              z && V && !js(V) ? I(ps(St, o)) : l.push(...St),
              Ze && (f.push(v), oe.isSymbol(Ze) && hb.set(v, Ze))
          } else oe.isBuiltInDirective(A) || (f.push(v), h && (p = !0))
        }
      }
      let N
      if (
        (c.length
          ? (I(), c.length > 1 ? (N = Rt(e.helper(Qa), c, o)) : (N = c[0]))
          : l.length && (N = ps(mb(l), o)),
        g
          ? (m |= 16)
          : (x && !i && (m |= 2),
            C && !i && (m |= 4),
            _.length && (m |= 8),
            E && (m |= 32)),
        !p && (m === 0 || m === 32) && (y || S || f.length > 0) && (m |= 512),
        !e.inSSR && N)
      )
        switch (N.type) {
          case 15:
            let O = -1,
              v = -1,
              A = !1
            for (let Y = 0; Y < N.properties.length; Y++) {
              let q = N.properties[Y].key
              js(q)
                ? q.content === 'class'
                  ? (O = Y)
                  : q.content === 'style' && (v = Y)
                : q.isHandlerKey || (A = !0)
            }
            let V = N.properties[O],
              se = N.properties[v]
            A
              ? (N = Rt(e.helper(Xn), [N]))
              : (V && !js(V.value) && (V.value = Rt(e.helper(nl), [V.value])),
                se &&
                  (C ||
                    (se.value.type === 4 &&
                      se.value.content.trim()[0] === '[') ||
                    se.value.type === 17) &&
                  (se.value = Rt(e.helper(al), [se.value])))
            break
          case 14:
            break
          default:
            N = Rt(e.helper(Xn), [Rt(e.helper(Gn), [N])])
            break
        }
      return {
        props: N,
        directives: f,
        patchFlag: m,
        dynamicPropNames: _,
        shouldUseBlock: p,
      }
    }
    function mb(t) {
      let e = new Map(),
        s = []
      for (let i = 0; i < t.length; i++) {
        let r = t[i]
        if (r.key.type === 8 || !r.key.isStatic) {
          s.push(r)
          continue
        }
        let n = r.key.content,
          a = e.get(n)
        a
          ? (n === 'style' || n === 'class' || oe.isOn(n)) && HI(a, r)
          : (e.set(n, r), s.push(r))
      }
      return s
    }
    function HI(t, e) {
      t.value.type === 17
        ? t.value.elements.push(e.value)
        : (t.value = zn([t.value, e.value], t.loc))
    }
    function gb(t, e) {
      let s = [],
        i = hb.get(t)
      if (i) s.push(e.helperString(i))
      else {
        let n = _p('v-' + t.name, e)
        n
          ? s.push(n)
          : (e.helper(el),
            e.directives.add(t.name),
            s.push(Yr(t.name, 'directive')))
      }
      let { loc: r } = t
      if (
        (t.exp && s.push(t.exp),
        t.arg && (t.exp || s.push('void 0'), s.push(t.arg)),
        Object.keys(t.modifiers).length)
      ) {
        t.arg || (t.exp || s.push('void 0'), s.push('void 0'))
        let n = Ae('true', !1, r)
        s.push(
          ps(
            t.modifiers.map((a) => dt(a, n)),
            r
          )
        )
      }
      return zn(s, t.loc)
    }
    function $I(t) {
      let e = '['
      for (let s = 0, i = t.length; s < i; s++)
        (e += JSON.stringify(t[s])), s < i - 1 && (e += ', ')
      return e + ']'
    }
    function Ap(t) {
      return t === 'component' || t === 'Component'
    }
    var jI = (t, e) => {
      if (ro(t)) {
        let { children: s, loc: i } = t,
          { slotName: r, slotProps: n } = yb(t, e),
          a = [
            e.prefixIdentifiers ? '_ctx.$slots' : '$slots',
            r,
            '{}',
            'undefined',
            'true',
          ],
          o = 2
        n && ((a[2] = n), (o = 3)),
          s.length && ((a[3] = Gr([], s, !1, !1, i)), (o = 4)),
          e.scopeId && !e.slotted && (o = 5),
          a.splice(o),
          (t.codegenNode = Rt(e.helper(tp), a, i))
      }
    }
    function yb(t, e) {
      let s = '"default"',
        i,
        r = []
      for (let n = 0; n < t.props.length; n++) {
        let a = t.props[n]
        if (a.type === 6)
          a.value &&
            (a.name === 'name'
              ? (s = JSON.stringify(a.value.content))
              : ((a.name = oe.camelize(a.name)), r.push(a)))
        else if (a.name === 'bind' && ir(a.arg, 'name')) {
          if (a.exp) s = a.exp
          else if (a.arg && a.arg.type === 4) {
            let o = oe.camelize(a.arg.content)
            ;(s = a.exp = Ae(o, !1, a.arg.loc)), (s = a.exp = $t(a.exp, e))
          }
        } else
          a.name === 'bind' &&
            a.arg &&
            js(a.arg) &&
            (a.arg.content = oe.camelize(a.arg.content)),
            r.push(a)
      }
      if (r.length > 0) {
        let { props: n, directives: a } = xp(t, e, r, !1, !1)
        ;(i = n), a.length && e.onError(Ge(36, a[0].loc))
      }
      return { slotName: s, slotProps: i }
    }
    var qI =
        /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/,
      bb = (t, e, s, i) => {
        let { loc: r, modifiers: n, arg: a } = t
        !t.exp && !n.length && s.onError(Ge(35, r))
        let o
        if (a.type === 4)
          if (a.isStatic) {
            let f = a.content
            f.startsWith('vue:') && (f = `vnode-${f.slice(4)}`)
            let h =
              e.tagType !== 0 || f.startsWith('vnode') || !/[A-Z]/.test(f)
                ? oe.toHandlerKey(oe.camelize(f))
                : `on:${f}`
            o = Ae(h, !0, a.loc)
          } else o = ds([`${s.helperString(ll)}(`, a, ')'])
        else
          (o = a),
            o.children.unshift(`${s.helperString(ll)}(`),
            o.children.push(')')
        let u = t.exp
        u && !u.content.trim() && (u = void 0)
        let l = s.cacheHandlers && !u && !s.inVOnce
        if (u) {
          let f = hp(u.content, s),
            h = !(f || qI.test(u.content)),
            p = u.content.includes(';')
          s.prefixIdentifiers &&
            (h && s.addIdentifiers('$event'),
            (u = t.exp = $t(u, s, !1, p)),
            h && s.removeIdentifiers('$event'),
            (l =
              s.cacheHandlers &&
              !s.inVOnce &&
              !(u.type === 4 && u.constType > 0) &&
              !(f && e.tagType === 1) &&
              !rs(u, s.identifiers)),
            l &&
              f &&
              (u.type === 4
                ? (u.content = `${u.content} && ${u.content}(...args)`)
                : (u.children = [
                    ...u.children,
                    ' && ',
                    ...u.children,
                    '(...args)',
                  ]))),
            (h || (l && f)) &&
              (u = ds([
                `${
                  h
                    ? s.isTS
                      ? '($event: any)'
                      : '$event'
                    : `${
                        s.isTS
                          ? `
//@ts-ignore
`
                          : ''
                      }(...args)`
                } => ${p ? '{' : '('}`,
                u,
                p ? '}' : ')',
              ]))
        }
        let c = { props: [dt(o, u || Ae('() => {}', !1, r))] }
        return (
          i && (c = i(c)),
          l && (c.props[0].value = s.cache(c.props[0].value)),
          c.props.forEach((f) => (f.key.isHandlerKey = !0)),
          c
        )
      },
      KI = (t, e) => {
        if (t.type === 0 || t.type === 1 || t.type === 11 || t.type === 10)
          return () => {
            let s = t.children,
              i,
              r = !1
            for (let n = 0; n < s.length; n++) {
              let a = s[n]
              if (yl(a)) {
                r = !0
                for (let o = n + 1; o < s.length; o++) {
                  let u = s[o]
                  if (yl(u))
                    i || (i = s[n] = ds([a], a.loc)),
                      i.children.push(' + ', u),
                      s.splice(o, 1),
                      o--
                  else {
                    i = void 0
                    break
                  }
                }
              }
            }
            if (
              !(
                !r ||
                (s.length === 1 &&
                  (t.type === 0 ||
                    (t.type === 1 &&
                      t.tagType === 0 &&
                      !t.props.find(
                        (n) => n.type === 7 && !e.directiveTransforms[n.name]
                      ) &&
                      t.tag !== 'template')))
              )
            )
              for (let n = 0; n < s.length; n++) {
                let a = s[n]
                if (yl(a) || a.type === 8) {
                  let o = []
                  ;(a.type !== 2 || a.content !== ' ') && o.push(a),
                    !e.ssr && Is(a, e) === 0 && o.push(1 + ''),
                    (s[n] = {
                      type: 12,
                      content: a,
                      loc: a.loc,
                      codegenNode: Rt(e.helper(Qu), o),
                    })
                }
              }
          }
      },
      Eb = new WeakSet(),
      XI = (t, e) => {
        if (t.type === 1 && gs(t, 'once', !0))
          return Eb.has(t) || e.inVOnce || e.inSSR
            ? void 0
            : (Eb.add(t),
              (e.inVOnce = !0),
              e.helper(Za),
              () => {
                e.inVOnce = !1
                let s = e.currentNode
                s.codegenNode && (s.codegenNode = e.cache(s.codegenNode, !0))
              })
      },
      Sb = (t, e, s) => {
        let { exp: i, arg: r } = t
        if (!i) return s.onError(Ge(41, t.loc)), lo()
        let n = i.loc.source,
          a = i.type === 4 ? i.content : n,
          o = s.bindingMetadata[n]
        if (o === 'props' || o === 'props-aliased')
          return s.onError(Ge(44, i.loc)), lo()
        let u =
          s.inline &&
          (o === 'setup-let' || o === 'setup-ref' || o === 'setup-maybe-ref')
        if (!a.trim() || (!hp(a, s) && !u))
          return s.onError(Ge(42, i.loc)), lo()
        if (s.prefixIdentifiers && _i(a) && s.identifiers[a])
          return s.onError(Ge(43, i.loc)), lo()
        let l = r || Ae('modelValue', !0),
          c = r
            ? js(r)
              ? `onUpdate:${oe.camelize(r.content)}`
              : ds(['"onUpdate:" + ', r])
            : 'onUpdate:modelValue',
          f,
          h = s.isTS ? '($event: any)' : '$event'
        if (u)
          if (o === 'setup-ref')
            f = ds([`${h} => ((`, Ae(n, !1, i.loc), ').value = $event)'])
          else {
            let m = o === 'setup-let' ? `${n} = $event` : 'null'
            f = ds([
              `${h} => (${s.helperString(to)}(${n}) ? (`,
              Ae(n, !1, i.loc),
              `).value = $event : ${m})`,
            ])
          }
        else f = ds([`${h} => ((`, i, ') = $event)'])
        let p = [dt(l, t.exp), dt(c, f)]
        if (
          (s.prefixIdentifiers &&
            !s.inVOnce &&
            s.cacheHandlers &&
            !rs(i, s.identifiers) &&
            (p[1].value = s.cache(p[1].value)),
          t.modifiers.length && e.tagType === 1)
        ) {
          let m = t.modifiers
              .map((x) => (_i(x) ? x : JSON.stringify(x)) + ': true')
              .join(', '),
            y = r
              ? js(r)
                ? `${r.content}Modifiers`
                : ds([r, ' + "Modifiers"'])
              : 'modelModifiers'
          p.push(dt(y, Ae(`{ ${m} }`, !1, t.loc, 2)))
        }
        return lo(p)
      }
    function lo(t = []) {
      return { props: t }
    }
    var GI = /[\w).+\-_$\]]/,
      WI = (t, e) => {
        !Jr('COMPILER_FILTERS', e) ||
          (t.type === 5
            ? Nl(t.content, e)
            : t.type === 1 &&
              t.props.forEach((s) => {
                s.type === 7 && s.name !== 'for' && s.exp && Nl(s.exp, e)
              }))
      }
    function Nl(t, e) {
      if (t.type === 4) Tb(t, e)
      else
        for (let s = 0; s < t.children.length; s++) {
          let i = t.children[s]
          typeof i == 'object' &&
            (i.type === 4
              ? Tb(i, e)
              : i.type === 8
              ? Nl(t, e)
              : i.type === 5 && Nl(i.content, e))
        }
    }
    function Tb(t, e) {
      let s = t.content,
        i = !1,
        r = !1,
        n = !1,
        a = !1,
        o = 0,
        u = 0,
        l = 0,
        c = 0,
        f,
        h,
        p,
        m,
        y = []
      for (p = 0; p < s.length; p++)
        if (((h = f), (f = s.charCodeAt(p)), i))
          f === 39 && h !== 92 && (i = !1)
        else if (r) f === 34 && h !== 92 && (r = !1)
        else if (n) f === 96 && h !== 92 && (n = !1)
        else if (a) f === 47 && h !== 92 && (a = !1)
        else if (
          f === 124 &&
          s.charCodeAt(p + 1) !== 124 &&
          s.charCodeAt(p - 1) !== 124 &&
          !o &&
          !u &&
          !l
        )
          m === void 0 ? ((c = p + 1), (m = s.slice(0, p).trim())) : x()
        else {
          switch (f) {
            case 34:
              r = !0
              break
            case 39:
              i = !0
              break
            case 96:
              n = !0
              break
            case 40:
              l++
              break
            case 41:
              l--
              break
            case 91:
              u++
              break
            case 93:
              u--
              break
            case 123:
              o++
              break
            case 125:
              o--
              break
          }
          if (f === 47) {
            let C = p - 1,
              E
            for (; C >= 0 && ((E = s.charAt(C)), E === ' '); C--);
            ;(!E || !GI.test(E)) && (a = !0)
          }
        }
      m === void 0 ? (m = s.slice(0, p).trim()) : c !== 0 && x()
      function x() {
        y.push(s.slice(c, p).trim()), (c = p + 1)
      }
      if (y.length) {
        for (p = 0; p < y.length; p++) m = zI(m, y[p], e)
        ;(t.content = m), (t.ast = void 0)
      }
    }
    function zI(t, e, s) {
      s.helper(tl)
      let i = e.indexOf('(')
      if (i < 0) return s.filters.add(e), `${Yr(e, 'filter')}(${t})`
      {
        let r = e.slice(0, i),
          n = e.slice(i + 1)
        return (
          s.filters.add(r), `${Yr(r, 'filter')}(${t}${n !== ')' ? ',' + n : n}`
        )
      }
    }
    var _b = new WeakSet(),
      JI = (t, e) => {
        if (t.type === 1) {
          let s = gs(t, 'memo')
          return !s || _b.has(t)
            ? void 0
            : (_b.add(t),
              () => {
                let i = t.codegenNode || e.currentNode.codegenNode
                i &&
                  i.type === 13 &&
                  (t.tagType !== 1 && ml(i, e),
                  (t.codegenNode = Rt(e.helper(pl), [
                    s.exp,
                    Gr(void 0, i),
                    '_cache',
                    String(e.cached++),
                  ])))
              })
        }
      }
    function xb(t) {
      return [
        [XI, kI, JI, BI, WI, ...(t ? [lb, Yy] : []), jI, pb, ub, KI],
        { on: bb, bind: ib, model: Sb },
      ]
    }
    function YI(t, e = {}) {
      let s = e.onError || np,
        i = e.mode === 'module',
        r = e.prefixIdentifiers === !0 || i
      !r && e.cacheHandlers && s(Ge(49)), e.scopeId && !i && s(Ge(50))
      let n = oe.extend({}, e, { prefixIdentifiers: r }),
        a = oe.isString(t) ? By(t, n) : t,
        [o, u] = xb(r)
      if (e.isTS) {
        let { expressionPlugins: l } = e
        ;(!l || !l.includes('typescript')) &&
          (e.expressionPlugins = [...(l || []), 'typescript'])
      }
      return (
        qy(
          a,
          oe.extend({}, n, {
            nodeTransforms: [...o, ...(e.nodeTransforms || [])],
            directiveTransforms: oe.extend({}, u, e.directiveTransforms || {}),
          })
        ),
        Xy(a, n)
      )
    }
    var QI = {
        DATA: 'data',
        PROPS: 'props',
        PROPS_ALIASED: 'props-aliased',
        SETUP_LET: 'setup-let',
        SETUP_CONST: 'setup-const',
        SETUP_REACTIVE_CONST: 'setup-reactive-const',
        SETUP_MAYBE_REF: 'setup-maybe-ref',
        SETUP_REF: 'setup-ref',
        OPTIONS: 'options',
        LITERAL_CONST: 'literal-const',
      },
      ZI = () => ({ props: [] })
    G.generateCodeFrame = oe.generateCodeFrame
    G.BASE_TRANSITION = Yh
    G.BindingTypes = QI
    G.CAMELIZE = ul
    G.CAPITALIZE = uy
    G.CREATE_BLOCK = Qh
    G.CREATE_COMMENT = Kn
    G.CREATE_ELEMENT_BLOCK = Zh
    G.CREATE_ELEMENT_VNODE = Yu
    G.CREATE_SLOTS = sp
    G.CREATE_STATIC = ep
    G.CREATE_TEXT = Qu
    G.CREATE_VNODE = Ju
    G.CompilerDeprecationTypes = VN
    G.ConstantTypes = MN
    G.ElementTypes = wN
    G.ErrorCodes = $N
    G.FRAGMENT = jn
    G.GUARD_REACTIVE_PROPS = Gn
    G.IS_MEMO_SAME = ip
    G.IS_REF = to
    G.KEEP_ALIVE = Ja
    G.MERGE_PROPS = Qa
    G.NORMALIZE_CLASS = nl
    G.NORMALIZE_PROPS = Xn
    G.NORMALIZE_STYLE = al
    G.Namespaces = IN
    G.NodeTypes = ON
    G.OPEN_BLOCK = tr
    G.POP_SCOPE_ID = fl
    G.PUSH_SCOPE_ID = cl
    G.RENDER_LIST = il
    G.RENDER_SLOT = tp
    G.RESOLVE_COMPONENT = Ya
    G.RESOLVE_DIRECTIVE = el
    G.RESOLVE_DYNAMIC_COMPONENT = Zu
    G.RESOLVE_FILTER = tl
    G.SET_BLOCK_TRACKING = Za
    G.SUSPENSE = zu
    G.TELEPORT = qn
    G.TO_DISPLAY_STRING = rl
    G.TO_HANDLERS = ol
    G.TO_HANDLER_KEY = ll
    G.TS_NODE_TYPES = lp
    G.UNREF = eo
    G.WITH_CTX = hl
    G.WITH_DIRECTIVES = sl
    G.WITH_MEMO = pl
    G.advancePositionWithClone = pp
    G.advancePositionWithMutation = dp
    G.assert = zN
    G.baseCompile = YI
    G.baseParse = By
    G.buildDirectiveArgs = gb
    G.buildProps = xp
    G.buildSlots = cb
    G.checkCompatEnabled = so
    G.convertToBlock = ml
    G.createArrayExpression = zn
    G.createAssignmentExpression = DN
    G.createBlockStatement = fy
    G.createCacheExpression = cy
    G.createCallExpression = Rt
    G.createCompilerError = Ge
    G.createCompoundExpression = ds
    G.createConditionalExpression = dl
    G.createForLoopParams = Pl
    G.createFunctionExpression = Gr
    G.createIfStatement = kN
    G.createInterpolation = RN
    G.createObjectExpression = ps
    G.createObjectProperty = dt
    G.createReturnStatement = BN
    G.createRoot = ly
    G.createSequenceExpression = FN
    G.createSimpleExpression = Ae
    G.createStructuralDirectiveTransform = bp
    G.createTemplateLiteral = LN
    G.createTransformContext = jy
    G.createVNodeCall = Wn
    G.errorMessages = yy
    G.extractIdentifiers = Ti
    G.findDir = gs
    G.findProp = io
    G.forAliasRE = Oy
    G.generate = Xy
    G.getBaseTransformPreset = xb
    G.getConstantType = Is
    G.getMemoedVNodeCall = Iy
    G.getVNodeBlockHelper = zr
    G.getVNodeHelper = Wr
    G.hasDynamicKeyVBind = JN
    G.hasScopeRef = rs
    G.helperNameMap = is
    G.injectProp = no
    G.isCoreComponent = fp
    G.isFunctionType = Ay
    G.isInDestructureAssignment = ap
    G.isInNewExpression = Sy
    G.isMemberExpression = hp
    G.isMemberExpressionBrowser = WN
    G.isMemberExpressionNode = Cy
    G.isReferencedIdentifier = Ey
    G.isSimpleIdentifier = _i
    G.isSlotOutlet = ro
    G.isStaticArgOf = ir
    G.isStaticExp = js
    G.isStaticProperty = up
    G.isStaticPropertyKey = Py
    G.isTemplateNode = Jn
    G.isText = yl
    G.isVSlot = mp
    G.locStub = bt
    G.noopDirectiveTransform = ZI
    G.processExpression = $t
    G.processFor = ab
    G.processIf = Zy
    G.processSlotOutlet = yb
    G.registerRuntimeHelpers = NN
    G.resolveComponentType = db
    G.stringifyExpression = Sp
    G.toValidAssetId = Yr
    G.trackSlotScopes = ub
    G.trackVForSlotScopes = lb
    G.transform = qy
    G.transformBind = ib
    G.transformElement = pb
    G.transformExpression = Yy
    G.transformModel = Sb
    G.transformOn = bb
    G.traverseNode = oo
    G.unwrapTSNode = cp
    G.walkBlockDeclarations = _y
    G.walkFunctionParams = Ty
    G.walkIdentifiers = by
    G.warnDeprecation = HN
  })
  var HE = Oe((W) => {
    'use strict'
    Object.defineProperty(W, '__esModule', { value: !0 })
    var re = fs(),
      en = dh(),
      co = Dh(),
      e6 = Fh(),
      t6 = Jh(),
      Qn = Symbol('Fragment'),
      Zn = Symbol('Teleport'),
      Il = Symbol('Suspense'),
      fo = Symbol('KeepAlive'),
      Pp = Symbol('BaseTransition'),
      nr = Symbol('openBlock'),
      Cp = Symbol('createBlock'),
      vp = Symbol('createElementBlock'),
      Ol = Symbol('createVNode'),
      wl = Symbol('createElementVNode'),
      ea = Symbol('createCommentVNode'),
      Ml = Symbol('createTextVNode'),
      Np = Symbol('createStaticVNode'),
      ho = Symbol('resolveComponent'),
      Rl = Symbol('resolveDynamicComponent'),
      Ll = Symbol('resolveDirective'),
      kl = Symbol('resolveFilter'),
      Dl = Symbol('withDirectives'),
      Fl = Symbol('renderList'),
      Ip = Symbol('renderSlot'),
      Op = Symbol('createSlots'),
      Bl = Symbol('toDisplayString'),
      po = Symbol('mergeProps'),
      Vl = Symbol('normalizeClass'),
      Ul = Symbol('normalizeStyle'),
      ta = Symbol('normalizeProps'),
      sa = Symbol('guardReactiveProps'),
      Hl = Symbol('toHandlers'),
      $l = Symbol('camelize'),
      Pb = Symbol('capitalize'),
      jl = Symbol('toHandlerKey'),
      mo = Symbol('setBlockTracking'),
      ql = Symbol('pushScopeId'),
      Kl = Symbol('popScopeId'),
      Xl = Symbol('withCtx'),
      go = Symbol('unref'),
      yo = Symbol('isRef'),
      Gl = Symbol('withMemo'),
      wp = Symbol('isMemoSame'),
      ns = {
        [Qn]: 'Fragment',
        [Zn]: 'Teleport',
        [Il]: 'Suspense',
        [fo]: 'KeepAlive',
        [Pp]: 'BaseTransition',
        [nr]: 'openBlock',
        [Cp]: 'createBlock',
        [vp]: 'createElementBlock',
        [Ol]: 'createVNode',
        [wl]: 'createElementVNode',
        [ea]: 'createCommentVNode',
        [Ml]: 'createTextVNode',
        [Np]: 'createStaticVNode',
        [ho]: 'resolveComponent',
        [Rl]: 'resolveDynamicComponent',
        [Ll]: 'resolveDirective',
        [kl]: 'resolveFilter',
        [Dl]: 'withDirectives',
        [Fl]: 'renderList',
        [Ip]: 'renderSlot',
        [Op]: 'createSlots',
        [Bl]: 'toDisplayString',
        [po]: 'mergeProps',
        [Vl]: 'normalizeClass',
        [Ul]: 'normalizeStyle',
        [ta]: 'normalizeProps',
        [sa]: 'guardReactiveProps',
        [Hl]: 'toHandlers',
        [$l]: 'camelize',
        [Pb]: 'capitalize',
        [jl]: 'toHandlerKey',
        [mo]: 'setBlockTracking',
        [ql]: 'pushScopeId',
        [Kl]: 'popScopeId',
        [Xl]: 'withCtx',
        [go]: 'unref',
        [yo]: 'isRef',
        [Gl]: 'withMemo',
        [wp]: 'isMemoSame',
      }
    function s6(t) {
      Object.getOwnPropertySymbols(t).forEach((e) => {
        ns[e] = t[e]
      })
    }
    var i6 = { HTML: 0, 0: 'HTML', SVG: 1, 1: 'SVG', MATH_ML: 2, 2: 'MATH_ML' },
      r6 = {
        ROOT: 0,
        0: 'ROOT',
        ELEMENT: 1,
        1: 'ELEMENT',
        TEXT: 2,
        2: 'TEXT',
        COMMENT: 3,
        3: 'COMMENT',
        SIMPLE_EXPRESSION: 4,
        4: 'SIMPLE_EXPRESSION',
        INTERPOLATION: 5,
        5: 'INTERPOLATION',
        ATTRIBUTE: 6,
        6: 'ATTRIBUTE',
        DIRECTIVE: 7,
        7: 'DIRECTIVE',
        COMPOUND_EXPRESSION: 8,
        8: 'COMPOUND_EXPRESSION',
        IF: 9,
        9: 'IF',
        IF_BRANCH: 10,
        10: 'IF_BRANCH',
        FOR: 11,
        11: 'FOR',
        TEXT_CALL: 12,
        12: 'TEXT_CALL',
        VNODE_CALL: 13,
        13: 'VNODE_CALL',
        JS_CALL_EXPRESSION: 14,
        14: 'JS_CALL_EXPRESSION',
        JS_OBJECT_EXPRESSION: 15,
        15: 'JS_OBJECT_EXPRESSION',
        JS_PROPERTY: 16,
        16: 'JS_PROPERTY',
        JS_ARRAY_EXPRESSION: 17,
        17: 'JS_ARRAY_EXPRESSION',
        JS_FUNCTION_EXPRESSION: 18,
        18: 'JS_FUNCTION_EXPRESSION',
        JS_CONDITIONAL_EXPRESSION: 19,
        19: 'JS_CONDITIONAL_EXPRESSION',
        JS_CACHE_EXPRESSION: 20,
        20: 'JS_CACHE_EXPRESSION',
        JS_BLOCK_STATEMENT: 21,
        21: 'JS_BLOCK_STATEMENT',
        JS_TEMPLATE_LITERAL: 22,
        22: 'JS_TEMPLATE_LITERAL',
        JS_IF_STATEMENT: 23,
        23: 'JS_IF_STATEMENT',
        JS_ASSIGNMENT_EXPRESSION: 24,
        24: 'JS_ASSIGNMENT_EXPRESSION',
        JS_SEQUENCE_EXPRESSION: 25,
        25: 'JS_SEQUENCE_EXPRESSION',
        JS_RETURN_STATEMENT: 26,
        26: 'JS_RETURN_STATEMENT',
      },
      n6 = {
        ELEMENT: 0,
        0: 'ELEMENT',
        COMPONENT: 1,
        1: 'COMPONENT',
        SLOT: 2,
        2: 'SLOT',
        TEMPLATE: 3,
        3: 'TEMPLATE',
      },
      a6 = {
        NOT_CONSTANT: 0,
        0: 'NOT_CONSTANT',
        CAN_SKIP_PATCH: 1,
        1: 'CAN_SKIP_PATCH',
        CAN_HOIST: 2,
        2: 'CAN_HOIST',
        CAN_STRINGIFY: 3,
        3: 'CAN_STRINGIFY',
      },
      Et = {
        start: { line: 1, column: 1, offset: 0 },
        end: { line: 1, column: 1, offset: 0 },
        source: '',
      }
    function Cb(t, e = '') {
      return {
        type: 0,
        source: e,
        children: t,
        helpers: new Set(),
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: void 0,
        loc: Et,
      }
    }
    function ia(t, e, s, i, r, n, a, o = !1, u = !1, l = !1, c = Et) {
      return (
        t &&
          (o
            ? (t.helper(nr), t.helper(rn(t.inSSR, l)))
            : t.helper(sn(t.inSSR, l)),
          a && t.helper(Dl)),
        {
          type: 13,
          tag: e,
          props: s,
          children: i,
          patchFlag: r,
          dynamicProps: n,
          directives: a,
          isBlock: o,
          disableTracking: u,
          isComponent: l,
          loc: c,
        }
      )
    }
    function ra(t, e = Et) {
      return { type: 17, loc: e, elements: t }
    }
    function ys(t, e = Et) {
      return { type: 15, loc: e, properties: t }
    }
    function mt(t, e) {
      return {
        type: 16,
        loc: Et,
        key: re.isString(t) ? Pe(t, !0) : t,
        value: e,
      }
    }
    function Pe(t, e = !1, s = Et, i = 0) {
      return { type: 4, loc: s, content: t, isStatic: e, constType: e ? 3 : i }
    }
    function o6(t, e) {
      return { type: 5, loc: e, content: re.isString(t) ? Pe(t, !1, e) : t }
    }
    function bs(t, e = Et) {
      return { type: 8, loc: e, children: t }
    }
    function Dt(t, e = [], s = Et) {
      return { type: 14, loc: s, callee: t, arguments: e }
    }
    function tn(t, e = void 0, s = !1, i = !1, r = Et) {
      return { type: 18, params: t, returns: e, newline: s, isSlot: i, loc: r }
    }
    function Wl(t, e, s, i = !0) {
      return {
        type: 19,
        test: t,
        consequent: e,
        alternate: s,
        newline: i,
        loc: Et,
      }
    }
    function vb(t, e, s = !1) {
      return { type: 20, index: t, value: e, isVOnce: s, loc: Et }
    }
    function Nb(t) {
      return { type: 21, body: t, loc: Et }
    }
    function u6(t) {
      return { type: 22, elements: t, loc: Et }
    }
    function l6(t, e, s) {
      return { type: 23, test: t, consequent: e, alternate: s, loc: Et }
    }
    function c6(t, e) {
      return { type: 24, left: t, right: e, loc: Et }
    }
    function f6(t) {
      return { type: 25, expressions: t, loc: Et }
    }
    function h6(t) {
      return { type: 26, returns: t, loc: Et }
    }
    function sn(t, e) {
      return t || e ? Ol : wl
    }
    function rn(t, e) {
      return t || e ? Cp : vp
    }
    function zl(t, { helper: e, removeHelper: s, inSSR: i }) {
      t.isBlock ||
        ((t.isBlock = !0),
        s(sn(i, t.isComponent)),
        e(nr),
        e(rn(i, t.isComponent)))
    }
    var Ib = new Uint8Array([123, 123]),
      Ob = new Uint8Array([125, 125])
    function wb(t) {
      return (t >= 97 && t <= 122) || (t >= 65 && t <= 90)
    }
    function Es(t) {
      return t === 32 || t === 10 || t === 9 || t === 12 || t === 13
    }
    function ar(t) {
      return t === 47 || t === 62 || Es(t)
    }
    function Jl(t) {
      let e = new Uint8Array(t.length)
      for (let s = 0; s < t.length; s++) e[s] = t.charCodeAt(s)
      return e
    }
    var Ft = {
        Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
        CdataEnd: new Uint8Array([93, 93, 62]),
        CommentEnd: new Uint8Array([45, 45, 62]),
        ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
        StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
        TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
        TextareaEnd: new Uint8Array([
          60, 47, 116, 101, 120, 116, 97, 114, 101, 97,
        ]),
      },
      Mb = class {
        constructor(e, s) {
          ;(this.stack = e),
            (this.cbs = s),
            (this.state = 1),
            (this.buffer = ''),
            (this.sectionStart = 0),
            (this.index = 0),
            (this.entityStart = 0),
            (this.baseState = 1),
            (this.inRCDATA = !1),
            (this.inXML = !1),
            (this.inVPre = !1),
            (this.newlines = []),
            (this.mode = 0),
            (this.delimiterOpen = Ib),
            (this.delimiterClose = Ob),
            (this.delimiterIndex = -1),
            (this.currentSequence = void 0),
            (this.sequenceIndex = 0),
            (this.entityDecoder = new en.EntityDecoder(
              en.htmlDecodeTree,
              (i, r) => this.emitCodePoint(i, r)
            ))
        }
        get inSFCRoot() {
          return this.mode === 2 && this.stack.length === 0
        }
        reset() {
          ;(this.state = 1),
            (this.mode = 0),
            (this.buffer = ''),
            (this.sectionStart = 0),
            (this.index = 0),
            (this.baseState = 1),
            (this.inRCDATA = !1),
            (this.currentSequence = void 0),
            (this.newlines.length = 0),
            (this.delimiterOpen = Ib),
            (this.delimiterClose = Ob)
        }
        getPos(e) {
          let s = 1,
            i = e + 1
          for (let r = this.newlines.length - 1; r >= 0; r--) {
            let n = this.newlines[r]
            if (e > n) {
              ;(s = r + 2), (i = e - n)
              break
            }
          }
          return { column: i, line: s, offset: e }
        }
        peek() {
          return this.buffer.charCodeAt(this.index + 1)
        }
        stateText(e) {
          e === 60
            ? (this.index > this.sectionStart &&
                this.cbs.ontext(this.sectionStart, this.index),
              (this.state = 5),
              (this.sectionStart = this.index))
            : e === 38
            ? this.startEntity()
            : !this.inVPre &&
              e === this.delimiterOpen[0] &&
              ((this.state = 2),
              (this.delimiterIndex = 0),
              this.stateInterpolationOpen(e))
        }
        stateInterpolationOpen(e) {
          if (e === this.delimiterOpen[this.delimiterIndex])
            if (this.delimiterIndex === this.delimiterOpen.length - 1) {
              let s = this.index + 1 - this.delimiterOpen.length
              s > this.sectionStart && this.cbs.ontext(this.sectionStart, s),
                (this.state = 3),
                (this.sectionStart = s)
            } else this.delimiterIndex++
          else
            this.inRCDATA
              ? ((this.state = 32), this.stateInRCDATA(e))
              : ((this.state = 1), this.stateText(e))
        }
        stateInterpolation(e) {
          e === this.delimiterClose[0] &&
            ((this.state = 4),
            (this.delimiterIndex = 0),
            this.stateInterpolationClose(e))
        }
        stateInterpolationClose(e) {
          e === this.delimiterClose[this.delimiterIndex]
            ? this.delimiterIndex === this.delimiterClose.length - 1
              ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1),
                this.inRCDATA ? (this.state = 32) : (this.state = 1),
                (this.sectionStart = this.index + 1))
              : this.delimiterIndex++
            : ((this.state = 3), this.stateInterpolation(e))
        }
        stateSpecialStartSequence(e) {
          let s = this.sequenceIndex === this.currentSequence.length
          if (
            !(s ? ar(e) : (e | 32) === this.currentSequence[this.sequenceIndex])
          )
            this.inRCDATA = !1
          else if (!s) {
            this.sequenceIndex++
            return
          }
          ;(this.sequenceIndex = 0), (this.state = 6), this.stateInTagName(e)
        }
        stateInRCDATA(e) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (e === 62 || Es(e)) {
              let s = this.index - this.currentSequence.length
              if (this.sectionStart < s) {
                let i = this.index
                ;(this.index = s),
                  this.cbs.ontext(this.sectionStart, s),
                  (this.index = i)
              }
              ;(this.sectionStart = s + 2),
                this.stateInClosingTagName(e),
                (this.inRCDATA = !1)
              return
            }
            this.sequenceIndex = 0
          }
          ;(e | 32) === this.currentSequence[this.sequenceIndex]
            ? (this.sequenceIndex += 1)
            : this.sequenceIndex === 0
            ? this.currentSequence === Ft.TitleEnd ||
              (this.currentSequence === Ft.TextareaEnd && !this.inSFCRoot)
              ? e === 38
                ? this.startEntity()
                : e === this.delimiterOpen[0] &&
                  ((this.state = 2),
                  (this.delimiterIndex = 0),
                  this.stateInterpolationOpen(e))
              : this.fastForwardTo(60) && (this.sequenceIndex = 1)
            : (this.sequenceIndex = Number(e === 60))
        }
        stateCDATASequence(e) {
          e === Ft.Cdata[this.sequenceIndex]
            ? ++this.sequenceIndex === Ft.Cdata.length &&
              ((this.state = 28),
              (this.currentSequence = Ft.CdataEnd),
              (this.sequenceIndex = 0),
              (this.sectionStart = this.index + 1))
            : ((this.sequenceIndex = 0),
              (this.state = 23),
              this.stateInDeclaration(e))
        }
        fastForwardTo(e) {
          for (; ++this.index < this.buffer.length; ) {
            let s = this.buffer.charCodeAt(this.index)
            if ((s === 10 && this.newlines.push(this.index), s === e)) return !0
          }
          return (this.index = this.buffer.length - 1), !1
        }
        stateInCommentLike(e) {
          e === this.currentSequence[this.sequenceIndex]
            ? ++this.sequenceIndex === this.currentSequence.length &&
              (this.currentSequence === Ft.CdataEnd
                ? this.cbs.oncdata(this.sectionStart, this.index - 2)
                : this.cbs.oncomment(this.sectionStart, this.index - 2),
              (this.sequenceIndex = 0),
              (this.sectionStart = this.index + 1),
              (this.state = 1))
            : this.sequenceIndex === 0
            ? this.fastForwardTo(this.currentSequence[0]) &&
              (this.sequenceIndex = 1)
            : e !== this.currentSequence[this.sequenceIndex - 1] &&
              (this.sequenceIndex = 0)
        }
        startSpecial(e, s) {
          this.enterRCDATA(e, s), (this.state = 31)
        }
        enterRCDATA(e, s) {
          ;(this.inRCDATA = !0),
            (this.currentSequence = e),
            (this.sequenceIndex = s)
        }
        stateBeforeTagName(e) {
          e === 33
            ? ((this.state = 22), (this.sectionStart = this.index + 1))
            : e === 63
            ? ((this.state = 24), (this.sectionStart = this.index + 1))
            : wb(e)
            ? ((this.sectionStart = this.index),
              this.mode === 0
                ? (this.state = 6)
                : this.inSFCRoot
                ? (this.state = 34)
                : this.inXML
                ? (this.state = 6)
                : e === 116
                ? (this.state = 30)
                : (this.state = e === 115 ? 29 : 6))
            : e === 47
            ? (this.state = 8)
            : ((this.state = 1), this.stateText(e))
        }
        stateInTagName(e) {
          ar(e) && this.handleTagName(e)
        }
        stateInSFCRootTagName(e) {
          if (ar(e)) {
            let s = this.buffer.slice(this.sectionStart, this.index)
            s !== 'template' && this.enterRCDATA(Jl('</' + s), 0),
              this.handleTagName(e)
          }
        }
        handleTagName(e) {
          this.cbs.onopentagname(this.sectionStart, this.index),
            (this.sectionStart = -1),
            (this.state = 11),
            this.stateBeforeAttrName(e)
        }
        stateBeforeClosingTagName(e) {
          Es(e) ||
            (e === 62
              ? (this.cbs.onerr(14, this.index),
                (this.state = 1),
                (this.sectionStart = this.index + 1))
              : ((this.state = wb(e) ? 9 : 27),
                (this.sectionStart = this.index)))
        }
        stateInClosingTagName(e) {
          ;(e === 62 || Es(e)) &&
            (this.cbs.onclosetag(this.sectionStart, this.index),
            (this.sectionStart = -1),
            (this.state = 10),
            this.stateAfterClosingTagName(e))
        }
        stateAfterClosingTagName(e) {
          e === 62 && ((this.state = 1), (this.sectionStart = this.index + 1))
        }
        stateBeforeAttrName(e) {
          e === 62
            ? (this.cbs.onopentagend(this.index),
              this.inRCDATA ? (this.state = 32) : (this.state = 1),
              (this.sectionStart = this.index + 1))
            : e === 47
            ? ((this.state = 7),
              this.peek() !== 62 && this.cbs.onerr(22, this.index))
            : e === 60 && this.peek() === 47
            ? (this.cbs.onopentagend(this.index),
              (this.state = 5),
              (this.sectionStart = this.index))
            : Es(e) ||
              (e === 61 && this.cbs.onerr(19, this.index),
              this.handleAttrStart(e))
        }
        handleAttrStart(e) {
          e === 118 && this.peek() === 45
            ? ((this.state = 13), (this.sectionStart = this.index))
            : e === 46 || e === 58 || e === 64 || e === 35
            ? (this.cbs.ondirname(this.index, this.index + 1),
              (this.state = 14),
              (this.sectionStart = this.index + 1))
            : ((this.state = 12), (this.sectionStart = this.index))
        }
        stateInSelfClosingTag(e) {
          e === 62
            ? (this.cbs.onselfclosingtag(this.index),
              (this.state = 1),
              (this.sectionStart = this.index + 1),
              (this.inRCDATA = !1))
            : Es(e) || ((this.state = 11), this.stateBeforeAttrName(e))
        }
        stateInAttrName(e) {
          e === 61 || ar(e)
            ? (this.cbs.onattribname(this.sectionStart, this.index),
              this.handleAttrNameEnd(e))
            : (e === 34 || e === 39 || e === 60) &&
              this.cbs.onerr(17, this.index)
        }
        stateInDirName(e) {
          e === 61 || ar(e)
            ? (this.cbs.ondirname(this.sectionStart, this.index),
              this.handleAttrNameEnd(e))
            : e === 58
            ? (this.cbs.ondirname(this.sectionStart, this.index),
              (this.state = 14),
              (this.sectionStart = this.index + 1))
            : e === 46 &&
              (this.cbs.ondirname(this.sectionStart, this.index),
              (this.state = 16),
              (this.sectionStart = this.index + 1))
        }
        stateInDirArg(e) {
          e === 61 || ar(e)
            ? (this.cbs.ondirarg(this.sectionStart, this.index),
              this.handleAttrNameEnd(e))
            : e === 91
            ? (this.state = 15)
            : e === 46 &&
              (this.cbs.ondirarg(this.sectionStart, this.index),
              (this.state = 16),
              (this.sectionStart = this.index + 1))
        }
        stateInDynamicDirArg(e) {
          e === 93
            ? (this.state = 14)
            : (e === 61 || ar(e)) &&
              (this.cbs.ondirarg(this.sectionStart, this.index + 1),
              this.handleAttrNameEnd(e),
              this.cbs.onerr(27, this.index))
        }
        stateInDirModifier(e) {
          e === 61 || ar(e)
            ? (this.cbs.ondirmodifier(this.sectionStart, this.index),
              this.handleAttrNameEnd(e))
            : e === 46 &&
              (this.cbs.ondirmodifier(this.sectionStart, this.index),
              (this.sectionStart = this.index + 1))
        }
        handleAttrNameEnd(e) {
          ;(this.sectionStart = this.index),
            (this.state = 17),
            this.cbs.onattribnameend(this.index),
            this.stateAfterAttrName(e)
        }
        stateAfterAttrName(e) {
          e === 61
            ? (this.state = 18)
            : e === 47 || e === 62
            ? (this.cbs.onattribend(0, this.sectionStart),
              (this.sectionStart = -1),
              (this.state = 11),
              this.stateBeforeAttrName(e))
            : Es(e) ||
              (this.cbs.onattribend(0, this.sectionStart),
              this.handleAttrStart(e))
        }
        stateBeforeAttrValue(e) {
          e === 34
            ? ((this.state = 19), (this.sectionStart = this.index + 1))
            : e === 39
            ? ((this.state = 20), (this.sectionStart = this.index + 1))
            : Es(e) ||
              ((this.sectionStart = this.index),
              (this.state = 21),
              this.stateInAttrValueNoQuotes(e))
        }
        handleInAttrValue(e, s) {
          e === s
            ? (this.cbs.onattribdata(this.sectionStart, this.index),
              (this.sectionStart = -1),
              this.cbs.onattribend(s === 34 ? 3 : 2, this.index + 1),
              (this.state = 11))
            : e === 38 && this.startEntity()
        }
        stateInAttrValueDoubleQuotes(e) {
          this.handleInAttrValue(e, 34)
        }
        stateInAttrValueSingleQuotes(e) {
          this.handleInAttrValue(e, 39)
        }
        stateInAttrValueNoQuotes(e) {
          Es(e) || e === 62
            ? (this.cbs.onattribdata(this.sectionStart, this.index),
              (this.sectionStart = -1),
              this.cbs.onattribend(1, this.index),
              (this.state = 11),
              this.stateBeforeAttrName(e))
            : e === 34 || e === 39 || e === 60 || e === 61 || e === 96
            ? this.cbs.onerr(18, this.index)
            : e === 38 && this.startEntity()
        }
        stateBeforeDeclaration(e) {
          e === 91
            ? ((this.state = 26), (this.sequenceIndex = 0))
            : (this.state = e === 45 ? 25 : 23)
        }
        stateInDeclaration(e) {
          ;(e === 62 || this.fastForwardTo(62)) &&
            ((this.state = 1), (this.sectionStart = this.index + 1))
        }
        stateInProcessingInstruction(e) {
          ;(e === 62 || this.fastForwardTo(62)) &&
            (this.cbs.onprocessinginstruction(this.sectionStart, this.index),
            (this.state = 1),
            (this.sectionStart = this.index + 1))
        }
        stateBeforeComment(e) {
          e === 45
            ? ((this.state = 28),
              (this.currentSequence = Ft.CommentEnd),
              (this.sequenceIndex = 2),
              (this.sectionStart = this.index + 1))
            : (this.state = 23)
        }
        stateInSpecialComment(e) {
          ;(e === 62 || this.fastForwardTo(62)) &&
            (this.cbs.oncomment(this.sectionStart, this.index),
            (this.state = 1),
            (this.sectionStart = this.index + 1))
        }
        stateBeforeSpecialS(e) {
          e === Ft.ScriptEnd[3]
            ? this.startSpecial(Ft.ScriptEnd, 4)
            : e === Ft.StyleEnd[3]
            ? this.startSpecial(Ft.StyleEnd, 4)
            : ((this.state = 6), this.stateInTagName(e))
        }
        stateBeforeSpecialT(e) {
          e === Ft.TitleEnd[3]
            ? this.startSpecial(Ft.TitleEnd, 4)
            : e === Ft.TextareaEnd[3]
            ? this.startSpecial(Ft.TextareaEnd, 4)
            : ((this.state = 6), this.stateInTagName(e))
        }
        startEntity() {
          ;(this.baseState = this.state),
            (this.state = 33),
            (this.entityStart = this.index),
            this.entityDecoder.startEntity(
              this.baseState === 1 || this.baseState === 32
                ? en.DecodingMode.Legacy
                : en.DecodingMode.Attribute
            )
        }
        stateInEntity() {
          {
            let e = this.entityDecoder.write(this.buffer, this.index)
            e >= 0
              ? ((this.state = this.baseState),
                e === 0 && (this.index = this.entityStart))
              : (this.index = this.buffer.length - 1)
          }
        }
        parse(e) {
          for (this.buffer = e; this.index < this.buffer.length; ) {
            let s = this.buffer.charCodeAt(this.index)
            switch ((s === 10 && this.newlines.push(this.index), this.state)) {
              case 1: {
                this.stateText(s)
                break
              }
              case 2: {
                this.stateInterpolationOpen(s)
                break
              }
              case 3: {
                this.stateInterpolation(s)
                break
              }
              case 4: {
                this.stateInterpolationClose(s)
                break
              }
              case 31: {
                this.stateSpecialStartSequence(s)
                break
              }
              case 32: {
                this.stateInRCDATA(s)
                break
              }
              case 26: {
                this.stateCDATASequence(s)
                break
              }
              case 19: {
                this.stateInAttrValueDoubleQuotes(s)
                break
              }
              case 12: {
                this.stateInAttrName(s)
                break
              }
              case 13: {
                this.stateInDirName(s)
                break
              }
              case 14: {
                this.stateInDirArg(s)
                break
              }
              case 15: {
                this.stateInDynamicDirArg(s)
                break
              }
              case 16: {
                this.stateInDirModifier(s)
                break
              }
              case 28: {
                this.stateInCommentLike(s)
                break
              }
              case 27: {
                this.stateInSpecialComment(s)
                break
              }
              case 11: {
                this.stateBeforeAttrName(s)
                break
              }
              case 6: {
                this.stateInTagName(s)
                break
              }
              case 34: {
                this.stateInSFCRootTagName(s)
                break
              }
              case 9: {
                this.stateInClosingTagName(s)
                break
              }
              case 5: {
                this.stateBeforeTagName(s)
                break
              }
              case 17: {
                this.stateAfterAttrName(s)
                break
              }
              case 20: {
                this.stateInAttrValueSingleQuotes(s)
                break
              }
              case 18: {
                this.stateBeforeAttrValue(s)
                break
              }
              case 8: {
                this.stateBeforeClosingTagName(s)
                break
              }
              case 10: {
                this.stateAfterClosingTagName(s)
                break
              }
              case 29: {
                this.stateBeforeSpecialS(s)
                break
              }
              case 30: {
                this.stateBeforeSpecialT(s)
                break
              }
              case 21: {
                this.stateInAttrValueNoQuotes(s)
                break
              }
              case 7: {
                this.stateInSelfClosingTag(s)
                break
              }
              case 23: {
                this.stateInDeclaration(s)
                break
              }
              case 22: {
                this.stateBeforeDeclaration(s)
                break
              }
              case 25: {
                this.stateBeforeComment(s)
                break
              }
              case 24: {
                this.stateInProcessingInstruction(s)
                break
              }
              case 33: {
                this.stateInEntity()
                break
              }
            }
            this.index++
          }
          this.cleanup(), this.finish()
        }
        cleanup() {
          this.sectionStart !== this.index &&
            (this.state === 1 || (this.state === 32 && this.sequenceIndex === 0)
              ? (this.cbs.ontext(this.sectionStart, this.index),
                (this.sectionStart = this.index))
              : (this.state === 19 || this.state === 20 || this.state === 21) &&
                (this.cbs.onattribdata(this.sectionStart, this.index),
                (this.sectionStart = this.index)))
        }
        finish() {
          this.state === 33 &&
            (this.entityDecoder.end(), (this.state = this.baseState)),
            this.handleTrailingData(),
            this.cbs.onend()
        }
        handleTrailingData() {
          let e = this.buffer.length
          this.sectionStart >= e ||
            (this.state === 28
              ? this.currentSequence === Ft.CdataEnd
                ? this.cbs.oncdata(this.sectionStart, e)
                : this.cbs.oncomment(this.sectionStart, e)
              : this.state === 6 ||
                this.state === 11 ||
                this.state === 18 ||
                this.state === 17 ||
                this.state === 12 ||
                this.state === 13 ||
                this.state === 14 ||
                this.state === 15 ||
                this.state === 16 ||
                this.state === 20 ||
                this.state === 19 ||
                this.state === 21 ||
                this.state === 9 ||
                this.cbs.ontext(this.sectionStart, e))
        }
        emitCodePoint(e, s) {
          this.baseState !== 1 && this.baseState !== 32
            ? (this.sectionStart < this.entityStart &&
                this.cbs.onattribdata(this.sectionStart, this.entityStart),
              (this.sectionStart = this.entityStart + s),
              (this.index = this.sectionStart - 1),
              this.cbs.onattribentity(
                en.fromCodePoint(e),
                this.entityStart,
                this.sectionStart
              ))
            : (this.sectionStart < this.entityStart &&
                this.cbs.ontext(this.sectionStart, this.entityStart),
              (this.sectionStart = this.entityStart + s),
              (this.index = this.sectionStart - 1),
              this.cbs.ontextentity(
                en.fromCodePoint(e),
                this.entityStart,
                this.sectionStart
              ))
        }
      },
      p6 = {
        COMPILER_IS_ON_ELEMENT: 'COMPILER_IS_ON_ELEMENT',
        COMPILER_V_BIND_SYNC: 'COMPILER_V_BIND_SYNC',
        COMPILER_V_BIND_OBJECT_ORDER: 'COMPILER_V_BIND_OBJECT_ORDER',
        COMPILER_V_ON_NATIVE: 'COMPILER_V_ON_NATIVE',
        COMPILER_V_IF_V_FOR_PRECEDENCE: 'COMPILER_V_IF_V_FOR_PRECEDENCE',
        COMPILER_NATIVE_TEMPLATE: 'COMPILER_NATIVE_TEMPLATE',
        COMPILER_INLINE_TEMPLATE: 'COMPILER_INLINE_TEMPLATE',
        COMPILER_FILTERS: 'COMPILER_FILTERS',
      },
      d6 = {
        COMPILER_IS_ON_ELEMENT: {
          message:
            'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
          link: 'https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html',
        },
        COMPILER_V_BIND_SYNC: {
          message: (t) =>
            `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${t}.sync\` should be changed to \`v-model:${t}\`.`,
          link: 'https://v3-migration.vuejs.org/breaking-changes/v-model.html',
        },
        COMPILER_V_BIND_OBJECT_ORDER: {
          message:
            'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
          link: 'https://v3-migration.vuejs.org/breaking-changes/v-bind.html',
        },
        COMPILER_V_ON_NATIVE: {
          message:
            '.native modifier for v-on has been removed as is no longer necessary.',
          link: 'https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html',
        },
        COMPILER_V_IF_V_FOR_PRECEDENCE: {
          message:
            'v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.',
          link: 'https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html',
        },
        COMPILER_NATIVE_TEMPLATE: {
          message:
            '<template> with no special directives will render as a native template element instead of its inner content in Vue 3.',
        },
        COMPILER_INLINE_TEMPLATE: {
          message: '"inline-template" has been removed in Vue 3.',
          link: 'https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html',
        },
        COMPILER_FILTERS: {
          message:
            'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
          link: 'https://v3-migration.vuejs.org/breaking-changes/filters.html',
        },
      }
    function Mp(t, { compatConfig: e }) {
      let s = e && e[t]
      return t === 'MODE' ? s || 3 : s
    }
    function or(t, e) {
      let s = Mp('MODE', e),
        i = Mp(t, e)
      return s === 3 ? i === !0 : i !== !1
    }
    function na(t, e, s, ...i) {
      let r = or(t, e)
      return r && bo(t, e, s, ...i), r
    }
    function bo(t, e, s, ...i) {
      if (Mp(t, e) === 'suppress-warning') return
      let { message: n, link: a } = d6[t],
        o = `(deprecation ${t}) ${typeof n == 'function' ? n(...i) : n}${
          a
            ? `
  Details: ${a}`
            : ''
        }`,
        u = new SyntaxError(o)
      ;(u.code = t), s && (u.loc = s), e.onWarn(u)
    }
    function Rp(t) {
      throw t
    }
    function Rb(t) {
      console.warn(`[Vue warn] ${t.message}`)
    }
    function Xe(t, e, s, i) {
      let r = (s || Lb)[t] + (i || ''),
        n = new SyntaxError(String(r))
      return (n.code = t), (n.loc = e), n
    }
    var m6 = {
        ABRUPT_CLOSING_OF_EMPTY_COMMENT: 0,
        0: 'ABRUPT_CLOSING_OF_EMPTY_COMMENT',
        CDATA_IN_HTML_CONTENT: 1,
        1: 'CDATA_IN_HTML_CONTENT',
        DUPLICATE_ATTRIBUTE: 2,
        2: 'DUPLICATE_ATTRIBUTE',
        END_TAG_WITH_ATTRIBUTES: 3,
        3: 'END_TAG_WITH_ATTRIBUTES',
        END_TAG_WITH_TRAILING_SOLIDUS: 4,
        4: 'END_TAG_WITH_TRAILING_SOLIDUS',
        EOF_BEFORE_TAG_NAME: 5,
        5: 'EOF_BEFORE_TAG_NAME',
        EOF_IN_CDATA: 6,
        6: 'EOF_IN_CDATA',
        EOF_IN_COMMENT: 7,
        7: 'EOF_IN_COMMENT',
        EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT: 8,
        8: 'EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT',
        EOF_IN_TAG: 9,
        9: 'EOF_IN_TAG',
        INCORRECTLY_CLOSED_COMMENT: 10,
        10: 'INCORRECTLY_CLOSED_COMMENT',
        INCORRECTLY_OPENED_COMMENT: 11,
        11: 'INCORRECTLY_OPENED_COMMENT',
        INVALID_FIRST_CHARACTER_OF_TAG_NAME: 12,
        12: 'INVALID_FIRST_CHARACTER_OF_TAG_NAME',
        MISSING_ATTRIBUTE_VALUE: 13,
        13: 'MISSING_ATTRIBUTE_VALUE',
        MISSING_END_TAG_NAME: 14,
        14: 'MISSING_END_TAG_NAME',
        MISSING_WHITESPACE_BETWEEN_ATTRIBUTES: 15,
        15: 'MISSING_WHITESPACE_BETWEEN_ATTRIBUTES',
        NESTED_COMMENT: 16,
        16: 'NESTED_COMMENT',
        UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME: 17,
        17: 'UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME',
        UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE: 18,
        18: 'UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE',
        UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME: 19,
        19: 'UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME',
        UNEXPECTED_NULL_CHARACTER: 20,
        20: 'UNEXPECTED_NULL_CHARACTER',
        UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME: 21,
        21: 'UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME',
        UNEXPECTED_SOLIDUS_IN_TAG: 22,
        22: 'UNEXPECTED_SOLIDUS_IN_TAG',
        X_INVALID_END_TAG: 23,
        23: 'X_INVALID_END_TAG',
        X_MISSING_END_TAG: 24,
        24: 'X_MISSING_END_TAG',
        X_MISSING_INTERPOLATION_END: 25,
        25: 'X_MISSING_INTERPOLATION_END',
        X_MISSING_DIRECTIVE_NAME: 26,
        26: 'X_MISSING_DIRECTIVE_NAME',
        X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END: 27,
        27: 'X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END',
        X_V_IF_NO_EXPRESSION: 28,
        28: 'X_V_IF_NO_EXPRESSION',
        X_V_IF_SAME_KEY: 29,
        29: 'X_V_IF_SAME_KEY',
        X_V_ELSE_NO_ADJACENT_IF: 30,
        30: 'X_V_ELSE_NO_ADJACENT_IF',
        X_V_FOR_NO_EXPRESSION: 31,
        31: 'X_V_FOR_NO_EXPRESSION',
        X_V_FOR_MALFORMED_EXPRESSION: 32,
        32: 'X_V_FOR_MALFORMED_EXPRESSION',
        X_V_FOR_TEMPLATE_KEY_PLACEMENT: 33,
        33: 'X_V_FOR_TEMPLATE_KEY_PLACEMENT',
        X_V_BIND_NO_EXPRESSION: 34,
        34: 'X_V_BIND_NO_EXPRESSION',
        X_V_ON_NO_EXPRESSION: 35,
        35: 'X_V_ON_NO_EXPRESSION',
        X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET: 36,
        36: 'X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET',
        X_V_SLOT_MIXED_SLOT_USAGE: 37,
        37: 'X_V_SLOT_MIXED_SLOT_USAGE',
        X_V_SLOT_DUPLICATE_SLOT_NAMES: 38,
        38: 'X_V_SLOT_DUPLICATE_SLOT_NAMES',
        X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN: 39,
        39: 'X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN',
        X_V_SLOT_MISPLACED: 40,
        40: 'X_V_SLOT_MISPLACED',
        X_V_MODEL_NO_EXPRESSION: 41,
        41: 'X_V_MODEL_NO_EXPRESSION',
        X_V_MODEL_MALFORMED_EXPRESSION: 42,
        42: 'X_V_MODEL_MALFORMED_EXPRESSION',
        X_V_MODEL_ON_SCOPE_VARIABLE: 43,
        43: 'X_V_MODEL_ON_SCOPE_VARIABLE',
        X_V_MODEL_ON_PROPS: 44,
        44: 'X_V_MODEL_ON_PROPS',
        X_INVALID_EXPRESSION: 45,
        45: 'X_INVALID_EXPRESSION',
        X_KEEP_ALIVE_INVALID_CHILDREN: 46,
        46: 'X_KEEP_ALIVE_INVALID_CHILDREN',
        X_PREFIX_ID_NOT_SUPPORTED: 47,
        47: 'X_PREFIX_ID_NOT_SUPPORTED',
        X_MODULE_MODE_NOT_SUPPORTED: 48,
        48: 'X_MODULE_MODE_NOT_SUPPORTED',
        X_CACHE_HANDLER_NOT_SUPPORTED: 49,
        49: 'X_CACHE_HANDLER_NOT_SUPPORTED',
        X_SCOPE_ID_NOT_SUPPORTED: 50,
        50: 'X_SCOPE_ID_NOT_SUPPORTED',
        X_VNODE_HOOKS: 51,
        51: 'X_VNODE_HOOKS',
        X_V_BIND_INVALID_SAME_NAME_ARGUMENT: 52,
        52: 'X_V_BIND_INVALID_SAME_NAME_ARGUMENT',
        __EXTEND_POINT__: 53,
        53: '__EXTEND_POINT__',
      },
      Lb = {
        [0]: 'Illegal comment.',
        [1]: 'CDATA section is allowed only in XML context.',
        [2]: 'Duplicate attribute.',
        [3]: 'End tag cannot have attributes.',
        [4]: "Illegal '/' in tags.",
        [5]: 'Unexpected EOF in tag.',
        [6]: 'Unexpected EOF in CDATA section.',
        [7]: 'Unexpected EOF in comment.',
        [8]: 'Unexpected EOF in script.',
        [9]: 'Unexpected EOF in tag.',
        [10]: 'Incorrectly closed comment.',
        [11]: 'Incorrectly opened comment.',
        [12]: "Illegal tag name. Use '&lt;' to print '<'.",
        [13]: 'Attribute value was expected.',
        [14]: 'End tag name was expected.',
        [15]: 'Whitespace was expected.',
        [16]: "Unexpected '<!--' in comment.",
        [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
        [18]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
        [19]: "Attribute name cannot start with '='.",
        [21]: "'<?' is allowed only in XML context.",
        [20]: 'Unexpected null character.',
        [22]: "Illegal '/' in tags.",
        [23]: 'Invalid end tag.',
        [24]: 'Element is missing end tag.',
        [25]: 'Interpolation end sign was not found.',
        [27]: 'End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.',
        [26]: 'Legal directive name was expected.',
        [28]: 'v-if/v-else-if is missing expression.',
        [29]: 'v-if/else branches must use unique keys.',
        [30]: 'v-else/v-else-if has no adjacent v-if or v-else-if.',
        [31]: 'v-for is missing expression.',
        [32]: 'v-for has invalid expression.',
        [33]: '<template v-for> key should be placed on the <template> tag.',
        [34]: 'v-bind is missing expression.',
        [52]: 'v-bind with same-name shorthand only allows static argument.',
        [35]: 'v-on is missing expression.',
        [36]: 'Unexpected custom directive on <slot> outlet.',
        [37]: 'Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.',
        [38]: 'Duplicate slot names found. ',
        [39]: 'Extraneous children found when component already has explicitly named default slot. These children will be ignored.',
        [40]: 'v-slot can only be used on components or <template> tags.',
        [41]: 'v-model is missing expression.',
        [42]: 'v-model value must be a valid JavaScript member expression.',
        [43]: 'v-model cannot be used on v-for or v-slot scope variables because they are not writable.',
        [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
        [45]: 'Error parsing JavaScript expression: ',
        [46]: '<KeepAlive> expects exactly one child component.',
        [51]: '@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.',
        [47]: '"prefixIdentifiers" option is not supported in this build of compiler.',
        [48]: 'ES module mode is not supported in this build of compiler.',
        [49]: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
        [50]: '"scopeId" option is only supported in module mode.',
        [53]: '',
      }
    function kb(t, e, s = !1, i = [], r = Object.create(null)) {
      let n =
        t.type === 'Program'
          ? t.body[0].type === 'ExpressionStatement' && t.body[0].expression
          : t
      e6.walk(t, {
        enter(a, o) {
          if (
            (o && i.push(o),
            o && o.type.startsWith('TS') && !Fp.includes(o.type))
          )
            return this.skip()
          if (a.type === 'Identifier') {
            let u = !!r[a.name],
              l = Db(a, o, i)
            ;(s || (l && !u)) && e(a, o, i, l, u)
          } else
            a.type === 'ObjectProperty' &&
            (o == null ? void 0 : o.type) === 'ObjectPattern'
              ? (a.inPattern = !0)
              : Hb(a)
              ? a.scopeIds
                ? a.scopeIds.forEach((u) => kp(u, r))
                : Bb(a, (u) => Ub(a, u, r))
              : a.type === 'BlockStatement' &&
                (a.scopeIds
                  ? a.scopeIds.forEach((u) => kp(u, r))
                  : Vb(a, (u) => Ub(a, u, r)))
        },
        leave(a, o) {
          if ((o && i.pop(), a !== n && a.scopeIds))
            for (let u of a.scopeIds) r[u]--, r[u] === 0 && delete r[u]
        },
      })
    }
    function Db(t, e, s) {
      if (!e) return !0
      if (t.name === 'arguments') return !1
      if (g6(t, e)) return !0
      switch (e.type) {
        case 'AssignmentExpression':
        case 'AssignmentPattern':
          return !0
        case 'ObjectPattern':
        case 'ArrayPattern':
          return Lp(e, s)
      }
      return !1
    }
    function Lp(t, e) {
      if (t && (t.type === 'ObjectProperty' || t.type === 'ArrayPattern')) {
        let s = e.length
        for (; s--; ) {
          let i = e[s]
          if (i.type === 'AssignmentExpression') return !0
          if (i.type !== 'ObjectProperty' && !i.type.endsWith('Pattern')) break
        }
      }
      return !1
    }
    function Fb(t) {
      let e = t.length
      for (; e--; ) {
        let s = t[e]
        if (s.type === 'NewExpression') return !0
        if (s.type !== 'MemberExpression') break
      }
      return !1
    }
    function Bb(t, e) {
      for (let s of t.params) for (let i of Pi(s)) e(i)
    }
    function Vb(t, e) {
      for (let s of t.body)
        if (s.type === 'VariableDeclaration') {
          if (s.declare) continue
          for (let i of s.declarations) for (let r of Pi(i.id)) e(r)
        } else if (
          s.type === 'FunctionDeclaration' ||
          s.type === 'ClassDeclaration'
        ) {
          if (s.declare || !s.id) continue
          e(s.id)
        } else if (
          s.type === 'ForOfStatement' ||
          s.type === 'ForInStatement' ||
          s.type === 'ForStatement'
        ) {
          let i = s.type === 'ForStatement' ? s.init : s.left
          if (i && i.type === 'VariableDeclaration')
            for (let r of i.declarations) for (let n of Pi(r.id)) e(n)
        }
    }
    function Pi(t, e = []) {
      switch (t.type) {
        case 'Identifier':
          e.push(t)
          break
        case 'MemberExpression':
          let s = t
          for (; s.type === 'MemberExpression'; ) s = s.object
          e.push(s)
          break
        case 'ObjectPattern':
          for (let i of t.properties)
            i.type === 'RestElement' ? Pi(i.argument, e) : Pi(i.value, e)
          break
        case 'ArrayPattern':
          t.elements.forEach((i) => {
            i && Pi(i, e)
          })
          break
        case 'RestElement':
          Pi(t.argument, e)
          break
        case 'AssignmentPattern':
          Pi(t.left, e)
          break
      }
      return e
    }
    function kp(t, e) {
      t in e ? e[t]++ : (e[t] = 1)
    }
    function Ub(t, e, s) {
      let { name: i } = e
      ;(t.scopeIds && t.scopeIds.has(i)) ||
        (kp(i, s), (t.scopeIds || (t.scopeIds = new Set())).add(i))
    }
    var Hb = (t) => /Function(?:Expression|Declaration)$|Method$/.test(t.type),
      Dp = (t) =>
        t &&
        (t.type === 'ObjectProperty' || t.type === 'ObjectMethod') &&
        !t.computed,
      $b = (t, e) => Dp(e) && e.key === t
    function g6(t, e, s) {
      switch (e.type) {
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return e.property === t ? !!e.computed : e.object === t
        case 'JSXMemberExpression':
          return e.object === t
        case 'VariableDeclarator':
          return e.init === t
        case 'ArrowFunctionExpression':
          return e.body === t
        case 'PrivateName':
          return !1
        case 'ClassMethod':
        case 'ClassPrivateMethod':
        case 'ObjectMethod':
          return e.key === t ? !!e.computed : !1
        case 'ObjectProperty':
          return e.key === t ? !!e.computed : !s
        case 'ClassProperty':
          return e.key === t ? !!e.computed : !0
        case 'ClassPrivateProperty':
          return e.key !== t
        case 'ClassDeclaration':
        case 'ClassExpression':
          return e.superClass === t
        case 'AssignmentExpression':
          return e.right === t
        case 'AssignmentPattern':
          return e.right === t
        case 'LabeledStatement':
          return !1
        case 'CatchClause':
          return !1
        case 'RestElement':
          return !1
        case 'BreakStatement':
        case 'ContinueStatement':
          return !1
        case 'FunctionDeclaration':
        case 'FunctionExpression':
          return !1
        case 'ExportNamespaceSpecifier':
        case 'ExportDefaultSpecifier':
          return !1
        case 'ExportSpecifier':
          return e.local === t
        case 'ImportDefaultSpecifier':
        case 'ImportNamespaceSpecifier':
        case 'ImportSpecifier':
          return !1
        case 'ImportAttribute':
          return !1
        case 'JSXAttribute':
          return !1
        case 'ObjectPattern':
        case 'ArrayPattern':
          return !1
        case 'MetaProperty':
          return !1
        case 'ObjectTypeProperty':
          return e.key !== t
        case 'TSEnumMember':
          return e.id !== t
        case 'TSPropertySignature':
          return e.key === t ? !!e.computed : !0
      }
      return !0
    }
    var Fp = [
      'TSAsExpression',
      'TSTypeAssertion',
      'TSNonNullExpression',
      'TSInstantiationExpression',
      'TSSatisfiesExpression',
    ]
    function Bp(t) {
      return Fp.includes(t.type) ? Bp(t.expression) : t
    }
    var qs = (t) => t.type === 4 && t.isStatic
    function Vp(t) {
      switch (t) {
        case 'Teleport':
        case 'teleport':
          return Zn
        case 'Suspense':
        case 'suspense':
          return Il
        case 'KeepAlive':
        case 'keep-alive':
          return fo
        case 'BaseTransition':
        case 'base-transition':
          return Pp
      }
    }
    var y6 = /^\d|[^\$\w\xA0-\uFFFF]/,
      Ci = (t) => !y6.test(t),
      b6 = /[A-Za-z_$\xA0-\uFFFF]/,
      E6 = /[\.\?\w$\xA0-\uFFFF]/,
      S6 = /\s+[.[]\s*|\s*[.[]\s+/g,
      T6 = (t) => {
        t = t.trim().replace(S6, (a) => a.trim())
        let e = 0,
          s = [],
          i = 0,
          r = 0,
          n = null
        for (let a = 0; a < t.length; a++) {
          let o = t.charAt(a)
          switch (e) {
            case 0:
              if (o === '[') s.push(e), (e = 1), i++
              else if (o === '(') s.push(e), (e = 2), r++
              else if (!(a === 0 ? b6 : E6).test(o)) return !1
              break
            case 1:
              o === "'" || o === '"' || o === '`'
                ? (s.push(e), (e = 3), (n = o))
                : o === '['
                ? i++
                : o === ']' && (--i || (e = s.pop()))
              break
            case 2:
              if (o === "'" || o === '"' || o === '`')
                s.push(e), (e = 3), (n = o)
              else if (o === '(') r++
              else if (o === ')') {
                if (a === t.length - 1) return !1
                --r || (e = s.pop())
              }
              break
            case 3:
              o === n && ((e = s.pop()), (n = null))
              break
          }
        }
        return !i && !r
      },
      jb = (t, e) => {
        try {
          let s = co.parseExpression(t, { plugins: e.expressionPlugins })
          return (
            (s = Bp(s)),
            s.type === 'MemberExpression' ||
              s.type === 'OptionalMemberExpression' ||
              (s.type === 'Identifier' && s.name !== 'undefined')
          )
        } catch (s) {
          return !1
        }
      },
      Up = jb
    function Hp(t, e, s = e.length) {
      return $p({ offset: t.offset, line: t.line, column: t.column }, e, s)
    }
    function $p(t, e, s = e.length) {
      let i = 0,
        r = -1
      for (let n = 0; n < s; n++) e.charCodeAt(n) === 10 && (i++, (r = n))
      return (
        (t.offset += s),
        (t.line += i),
        (t.column = r === -1 ? t.column + s : s - r),
        t
      )
    }
    function jp(t, e) {
      if (!t) throw new Error(e || 'unexpected compiler condition')
    }
    function Ss(t, e, s = !1) {
      for (let i = 0; i < t.props.length; i++) {
        let r = t.props[i]
        if (
          r.type === 7 &&
          (s || r.exp) &&
          (re.isString(e) ? r.name === e : e.test(r.name))
        )
          return r
      }
    }
    function Eo(t, e, s = !1, i = !1) {
      for (let r = 0; r < t.props.length; r++) {
        let n = t.props[r]
        if (n.type === 6) {
          if (s) continue
          if (n.name === e && (n.value || i)) return n
        } else if (n.name === 'bind' && (n.exp || i) && ur(n.arg, e)) return n
      }
    }
    function ur(t, e) {
      return !!(t && qs(t) && t.content === e)
    }
    function _6(t) {
      return t.props.some(
        (e) =>
          e.type === 7 &&
          e.name === 'bind' &&
          (!e.arg || e.arg.type !== 4 || !e.arg.isStatic)
      )
    }
    function Yl(t) {
      return t.type === 5 || t.type === 2
    }
    function qp(t) {
      return t.type === 7 && t.name === 'slot'
    }
    function aa(t) {
      return t.type === 1 && t.tagType === 3
    }
    function So(t) {
      return t.type === 1 && t.tagType === 2
    }
    var x6 = new Set([ta, sa])
    function qb(t, e = []) {
      if (t && !re.isString(t) && t.type === 14) {
        let s = t.callee
        if (!re.isString(s) && x6.has(s)) return qb(t.arguments[0], e.concat(t))
      }
      return [t, e]
    }
    function To(t, e, s) {
      let i,
        r = t.type === 13 ? t.props : t.arguments[2],
        n = [],
        a
      if (r && !re.isString(r) && r.type === 14) {
        let o = qb(r)
        ;(r = o[0]), (n = o[1]), (a = n[n.length - 1])
      }
      if (r == null || re.isString(r)) i = ys([e])
      else if (r.type === 14) {
        let o = r.arguments[0]
        !re.isString(o) && o.type === 15
          ? Kb(e, o) || o.properties.unshift(e)
          : r.callee === Hl
          ? (i = Dt(s.helper(po), [ys([e]), r]))
          : r.arguments.unshift(ys([e])),
          !i && (i = r)
      } else
        r.type === 15
          ? (Kb(e, r) || r.properties.unshift(e), (i = r))
          : ((i = Dt(s.helper(po), [ys([e]), r])),
            a && a.callee === sa && (a = n[n.length - 2]))
      t.type === 13
        ? a
          ? (a.arguments[0] = i)
          : (t.props = i)
        : a
        ? (a.arguments[0] = i)
        : (t.arguments[2] = i)
    }
    function Kb(t, e) {
      let s = !1
      if (t.key.type === 4) {
        let i = t.key.content
        s = e.properties.some((r) => r.key.type === 4 && r.key.content === i)
      }
      return s
    }
    function nn(t, e) {
      return `_${e}_${t.replace(/[^\w]/g, (s, i) =>
        s === '-' ? '_' : t.charCodeAt(i).toString()
      )}`
    }
    function as(t, e) {
      if (!t || Object.keys(e).length === 0) return !1
      switch (t.type) {
        case 1:
          for (let s = 0; s < t.props.length; s++) {
            let i = t.props[s]
            if (i.type === 7 && (as(i.arg, e) || as(i.exp, e))) return !0
          }
          return t.children.some((s) => as(s, e))
        case 11:
          return as(t.source, e) ? !0 : t.children.some((s) => as(s, e))
        case 9:
          return t.branches.some((s) => as(s, e))
        case 10:
          return as(t.condition, e) ? !0 : t.children.some((s) => as(s, e))
        case 4:
          return !t.isStatic && Ci(t.content) && !!e[t.content]
        case 8:
          return t.children.some((s) => re.isObject(s) && as(s, e))
        case 5:
        case 12:
          return as(t.content, e)
        case 2:
        case 3:
          return !1
        default:
          return !1
      }
    }
    function Xb(t) {
      return t.type === 14 && t.callee === Gl ? t.arguments[1].returns : t
    }
    var Gb = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/,
      Wb = {
        parseMode: 'base',
        ns: 0,
        delimiters: ['{{', '}}'],
        getNamespace: () => 0,
        isVoidTag: re.NO,
        isPreTag: re.NO,
        isCustomElement: re.NO,
        onError: Rp,
        onWarn: Rb,
        comments: !0,
        prefixIdentifiers: !1,
      },
      Be = Wb,
      _o = null,
      vi = '',
      jt = null,
      Re = null,
      Os = '',
      Ni = -1,
      an = -1,
      Ql = 0,
      lr = !1,
      Kp = null,
      ft = [],
      Je = new Mb(ft, {
        onerr: Qt,
        ontext(t, e) {
          Zl(Bt(t, e), t, e)
        },
        ontextentity(t, e, s) {
          Zl(t, e, s)
        },
        oninterpolation(t, e) {
          if (lr) return Zl(Bt(t, e), t, e)
          let s = t + Je.delimiterOpen.length,
            i = e - Je.delimiterClose.length
          for (; Es(vi.charCodeAt(s)); ) s++
          for (; Es(vi.charCodeAt(i - 1)); ) i--
          let r = Bt(s, i)
          r.includes('&') && (r = en.decodeHTML(r)),
            Xp({ type: 5, content: tc(r, !1, _t(s, i)), loc: _t(t, e) })
        },
        onopentagname(t, e) {
          let s = Bt(t, e)
          jt = {
            type: 1,
            tag: s,
            ns: Be.getNamespace(s, ft[0], Be.ns),
            tagType: 0,
            props: [],
            children: [],
            loc: _t(t - 1, e),
            codegenNode: void 0,
          }
        },
        onopentagend(t) {
          Jb(t)
        },
        onclosetag(t, e) {
          let s = Bt(t, e)
          if (!Be.isVoidTag(s)) {
            let i = !1
            for (let r = 0; r < ft.length; r++)
              if (ft[r].tag.toLowerCase() === s.toLowerCase()) {
                ;(i = !0), r > 0 && Qt(24, ft[0].loc.start.offset)
                for (let a = 0; a <= r; a++) {
                  let o = ft.shift()
                  ec(o, e, a < r)
                }
                break
              }
            i || Qt(23, Yb(t, 60))
          }
        },
        onselfclosingtag(t) {
          let e = jt.tag
          ;(jt.isSelfClosing = !0),
            Jb(t),
            ft[0] && ft[0].tag === e && ec(ft.shift(), t)
        },
        onattribname(t, e) {
          Re = {
            type: 6,
            name: Bt(t, e),
            nameLoc: _t(t, e),
            value: void 0,
            loc: _t(t),
          }
        },
        ondirname(t, e) {
          let s = Bt(t, e),
            i =
              s === '.' || s === ':'
                ? 'bind'
                : s === '@'
                ? 'on'
                : s === '#'
                ? 'slot'
                : s.slice(2)
          if ((!lr && i === '' && Qt(26, t), lr || i === ''))
            Re = {
              type: 6,
              name: s,
              nameLoc: _t(t, e),
              value: void 0,
              loc: _t(t),
            }
          else if (
            ((Re = {
              type: 7,
              name: i,
              rawName: s,
              exp: void 0,
              arg: void 0,
              modifiers: s === '.' ? ['prop'] : [],
              loc: _t(t),
            }),
            i === 'pre')
          ) {
            ;(lr = Je.inVPre = !0), (Kp = jt)
            let r = jt.props
            for (let n = 0; n < r.length; n++)
              r[n].type === 7 && (r[n] = R6(r[n]))
          }
        },
        ondirarg(t, e) {
          if (t === e) return
          let s = Bt(t, e)
          if (lr) (Re.name += s), on(Re.nameLoc, e)
          else {
            let i = s[0] !== '['
            Re.arg = tc(i ? s : s.slice(1, -1), i, _t(t, e), i ? 3 : 0)
          }
        },
        ondirmodifier(t, e) {
          let s = Bt(t, e)
          if (lr) (Re.name += '.' + s), on(Re.nameLoc, e)
          else if (Re.name === 'slot') {
            let i = Re.arg
            i && ((i.content += '.' + s), on(i.loc, e))
          } else Re.modifiers.push(s)
        },
        onattribdata(t, e) {
          ;(Os += Bt(t, e)), Ni < 0 && (Ni = t), (an = e)
        },
        onattribentity(t, e, s) {
          ;(Os += t), Ni < 0 && (Ni = e), (an = s)
        },
        onattribnameend(t) {
          let e = Re.loc.start.offset,
            s = Bt(e, t)
          Re.type === 7 && (Re.rawName = s),
            jt.props.some((i) => (i.type === 7 ? i.rawName : i.name) === s) &&
              Qt(2, e)
        },
        onattribend(t, e) {
          if (jt && Re) {
            if ((on(Re.loc, e), t !== 0))
              if (Re.type === 6)
                Re.name === 'class' && (Os = eE(Os).trim()),
                  t === 1 && !Os && Qt(13, e),
                  (Re.value = {
                    type: 2,
                    content: Os,
                    loc: t === 1 ? _t(Ni, an) : _t(Ni - 1, an + 1),
                  }),
                  Je.inSFCRoot &&
                    jt.tag === 'template' &&
                    Re.name === 'lang' &&
                    Os &&
                    Os !== 'html' &&
                    Je.enterRCDATA(Jl('</template'), 0)
              else {
                let s = 0
                Re.name === 'for'
                  ? (s = 3)
                  : Re.name === 'slot'
                  ? (s = 1)
                  : Re.name === 'on' && Os.includes(';') && (s = 2),
                  (Re.exp = tc(Os, !1, _t(Ni, an), 0, s)),
                  Re.name === 'for' && (Re.forParseResult = P6(Re.exp))
                let i = -1
                Re.name === 'bind' &&
                  (i = Re.modifiers.indexOf('sync')) > -1 &&
                  na('COMPILER_V_BIND_SYNC', Be, Re.loc, Re.rawName) &&
                  ((Re.name = 'model'), Re.modifiers.splice(i, 1))
              }
            ;(Re.type !== 7 || Re.name !== 'pre') && jt.props.push(Re)
          }
          ;(Os = ''), (Ni = an = -1)
        },
        oncomment(t, e) {
          Be.comments &&
            Xp({ type: 3, content: Bt(t, e), loc: _t(t - 4, e + 3) })
        },
        onend() {
          let t = vi.length
          if (Je.state !== 1)
            switch (Je.state) {
              case 5:
              case 8:
                Qt(5, t)
                break
              case 3:
              case 4:
                Qt(25, Je.sectionStart)
                break
              case 28:
                Je.currentSequence === Ft.CdataEnd ? Qt(6, t) : Qt(7, t)
                break
              case 6:
              case 7:
              case 9:
              case 11:
              case 12:
              case 13:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
                Qt(9, t)
                break
            }
          for (let e = 0; e < ft.length; e++)
            ec(ft[e], t - 1), Qt(24, ft[e].loc.start.offset)
        },
        oncdata(t, e) {
          ft[0].ns !== 0 ? Zl(Bt(t, e), t, e) : Qt(1, t - 9)
        },
        onprocessinginstruction(t) {
          ;(ft[0] ? ft[0].ns : Be.ns) === 0 && Qt(21, t - 1)
        },
      }),
      zb = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
      A6 = /^\(|\)$/g
    function P6(t) {
      let e = t.loc,
        s = t.content,
        i = s.match(Gb)
      if (!i) return
      let [, r, n] = i,
        a = (f, h, p = !1) => {
          let m = e.start.offset + h,
            y = m + f.length
          return tc(f, !1, _t(m, y), 0, p ? 1 : 0)
        },
        o = {
          source: a(n.trim(), s.indexOf(n, r.length)),
          value: void 0,
          key: void 0,
          index: void 0,
          finalized: !1,
        },
        u = r.trim().replace(A6, '').trim(),
        l = r.indexOf(u),
        c = u.match(zb)
      if (c) {
        u = u.replace(zb, '').trim()
        let f = c[1].trim(),
          h
        if (
          (f && ((h = s.indexOf(f, l + u.length)), (o.key = a(f, h, !0))), c[2])
        ) {
          let p = c[2].trim()
          p &&
            (o.index = a(
              p,
              s.indexOf(p, o.key ? h + f.length : l + u.length),
              !0
            ))
        }
      }
      return u && (o.value = a(u, l, !0)), o
    }
    function Bt(t, e) {
      return vi.slice(t, e)
    }
    function Jb(t) {
      Je.inSFCRoot && (jt.innerLoc = _t(t + 1, t + 1)), Xp(jt)
      let { tag: e, ns: s } = jt
      s === 0 && Be.isPreTag(e) && Ql++,
        Be.isVoidTag(e)
          ? ec(jt, t)
          : (ft.unshift(jt), (s === 1 || s === 2) && (Je.inXML = !0)),
        (jt = null)
    }
    function Zl(t, e, s) {
      let i = ft[0] || _o,
        r = i.children[i.children.length - 1]
      r && r.type === 2
        ? ((r.content += t), on(r.loc, s))
        : i.children.push({ type: 2, content: t, loc: _t(e, s) })
    }
    function ec(t, e, s = !1) {
      s ? on(t.loc, Yb(e, 60)) : on(t.loc, C6(e, 62) + 1),
        Je.inSFCRoot &&
          (t.children.length
            ? (t.innerLoc.end = re.extend(
                {},
                t.children[t.children.length - 1].loc.end
              ))
            : (t.innerLoc.end = re.extend({}, t.innerLoc.start)),
          (t.innerLoc.source = Bt(
            t.innerLoc.start.offset,
            t.innerLoc.end.offset
          )))
      let { tag: i, ns: r } = t
      lr ||
        (i === 'slot'
          ? (t.tagType = 2)
          : Qb(t)
          ? (t.tagType = 3)
          : N6(t) && (t.tagType = 1)),
        Je.inRCDATA || (t.children = Zb(t.children, t.tag)),
        r === 0 && Be.isPreTag(i) && Ql--,
        Kp === t && ((lr = Je.inVPre = !1), (Kp = null)),
        Je.inXML && (ft[0] ? ft[0].ns : Be.ns) === 0 && (Je.inXML = !1)
      {
        let n = t.props
        if (or('COMPILER_V_IF_V_FOR_PRECEDENCE', Be)) {
          let o = !1,
            u = !1
          for (let l = 0; l < n.length; l++) {
            let c = n[l]
            if (
              (c.type === 7 &&
                (c.name === 'if' ? (o = !0) : c.name === 'for' && (u = !0)),
              o && u)
            ) {
              bo('COMPILER_V_IF_V_FOR_PRECEDENCE', Be, t.loc)
              break
            }
          }
        }
        if (
          !Je.inSFCRoot &&
          or('COMPILER_NATIVE_TEMPLATE', Be) &&
          t.tag === 'template' &&
          !Qb(t)
        ) {
          bo('COMPILER_NATIVE_TEMPLATE', Be, t.loc)
          let o = ft[0] || _o,
            u = o.children.indexOf(t)
          o.children.splice(u, 1, ...t.children)
        }
        let a = n.find((o) => o.type === 6 && o.name === 'inline-template')
        a &&
          na('COMPILER_INLINE_TEMPLATE', Be, a.loc) &&
          t.children.length &&
          (a.value = {
            type: 2,
            content: Bt(
              t.children[0].loc.start.offset,
              t.children[t.children.length - 1].loc.end.offset
            ),
            loc: a.loc,
          })
      }
    }
    function C6(t, e) {
      let s = t
      for (; vi.charCodeAt(s) !== e && s < vi.length - 1; ) s++
      return s
    }
    function Yb(t, e) {
      let s = t
      for (; vi.charCodeAt(s) !== e && s >= 0; ) s--
      return s
    }
    var v6 = new Set(['if', 'else', 'else-if', 'for', 'slot'])
    function Qb({ tag: t, props: e }) {
      if (t === 'template') {
        for (let s = 0; s < e.length; s++)
          if (e[s].type === 7 && v6.has(e[s].name)) return !0
      }
      return !1
    }
    function N6({ tag: t, props: e }) {
      if (Be.isCustomElement(t)) return !1
      if (
        t === 'component' ||
        I6(t.charCodeAt(0)) ||
        Vp(t) ||
        (Be.isBuiltInComponent && Be.isBuiltInComponent(t)) ||
        (Be.isNativeTag && !Be.isNativeTag(t))
      )
        return !0
      for (let s = 0; s < e.length; s++) {
        let i = e[s]
        if (i.type === 6) {
          if (i.name === 'is' && i.value) {
            if (i.value.content.startsWith('vue:')) return !0
            if (na('COMPILER_IS_ON_ELEMENT', Be, i.loc)) return !0
          }
        } else if (
          i.name === 'bind' &&
          ur(i.arg, 'is') &&
          na('COMPILER_IS_ON_ELEMENT', Be, i.loc)
        )
          return !0
      }
      return !1
    }
    function I6(t) {
      return t > 64 && t < 91
    }
    var O6 = /\r\n/g
    function Zb(t, e) {
      let s = Be.whitespace !== 'preserve',
        i = !1
      for (let r = 0; r < t.length; r++) {
        let n = t[r]
        if (n.type === 2)
          if (Ql)
            n.content = n.content.replace(
              O6,
              `
`
            )
          else if (w6(n.content)) {
            let a = t[r - 1] && t[r - 1].type,
              o = t[r + 1] && t[r + 1].type
            !a ||
            !o ||
            (s &&
              ((a === 3 && (o === 3 || o === 1)) ||
                (a === 1 && (o === 3 || (o === 1 && M6(n.content))))))
              ? ((i = !0), (t[r] = null))
              : (n.content = ' ')
          } else s && (n.content = eE(n.content))
      }
      if (Ql && e && Be.isPreTag(e)) {
        let r = t[0]
        r && r.type === 2 && (r.content = r.content.replace(/^\r?\n/, ''))
      }
      return i ? t.filter(Boolean) : t
    }
    function w6(t) {
      for (let e = 0; e < t.length; e++) if (!Es(t.charCodeAt(e))) return !1
      return !0
    }
    function M6(t) {
      for (let e = 0; e < t.length; e++) {
        let s = t.charCodeAt(e)
        if (s === 10 || s === 13) return !0
      }
      return !1
    }
    function eE(t) {
      let e = '',
        s = !1
      for (let i = 0; i < t.length; i++)
        Es(t.charCodeAt(i))
          ? s || ((e += ' '), (s = !0))
          : ((e += t[i]), (s = !1))
      return e
    }
    function Xp(t) {
      ;(ft[0] || _o).children.push(t)
    }
    function _t(t, e) {
      return {
        start: Je.getPos(t),
        end: e == null ? e : Je.getPos(e),
        source: e == null ? e : Bt(t, e),
      }
    }
    function on(t, e) {
      ;(t.end = Je.getPos(e)), (t.source = Bt(t.start.offset, e))
    }
    function R6(t) {
      let e = {
        type: 6,
        name: t.rawName,
        nameLoc: _t(t.loc.start.offset, t.loc.start.offset + t.rawName.length),
        value: void 0,
        loc: t.loc,
      }
      if (t.exp) {
        let s = t.exp.loc
        s.end.offset < t.loc.end.offset &&
          (s.start.offset--, s.start.column--, s.end.offset++, s.end.column++),
          (e.value = { type: 2, content: t.exp.content, loc: s })
      }
      return e
    }
    function tc(t, e = !1, s, i = 0, r = 0) {
      let n = Pe(t, e, s, i)
      if (!e && Be.prefixIdentifiers && r !== 3 && t.trim()) {
        if (Ci(t)) return (n.ast = null), n
        try {
          let a = Be.expressionPlugins,
            o = { plugins: a ? [...a, 'typescript'] : ['typescript'] }
          r === 2
            ? (n.ast = co.parse(` ${t} `, o).program)
            : r === 1
            ? (n.ast = co.parseExpression(`(${t})=>{}`, o))
            : (n.ast = co.parseExpression(`(${t})`, o))
        } catch (a) {
          ;(n.ast = !1), Qt(45, s.start.offset, a.message)
        }
      }
      return n
    }
    function Qt(t, e, s) {
      Be.onError(Xe(t, _t(e, e), void 0, s))
    }
    function L6() {
      Je.reset(),
        (jt = null),
        (Re = null),
        (Os = ''),
        (Ni = -1),
        (an = -1),
        (ft.length = 0)
    }
    function tE(t, e) {
      if ((L6(), (vi = t), (Be = re.extend({}, Wb)), e)) {
        let r
        for (r in e) e[r] != null && (Be[r] = e[r])
      }
      Be.decodeEntities &&
        console.warn(
          '[@vue/compiler-core] decodeEntities option is passed but will be ignored in non-browser builds.'
        ),
        (Je.mode =
          Be.parseMode === 'html' ? 1 : Be.parseMode === 'sfc' ? 2 : 0),
        (Je.inXML = Be.ns === 1 || Be.ns === 2)
      let s = e && e.delimiters
      s && ((Je.delimiterOpen = Jl(s[0])), (Je.delimiterClose = Jl(s[1])))
      let i = (_o = Cb([], t))
      return (
        Je.parse(vi),
        (i.loc = _t(0, t.length)),
        (i.children = Zb(i.children)),
        (_o = null),
        i
      )
    }
    function k6(t, e) {
      sc(t, e, sE(t, t.children[0]))
    }
    function sE(t, e) {
      let { children: s } = t
      return s.length === 1 && e.type === 1 && !So(e)
    }
    function sc(t, e, s = !1) {
      let { children: i } = t,
        r = i.length,
        n = 0
      for (let a = 0; a < i.length; a++) {
        let o = i[a]
        if (o.type === 1 && o.tagType === 0) {
          let u = s ? 0 : ws(o, e)
          if (u > 0) {
            if (u >= 2) {
              ;(o.codegenNode.patchFlag = -1),
                (o.codegenNode = e.hoist(o.codegenNode)),
                n++
              continue
            }
          } else {
            let l = o.codegenNode
            if (l.type === 13) {
              let c = l.patchFlag
              if ((c === void 0 || c === 512 || c === 1) && rE(o, e) >= 2) {
                let f = nE(o)
                f && (l.props = e.hoist(f))
              }
              l.dynamicProps && (l.dynamicProps = e.hoist(l.dynamicProps))
            }
          }
        }
        if (o.type === 1) {
          let u = o.tagType === 1
          u && e.scopes.vSlot++, sc(o, e), u && e.scopes.vSlot--
        } else if (o.type === 11) sc(o, e, o.children.length === 1)
        else if (o.type === 9)
          for (let u = 0; u < o.branches.length; u++)
            sc(o.branches[u], e, o.branches[u].children.length === 1)
      }
      if (
        (n && e.transformHoist && e.transformHoist(i, e, t),
        n &&
          n === r &&
          t.type === 1 &&
          t.tagType === 0 &&
          t.codegenNode &&
          t.codegenNode.type === 13 &&
          re.isArray(t.codegenNode.children))
      ) {
        let a = e.hoist(ra(t.codegenNode.children))
        e.hmr && (a.content = `[...${a.content}]`), (t.codegenNode.children = a)
      }
    }
    function ws(t, e) {
      let { constantCache: s } = e
      switch (t.type) {
        case 1:
          if (t.tagType !== 0) return 0
          let i = s.get(t)
          if (i !== void 0) return i
          let r = t.codegenNode
          if (
            r.type !== 13 ||
            (r.isBlock &&
              t.tag !== 'svg' &&
              t.tag !== 'foreignObject' &&
              t.tag !== 'math')
          )
            return 0
          if (r.patchFlag === void 0) {
            let a = 3,
              o = rE(t, e)
            if (o === 0) return s.set(t, 0), 0
            o < a && (a = o)
            for (let u = 0; u < t.children.length; u++) {
              let l = ws(t.children[u], e)
              if (l === 0) return s.set(t, 0), 0
              l < a && (a = l)
            }
            if (a > 1)
              for (let u = 0; u < t.props.length; u++) {
                let l = t.props[u]
                if (l.type === 7 && l.name === 'bind' && l.exp) {
                  let c = ws(l.exp, e)
                  if (c === 0) return s.set(t, 0), 0
                  c < a && (a = c)
                }
              }
            if (r.isBlock) {
              for (let u = 0; u < t.props.length; u++)
                if (t.props[u].type === 7) return s.set(t, 0), 0
              e.removeHelper(nr),
                e.removeHelper(rn(e.inSSR, r.isComponent)),
                (r.isBlock = !1),
                e.helper(sn(e.inSSR, r.isComponent))
            }
            return s.set(t, a), a
          } else return s.set(t, 0), 0
        case 2:
        case 3:
          return 3
        case 9:
        case 11:
        case 10:
          return 0
        case 5:
        case 12:
          return ws(t.content, e)
        case 4:
          return t.constType
        case 8:
          let n = 3
          for (let a = 0; a < t.children.length; a++) {
            let o = t.children[a]
            if (re.isString(o) || re.isSymbol(o)) continue
            let u = ws(o, e)
            if (u === 0) return 0
            u < n && (n = u)
          }
          return n
        default:
          return 0
      }
    }
    var D6 = new Set([Vl, Ul, ta, sa])
    function iE(t, e) {
      if (t.type === 14 && !re.isString(t.callee) && D6.has(t.callee)) {
        let s = t.arguments[0]
        if (s.type === 4) return ws(s, e)
        if (s.type === 14) return iE(s, e)
      }
      return 0
    }
    function rE(t, e) {
      let s = 3,
        i = nE(t)
      if (i && i.type === 15) {
        let { properties: r } = i
        for (let n = 0; n < r.length; n++) {
          let { key: a, value: o } = r[n],
            u = ws(a, e)
          if (u === 0) return u
          u < s && (s = u)
          let l
          if (
            (o.type === 4
              ? (l = ws(o, e))
              : o.type === 14
              ? (l = iE(o, e))
              : (l = 0),
            l === 0)
          )
            return l
          l < s && (s = l)
        }
      }
      return s
    }
    function nE(t) {
      let e = t.codegenNode
      if (e.type === 13) return e.props
    }
    function aE(
      t,
      {
        filename: e = '',
        prefixIdentifiers: s = !1,
        hoistStatic: i = !1,
        hmr: r = !1,
        cacheHandlers: n = !1,
        nodeTransforms: a = [],
        directiveTransforms: o = {},
        transformHoist: u = null,
        isBuiltInComponent: l = re.NOOP,
        isCustomElement: c = re.NOOP,
        expressionPlugins: f = [],
        scopeId: h = null,
        slotted: p = !0,
        ssr: m = !1,
        inSSR: y = !1,
        ssrCssVars: x = '',
        bindingMetadata: C = re.EMPTY_OBJ,
        inline: E = !1,
        isTS: g = !1,
        onError: S = Rp,
        onWarn: _ = Rb,
        compatConfig: I,
      }
    ) {
      let k = e.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/),
        L = {
          filename: e,
          selfName: k && re.capitalize(re.camelize(k[1])),
          prefixIdentifiers: s,
          hoistStatic: i,
          hmr: r,
          cacheHandlers: n,
          nodeTransforms: a,
          directiveTransforms: o,
          transformHoist: u,
          isBuiltInComponent: l,
          isCustomElement: c,
          expressionPlugins: f,
          scopeId: h,
          slotted: p,
          ssr: m,
          inSSR: y,
          ssrCssVars: x,
          bindingMetadata: C,
          inline: E,
          isTS: g,
          onError: S,
          onWarn: _,
          compatConfig: I,
          root: t,
          helpers: new Map(),
          components: new Set(),
          directives: new Set(),
          hoists: [],
          imports: [],
          constantCache: new WeakMap(),
          temps: 0,
          cached: 0,
          identifiers: Object.create(null),
          scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 },
          parent: null,
          grandParent: null,
          currentNode: t,
          childIndex: 0,
          inVOnce: !1,
          helper(v) {
            let A = L.helpers.get(v) || 0
            return L.helpers.set(v, A + 1), v
          },
          removeHelper(v) {
            let A = L.helpers.get(v)
            if (A) {
              let V = A - 1
              V ? L.helpers.set(v, V) : L.helpers.delete(v)
            }
          },
          helperString(v) {
            return `_${ns[L.helper(v)]}`
          },
          replaceNode(v) {
            {
              if (!L.currentNode)
                throw new Error('Node being replaced is already removed.')
              if (!L.parent) throw new Error('Cannot replace root node.')
            }
            L.parent.children[L.childIndex] = L.currentNode = v
          },
          removeNode(v) {
            if (!L.parent) throw new Error('Cannot remove root node.')
            let A = L.parent.children,
              V = v ? A.indexOf(v) : L.currentNode ? L.childIndex : -1
            if (V < 0)
              throw new Error(
                'node being removed is not a child of current parent'
              )
            !v || v === L.currentNode
              ? ((L.currentNode = null), L.onNodeRemoved())
              : L.childIndex > V && (L.childIndex--, L.onNodeRemoved()),
              L.parent.children.splice(V, 1)
          },
          onNodeRemoved: re.NOOP,
          addIdentifiers(v) {
            re.isString(v)
              ? N(v)
              : v.identifiers
              ? v.identifiers.forEach(N)
              : v.type === 4 && N(v.content)
          },
          removeIdentifiers(v) {
            re.isString(v)
              ? O(v)
              : v.identifiers
              ? v.identifiers.forEach(O)
              : v.type === 4 && O(v.content)
          },
          hoist(v) {
            re.isString(v) && (v = Pe(v)), L.hoists.push(v)
            let A = Pe(`_hoisted_${L.hoists.length}`, !1, v.loc, 2)
            return (A.hoisted = v), A
          },
          cache(v, A = !1) {
            return vb(L.cached++, v, A)
          },
        }
      L.filters = new Set()
      function N(v) {
        let { identifiers: A } = L
        A[v] === void 0 && (A[v] = 0), A[v]++
      }
      function O(v) {
        L.identifiers[v]--
      }
      return L
    }
    function oE(t, e) {
      let s = aE(t, e)
      xo(t, s),
        e.hoistStatic && k6(t, s),
        e.ssr || F6(t, s),
        (t.helpers = new Set([...s.helpers.keys()])),
        (t.components = [...s.components]),
        (t.directives = [...s.directives]),
        (t.imports = s.imports),
        (t.hoists = s.hoists),
        (t.temps = s.temps),
        (t.cached = s.cached),
        (t.transformed = !0),
        (t.filters = [...s.filters])
    }
    function F6(t, e) {
      let { helper: s } = e,
        { children: i } = t
      if (i.length === 1) {
        let r = i[0]
        if (sE(t, r) && r.codegenNode) {
          let n = r.codegenNode
          n.type === 13 && zl(n, e), (t.codegenNode = n)
        } else t.codegenNode = r
      } else if (i.length > 1) {
        let r = 64,
          n = re.PatchFlagNames[64]
        i.filter((a) => a.type !== 3).length === 1 &&
          ((r |= 2048), (n += `, ${re.PatchFlagNames[2048]}`)),
          (t.codegenNode = ia(
            e,
            s(Qn),
            void 0,
            t.children,
            r,
            void 0,
            void 0,
            !0,
            void 0,
            !1
          ))
      }
    }
    function B6(t, e) {
      let s = 0,
        i = () => {
          s--
        }
      for (; s < t.children.length; s++) {
        let r = t.children[s]
        re.isString(r) ||
          ((e.grandParent = e.parent),
          (e.parent = t),
          (e.childIndex = s),
          (e.onNodeRemoved = i),
          xo(r, e))
      }
    }
    function xo(t, e) {
      e.currentNode = t
      let { nodeTransforms: s } = e,
        i = []
      for (let n = 0; n < s.length; n++) {
        let a = s[n](t, e)
        if ((a && (re.isArray(a) ? i.push(...a) : i.push(a)), e.currentNode))
          t = e.currentNode
        else return
      }
      switch (t.type) {
        case 3:
          e.ssr || e.helper(ea)
          break
        case 5:
          e.ssr || e.helper(Bl)
          break
        case 9:
          for (let n = 0; n < t.branches.length; n++) xo(t.branches[n], e)
          break
        case 10:
        case 11:
        case 1:
        case 0:
          B6(t, e)
          break
      }
      e.currentNode = t
      let r = i.length
      for (; r--; ) i[r]()
    }
    function Gp(t, e) {
      let s = re.isString(t) ? (i) => i === t : (i) => t.test(i)
      return (i, r) => {
        if (i.type === 1) {
          let { props: n } = i
          if (i.tagType === 3 && n.some(qp)) return
          let a = []
          for (let o = 0; o < n.length; o++) {
            let u = n[o]
            if (u.type === 7 && s(u.name)) {
              n.splice(o, 1), o--
              let l = e(i, u, r)
              l && a.push(l)
            }
          }
          return a
        }
      }
    }
    var Ao = '/*#__PURE__*/',
      ic = (t) => `${ns[t]}: _${ns[t]}`
    function uE(
      t,
      {
        mode: e = 'function',
        prefixIdentifiers: s = e === 'module',
        sourceMap: i = !1,
        filename: r = 'template.vue.html',
        scopeId: n = null,
        optimizeImports: a = !1,
        runtimeGlobalName: o = 'Vue',
        runtimeModuleName: u = 'vue',
        ssrRuntimeModuleName: l = 'vue/server-renderer',
        ssr: c = !1,
        isTS: f = !1,
        inSSR: h = !1,
      }
    ) {
      let p = {
        mode: e,
        prefixIdentifiers: s,
        sourceMap: i,
        filename: r,
        scopeId: n,
        optimizeImports: a,
        runtimeGlobalName: o,
        runtimeModuleName: u,
        ssrRuntimeModuleName: l,
        ssr: c,
        isTS: f,
        inSSR: h,
        source: t.source,
        code: '',
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: !1,
        map: void 0,
        helper(x) {
          return `_${ns[x]}`
        },
        push(x, C = -2, E) {
          if (((p.code += x), p.map)) {
            if (E) {
              let g
              if (E.type === 4 && !E.isStatic) {
                let S = E.content.replace(/^_ctx\./, '')
                S !== E.content && Ci(S) && (g = S)
              }
              y(E.loc.start, g)
            }
            C === -3
              ? $p(p, x)
              : ((p.offset += x.length),
                C === -2
                  ? (p.column += x.length)
                  : (C === -1 && (C = x.length - 1),
                    p.line++,
                    (p.column = x.length - C))),
              E && E.loc !== Et && y(E.loc.end)
          }
        },
        indent() {
          m(++p.indentLevel)
        },
        deindent(x = !1) {
          x ? --p.indentLevel : m(--p.indentLevel)
        },
        newline() {
          m(p.indentLevel)
        },
      }
      function m(x) {
        p.push(
          `
` + '  '.repeat(x),
          0
        )
      }
      function y(x, C = null) {
        let { _names: E, _mappings: g } = p.map
        C !== null && !E.has(C) && E.add(C),
          g.add({
            originalLine: x.line,
            originalColumn: x.column - 1,
            generatedLine: p.line,
            generatedColumn: p.column - 1,
            source: r,
            name: C,
          })
      }
      return (
        i &&
          ((p.map = new t6.SourceMapGenerator()),
          p.map.setSourceContent(r, p.source),
          p.map._sources.add(r)),
        p
      )
    }
    function lE(t, e = {}) {
      let s = uE(t, e)
      e.onContextCreated && e.onContextCreated(s)
      let {
          mode: i,
          push: r,
          prefixIdentifiers: n,
          indent: a,
          deindent: o,
          newline: u,
          scopeId: l,
          ssr: c,
        } = s,
        f = Array.from(t.helpers),
        h = f.length > 0,
        p = !n && i !== 'module',
        m = l != null && i === 'module',
        y = !!e.inline,
        x = y ? uE(t, e) : s
      i === 'module' ? U6(t, x, m, y) : V6(t, x)
      let C = c ? 'ssrRender' : 'render',
        E = c ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']
      e.bindingMetadata &&
        !e.inline &&
        E.push('$props', '$setup', '$data', '$options')
      let g = e.isTS ? E.map((S) => `${S}: any`).join(',') : E.join(', ')
      if (
        (r(y ? `(${g}) => {` : `function ${C}(${g}) {`),
        a(),
        p &&
          (r('with (_ctx) {'),
          a(),
          h &&
            (r(
              `const { ${f.map(ic).join(', ')} } = _Vue
`,
              -1
            ),
            u())),
        t.components.length &&
          (Wp(t.components, 'component', s),
          (t.directives.length || t.temps > 0) && u()),
        t.directives.length &&
          (Wp(t.directives, 'directive', s), t.temps > 0 && u()),
        t.filters && t.filters.length && (u(), Wp(t.filters, 'filter', s), u()),
        t.temps > 0)
      ) {
        r('let ')
        for (let S = 0; S < t.temps; S++) r(`${S > 0 ? ', ' : ''}_temp${S}`)
      }
      return (
        (t.components.length || t.directives.length || t.temps) &&
          (r(
            `
`,
            0
          ),
          u()),
        c || r('return '),
        t.codegenNode ? tt(t.codegenNode, s) : r('null'),
        p && (o(), r('}')),
        o(),
        r('}'),
        {
          ast: t,
          code: s.code,
          preamble: y ? x.code : '',
          map: s.map ? s.map.toJSON() : void 0,
        }
      )
    }
    function V6(t, e) {
      let {
          ssr: s,
          prefixIdentifiers: i,
          push: r,
          newline: n,
          runtimeModuleName: a,
          runtimeGlobalName: o,
          ssrRuntimeModuleName: u,
        } = e,
        l = s ? `require(${JSON.stringify(a)})` : o,
        c = Array.from(t.helpers)
      if (c.length > 0) {
        if (i)
          r(
            `const { ${c.map(ic).join(', ')} } = ${l}
`,
            -1
          )
        else if (
          (r(
            `const _Vue = ${l}
`,
            -1
          ),
          t.hoists.length)
        ) {
          let f = [Ol, wl, ea, Ml, Np]
            .filter((h) => c.includes(h))
            .map(ic)
            .join(', ')
          r(
            `const { ${f} } = _Vue
`,
            -1
          )
        }
      }
      t.ssrHelpers &&
        t.ssrHelpers.length &&
        r(
          `const { ${t.ssrHelpers.map(ic).join(', ')} } = require("${u}")
`,
          -1
        ),
        cE(t.hoists, e),
        n(),
        r('return ')
    }
    function U6(t, e, s, i) {
      let {
        push: r,
        newline: n,
        optimizeImports: a,
        runtimeModuleName: o,
        ssrRuntimeModuleName: u,
      } = e
      if (
        (s && t.hoists.length && (t.helpers.add(ql), t.helpers.add(Kl)),
        t.helpers.size)
      ) {
        let l = Array.from(t.helpers)
        a
          ? (r(
              `import { ${l
                .map((c) => ns[c])
                .join(', ')} } from ${JSON.stringify(o)}
`,
              -1
            ),
            r(
              `
// Binding optimization for webpack code-split
const ${l.map((c) => `_${ns[c]} = ${ns[c]}`).join(', ')}
`,
              -1
            ))
          : r(
              `import { ${l
                .map((c) => `${ns[c]} as _${ns[c]}`)
                .join(', ')} } from ${JSON.stringify(o)}
`,
              -1
            )
      }
      t.ssrHelpers &&
        t.ssrHelpers.length &&
        r(
          `import { ${t.ssrHelpers
            .map((l) => `${ns[l]} as _${ns[l]}`)
            .join(', ')} } from "${u}"
`,
          -1
        ),
        t.imports.length && (H6(t.imports, e), n()),
        cE(t.hoists, e),
        n(),
        i || r('export ')
    }
    function Wp(t, e, { helper: s, push: i, newline: r, isTS: n }) {
      let a = s(e === 'filter' ? kl : e === 'component' ? ho : Ll)
      for (let o = 0; o < t.length; o++) {
        let u = t[o],
          l = u.endsWith('__self')
        l && (u = u.slice(0, -6)),
          i(
            `const ${nn(u, e)} = ${a}(${JSON.stringify(u)}${
              l ? ', true' : ''
            })${n ? '!' : ''}`
          ),
          o < t.length - 1 && r()
      }
    }
    function cE(t, e) {
      if (!t.length) return
      e.pure = !0
      let { push: s, newline: i, helper: r, scopeId: n, mode: a } = e,
        o = n != null && a !== 'function'
      if ((i(), o)) {
        let u = e.isTS ? '(n: any)' : 'n'
        s(`const _withScopeId = ${u} => (${r(ql)}("${n}"),n=n(),${r(Kl)}(),n)`),
          i()
      }
      for (let u = 0; u < t.length; u++) {
        let l = t[u]
        if (l) {
          let c = o && l.type === 13
          s(
            `const _hoisted_${u + 1} = ${c ? `${Ao} _withScopeId(() => ` : ''}`
          ),
            tt(l, e),
            c && s(')'),
            i()
        }
      }
      e.pure = !1
    }
    function H6(t, e) {
      !t.length ||
        t.forEach((s) => {
          e.push('import '),
            tt(s.exp, e),
            e.push(` from '${s.path}'`),
            e.newline()
        })
    }
    function $6(t) {
      return (
        re.isString(t) ||
        t.type === 4 ||
        t.type === 2 ||
        t.type === 5 ||
        t.type === 8
      )
    }
    function rc(t, e) {
      let s = t.length > 3 || t.some((i) => re.isArray(i) || !$6(i))
      e.push('['), s && e.indent(), oa(t, e, s), s && e.deindent(), e.push(']')
    }
    function oa(t, e, s = !1, i = !0) {
      let { push: r, newline: n } = e
      for (let a = 0; a < t.length; a++) {
        let o = t[a]
        re.isString(o) ? r(o, -3) : re.isArray(o) ? rc(o, e) : tt(o, e),
          a < t.length - 1 && (s ? (i && r(','), n()) : i && r(', '))
      }
    }
    function tt(t, e) {
      if (re.isString(t)) {
        e.push(t, -3)
        return
      }
      if (re.isSymbol(t)) {
        e.push(e.helper(t))
        return
      }
      switch (t.type) {
        case 1:
        case 9:
        case 11:
          jp(
            t.codegenNode != null,
            'Codegen node is missing for element/if/for node. Apply appropriate transforms first.'
          ),
            tt(t.codegenNode, e)
          break
        case 2:
          j6(t, e)
          break
        case 4:
          fE(t, e)
          break
        case 5:
          q6(t, e)
          break
        case 12:
          tt(t.codegenNode, e)
          break
        case 8:
          hE(t, e)
          break
        case 3:
          X6(t, e)
          break
        case 13:
          G6(t, e)
          break
        case 14:
          z6(t, e)
          break
        case 15:
          J6(t, e)
          break
        case 17:
          Y6(t, e)
          break
        case 18:
          Q6(t, e)
          break
        case 19:
          Z6(t, e)
          break
        case 20:
          eO(t, e)
          break
        case 21:
          oa(t.body, e, !0, !1)
          break
        case 22:
          tO(t, e)
          break
        case 23:
          pE(t, e)
          break
        case 24:
          sO(t, e)
          break
        case 25:
          iO(t, e)
          break
        case 26:
          rO(t, e)
          break
        case 10:
          break
        default:
          return jp(!1, `unhandled codegen node type: ${t.type}`), t
      }
    }
    function j6(t, e) {
      e.push(JSON.stringify(t.content), -3, t)
    }
    function fE(t, e) {
      let { content: s, isStatic: i } = t
      e.push(i ? JSON.stringify(s) : s, -3, t)
    }
    function q6(t, e) {
      let { push: s, helper: i, pure: r } = e
      r && s(Ao), s(`${i(Bl)}(`), tt(t.content, e), s(')')
    }
    function hE(t, e) {
      for (let s = 0; s < t.children.length; s++) {
        let i = t.children[s]
        re.isString(i) ? e.push(i, -3) : tt(i, e)
      }
    }
    function K6(t, e) {
      let { push: s } = e
      if (t.type === 8) s('['), hE(t, e), s(']')
      else if (t.isStatic) {
        let i = Ci(t.content) ? t.content : JSON.stringify(t.content)
        s(i, -2, t)
      } else s(`[${t.content}]`, -3, t)
    }
    function X6(t, e) {
      let { push: s, helper: i, pure: r } = e
      r && s(Ao), s(`${i(ea)}(${JSON.stringify(t.content)})`, -3, t)
    }
    function G6(t, e) {
      let { push: s, helper: i, pure: r } = e,
        {
          tag: n,
          props: a,
          children: o,
          patchFlag: u,
          dynamicProps: l,
          directives: c,
          isBlock: f,
          disableTracking: h,
          isComponent: p,
        } = t,
        m
      if (u)
        if (u < 0) m = u + ` /* ${re.PatchFlagNames[u]} */`
        else {
          let x = Object.keys(re.PatchFlagNames)
            .map(Number)
            .filter((C) => C > 0 && u & C)
            .map((C) => re.PatchFlagNames[C])
            .join(', ')
          m = u + ` /* ${x} */`
        }
      c && s(i(Dl) + '('), f && s(`(${i(nr)}(${h ? 'true' : ''}), `), r && s(Ao)
      let y = f ? rn(e.inSSR, p) : sn(e.inSSR, p)
      s(i(y) + '(', -2, t),
        oa(W6([n, a, o, m, l]), e),
        s(')'),
        f && s(')'),
        c && (s(', '), tt(c, e), s(')'))
    }
    function W6(t) {
      let e = t.length
      for (; e-- && t[e] == null; );
      return t.slice(0, e + 1).map((s) => s || 'null')
    }
    function z6(t, e) {
      let { push: s, helper: i, pure: r } = e,
        n = re.isString(t.callee) ? t.callee : i(t.callee)
      r && s(Ao), s(n + '(', -2, t), oa(t.arguments, e), s(')')
    }
    function J6(t, e) {
      let { push: s, indent: i, deindent: r, newline: n } = e,
        { properties: a } = t
      if (!a.length) {
        s('{}', -2, t)
        return
      }
      let o = a.length > 1 || a.some((u) => u.value.type !== 4)
      s(o ? '{' : '{ '), o && i()
      for (let u = 0; u < a.length; u++) {
        let { key: l, value: c } = a[u]
        K6(l, e), s(': '), tt(c, e), u < a.length - 1 && (s(','), n())
      }
      o && r(), s(o ? '}' : ' }')
    }
    function Y6(t, e) {
      rc(t.elements, e)
    }
    function Q6(t, e) {
      let { push: s, indent: i, deindent: r } = e,
        { params: n, returns: a, body: o, newline: u, isSlot: l } = t
      l && s(`_${ns[Xl]}(`),
        s('(', -2, t),
        re.isArray(n) ? oa(n, e) : n && tt(n, e),
        s(') => '),
        (u || o) && (s('{'), i()),
        a
          ? (u && s('return '), re.isArray(a) ? rc(a, e) : tt(a, e))
          : o && tt(o, e),
        (u || o) && (r(), s('}')),
        l && (t.isNonScopedSlot && s(', undefined, true'), s(')'))
    }
    function Z6(t, e) {
      let { test: s, consequent: i, alternate: r, newline: n } = t,
        { push: a, indent: o, deindent: u, newline: l } = e
      if (s.type === 4) {
        let f = !Ci(s.content)
        f && a('('), fE(s, e), f && a(')')
      } else a('('), tt(s, e), a(')')
      n && o(),
        e.indentLevel++,
        n || a(' '),
        a('? '),
        tt(i, e),
        e.indentLevel--,
        n && l(),
        n || a(' '),
        a(': ')
      let c = r.type === 19
      c || e.indentLevel++, tt(r, e), c || e.indentLevel--, n && u(!0)
    }
    function eO(t, e) {
      let { push: s, helper: i, indent: r, deindent: n, newline: a } = e
      s(`_cache[${t.index}] || (`),
        t.isVOnce && (r(), s(`${i(mo)}(-1),`), a(), s('(')),
        s(`_cache[${t.index}] = `),
        tt(t.value, e),
        t.isVOnce &&
          (s(`).cacheIndex = ${t.index},`),
          a(),
          s(`${i(mo)}(1),`),
          a(),
          s(`_cache[${t.index}]`),
          n()),
        s(')')
    }
    function tO(t, e) {
      let { push: s, indent: i, deindent: r } = e
      s('`')
      let n = t.elements.length,
        a = n > 3
      for (let o = 0; o < n; o++) {
        let u = t.elements[o]
        re.isString(u)
          ? s(u.replace(/(`|\$|\\)/g, '\\$1'), -3)
          : (s('${'), a && i(), tt(u, e), a && r(), s('}'))
      }
      s('`')
    }
    function pE(t, e) {
      let { push: s, indent: i, deindent: r } = e,
        { test: n, consequent: a, alternate: o } = t
      s('if ('),
        tt(n, e),
        s(') {'),
        i(),
        tt(a, e),
        r(),
        s('}'),
        o &&
          (s(' else '),
          o.type === 23 ? pE(o, e) : (s('{'), i(), tt(o, e), r(), s('}')))
    }
    function sO(t, e) {
      tt(t.left, e), e.push(' = '), tt(t.right, e)
    }
    function iO(t, e) {
      e.push('('), oa(t.expressions, e), e.push(')')
    }
    function rO({ returns: t }, e) {
      e.push('return '), re.isArray(t) ? rc(t, e) : tt(t, e)
    }
    var nO = re.makeMap('true,false,null,this'),
      dE = (t, e) => {
        if (t.type === 5) t.content = qt(t.content, e)
        else if (t.type === 1)
          for (let s = 0; s < t.props.length; s++) {
            let i = t.props[s]
            if (i.type === 7 && i.name !== 'for') {
              let r = i.exp,
                n = i.arg
              r &&
                r.type === 4 &&
                !(i.name === 'on' && n) &&
                (i.exp = qt(r, e, i.name === 'slot')),
                n && n.type === 4 && !n.isStatic && (i.arg = qt(n, e))
            }
          }
      }
    function qt(t, e, s = !1, i = !1, r = Object.create(e.identifiers)) {
      if (!e.prefixIdentifiers || !t.content.trim()) return t
      let { inline: n, bindingMetadata: a } = e,
        o = (y, x, C) => {
          let E = re.hasOwn(a, y) && a[y]
          if (n) {
            let g = x && x.type === 'AssignmentExpression' && x.left === C,
              S = x && x.type === 'UpdateExpression' && x.argument === C,
              _ = x && Lp(x, f),
              I = x && Fb(f),
              k = (L) => {
                let N = `${e.helperString(go)}(${L})`
                return I ? `(${N})` : N
              }
            if (mE(E) || E === 'setup-reactive-const' || r[y]) return y
            if (E === 'setup-ref') return `${y}.value`
            if (E === 'setup-maybe-ref')
              return g || S || _ ? `${y}.value` : k(y)
            if (E === 'setup-let')
              if (g) {
                let { right: L, operator: N } = x,
                  O = u.slice(L.start - 1, L.end - 1),
                  v = zp(qt(Pe(O, !1), e, !1, !1, h))
                return `${e.helperString(yo)}(${y})${
                  e.isTS
                    ? ` //@ts-ignore
`
                    : ''
                } ? ${y}.value ${N} ${v} : ${y}`
              } else if (S) {
                ;(C.start = x.start), (C.end = x.end)
                let { prefix: L, operator: N } = x,
                  O = L ? N : '',
                  v = L ? '' : N
                return `${e.helperString(yo)}(${y})${
                  e.isTS
                    ? ` //@ts-ignore
`
                    : ''
                } ? ${O}${y}.value${v} : ${O}${y}${v}`
              } else return _ ? y : k(y)
            else {
              if (E === 'props') return re.genPropsAccessExp(y)
              if (E === 'props-aliased')
                return re.genPropsAccessExp(a.__propsAliases[y])
            }
          } else {
            if ((E && E.startsWith('setup')) || E === 'literal-const')
              return `$setup.${y}`
            if (E === 'props-aliased') return `$props['${a.__propsAliases[y]}']`
            if (E) return `$${E}.${y}`
          }
          return `_ctx.${y}`
        },
        u = t.content,
        l = t.ast
      if (l === !1) return t
      if (l === null || (!l && Ci(u))) {
        let y = e.identifiers[u],
          x = re.isGloballyAllowed(u),
          C = nO(u)
        return (
          !s && !y && !C && (!x || a[u])
            ? (mE(a[u]) && (t.constType = 1), (t.content = o(u)))
            : y || (C ? (t.constType = 3) : (t.constType = 2)),
          t
        )
      }
      if (!l) {
        let y = i ? ` ${u} ` : `(${u})${s ? '=>{}' : ''}`
        try {
          l = co.parseExpression(y, {
            sourceType: 'module',
            plugins: e.expressionPlugins,
          })
        } catch (x) {
          return e.onError(Xe(45, t.loc, void 0, x.message)), t
        }
      }
      let c = [],
        f = [],
        h = Object.create(e.identifiers)
      kb(
        l,
        (y, x, C, E, g) => {
          if ($b(y, x) || y.name.startsWith('_filter_')) return
          let S = E && aO(y)
          S && !g
            ? (Dp(x) && x.shorthand && (y.prefix = `${y.name}: `),
              (y.name = o(y.name, x, y)),
              c.push(y))
            : (!(S && g) &&
                (!x ||
                  (x.type !== 'CallExpression' &&
                    x.type !== 'NewExpression' &&
                    x.type !== 'MemberExpression')) &&
                (y.isConstant = !0),
              c.push(y))
        },
        !0,
        f,
        h
      )
      let p = []
      c.sort((y, x) => y.start - x.start),
        c.forEach((y, x) => {
          let C = y.start - 1,
            E = y.end - 1,
            g = c[x - 1],
            S = u.slice(g ? g.end - 1 : 0, C)
          ;(S.length || y.prefix) && p.push(S + (y.prefix || ''))
          let _ = u.slice(C, E)
          p.push(
            Pe(
              y.name,
              !1,
              {
                start: Hp(t.loc.start, _, C),
                end: Hp(t.loc.start, _, E),
                source: _,
              },
              y.isConstant ? 3 : 0
            )
          ),
            x === c.length - 1 && E < u.length && p.push(u.slice(E))
        })
      let m
      return (
        p.length
          ? ((m = bs(p, t.loc)), (m.ast = l))
          : ((m = t), (m.constType = 3)),
        (m.identifiers = Object.keys(h)),
        m
      )
    }
    function aO(t) {
      return !(re.isGloballyAllowed(t.name) || t.name === 'require')
    }
    function zp(t) {
      return re.isString(t)
        ? t
        : t.type === 4
        ? t.content
        : t.children.map(zp).join('')
    }
    function mE(t) {
      return t === 'setup-const' || t === 'literal-const'
    }
    var oO = Gp(/^(if|else|else-if)$/, (t, e, s) =>
      gE(t, e, s, (i, r, n) => {
        let a = s.parent.children,
          o = a.indexOf(i),
          u = 0
        for (; o-- >= 0; ) {
          let l = a[o]
          l && l.type === 9 && (u += l.branches.length)
        }
        return () => {
          if (n) i.codegenNode = bE(r, u, s)
          else {
            let l = lO(i.codegenNode)
            l.alternate = bE(r, u + i.branches.length - 1, s)
          }
        }
      })
    )
    function gE(t, e, s, i) {
      if (e.name !== 'else' && (!e.exp || !e.exp.content.trim())) {
        let r = e.exp ? e.exp.loc : t.loc
        s.onError(Xe(28, e.loc)), (e.exp = Pe('true', !1, r))
      }
      if (
        (s.prefixIdentifiers && e.exp && (e.exp = qt(e.exp, s)),
        e.name === 'if')
      ) {
        let r = yE(t, e),
          n = { type: 9, loc: t.loc, branches: [r] }
        if ((s.replaceNode(n), i)) return i(n, r, !0)
      } else {
        let r = s.parent.children,
          n = [],
          a = r.indexOf(t)
        for (; a-- >= -1; ) {
          let o = r[a]
          if (o && o.type === 3) {
            s.removeNode(o), n.unshift(o)
            continue
          }
          if (o && o.type === 2 && !o.content.trim().length) {
            s.removeNode(o)
            continue
          }
          if (o && o.type === 9) {
            e.name === 'else-if' &&
              o.branches[o.branches.length - 1].condition === void 0 &&
              s.onError(Xe(30, t.loc)),
              s.removeNode()
            let u = yE(t, e)
            n.length &&
              !(
                s.parent &&
                s.parent.type === 1 &&
                (s.parent.tag === 'transition' || s.parent.tag === 'Transition')
              ) &&
              (u.children = [...n, ...u.children])
            {
              let c = u.userKey
              c &&
                o.branches.forEach(({ userKey: f }) => {
                  uO(f, c) && s.onError(Xe(29, u.userKey.loc))
                })
            }
            o.branches.push(u)
            let l = i && i(o, u, !1)
            xo(u, s), l && l(), (s.currentNode = null)
          } else s.onError(Xe(30, t.loc))
          break
        }
      }
    }
    function yE(t, e) {
      let s = t.tagType === 3
      return {
        type: 10,
        loc: t.loc,
        condition: e.name === 'else' ? void 0 : e.exp,
        children: s && !Ss(t, 'for') ? t.children : [t],
        userKey: Eo(t, 'key'),
        isTemplateIf: s,
      }
    }
    function bE(t, e, s) {
      return t.condition
        ? Wl(t.condition, EE(t, e, s), Dt(s.helper(ea), ['"v-if"', 'true']))
        : EE(t, e, s)
    }
    function EE(t, e, s) {
      let { helper: i } = s,
        r = mt('key', Pe(`${e}`, !1, Et, 2)),
        { children: n } = t,
        a = n[0]
      if (n.length !== 1 || a.type !== 1)
        if (n.length === 1 && a.type === 11) {
          let u = a.codegenNode
          return To(u, r, s), u
        } else {
          let u = 64,
            l = re.PatchFlagNames[64]
          return (
            !t.isTemplateIf &&
              n.filter((c) => c.type !== 3).length === 1 &&
              ((u |= 2048), (l += `, ${re.PatchFlagNames[2048]}`)),
            ia(s, i(Qn), ys([r]), n, u, void 0, void 0, !0, !1, !1, t.loc)
          )
        }
      else {
        let u = a.codegenNode,
          l = Xb(u)
        return l.type === 13 && zl(l, s), To(l, r, s), u
      }
    }
    function uO(t, e) {
      if (!t || t.type !== e.type) return !1
      if (t.type === 6) {
        if (t.value.content !== e.value.content) return !1
      } else {
        let s = t.exp,
          i = e.exp
        if (
          s.type !== i.type ||
          s.type !== 4 ||
          s.isStatic !== i.isStatic ||
          s.content !== i.content
        )
          return !1
      }
      return !0
    }
    function lO(t) {
      for (;;)
        if (t.type === 19)
          if (t.alternate.type === 19) t = t.alternate
          else return t
        else t.type === 20 && (t = t.value)
    }
    var SE = (t, e, s) => {
        let { modifiers: i, loc: r } = t,
          n = t.arg,
          { exp: a } = t
        if (a && a.type === 4 && !a.content.trim())
          return s.onError(Xe(34, r)), { props: [mt(n, Pe('', !0, r))] }
        if (!a) {
          if (n.type !== 4 || !n.isStatic)
            return s.onError(Xe(52, n.loc)), { props: [mt(n, Pe('', !0, r))] }
          TE(t, s), (a = t.exp)
        }
        return (
          n.type !== 4
            ? (n.children.unshift('('), n.children.push(') || ""'))
            : n.isStatic || (n.content = `${n.content} || ""`),
          i.includes('camel') &&
            (n.type === 4
              ? n.isStatic
                ? (n.content = re.camelize(n.content))
                : (n.content = `${s.helperString($l)}(${n.content})`)
              : (n.children.unshift(`${s.helperString($l)}(`),
                n.children.push(')'))),
          s.inSSR ||
            (i.includes('prop') && _E(n, '.'),
            i.includes('attr') && _E(n, '^')),
          { props: [mt(n, a)] }
        )
      },
      TE = (t, e) => {
        let s = t.arg,
          i = re.camelize(s.content)
        ;(t.exp = Pe(i, !1, s.loc)), (t.exp = qt(t.exp, e))
      },
      _E = (t, e) => {
        t.type === 4
          ? t.isStatic
            ? (t.content = e + t.content)
            : (t.content = `\`${e}\${${t.content}}\``)
          : (t.children.unshift(`'${e}' + (`), t.children.push(')'))
      },
      cO = Gp('for', (t, e, s) => {
        let { helper: i, removeHelper: r } = s
        return xE(t, e, s, (n) => {
          let a = Dt(i(Fl), [n.source]),
            o = aa(t),
            u = Ss(t, 'memo'),
            l = Eo(t, 'key', !1, !0)
          l && l.type === 7 && !l.exp && TE(l, s)
          let c =
              l &&
              (l.type === 6
                ? l.value
                  ? Pe(l.value.content, !0)
                  : void 0
                : l.exp),
            f = l && c ? mt('key', c) : null
          o &&
            (u && (u.exp = qt(u.exp, s)),
            f && l.type !== 6 && (f.value = qt(f.value, s)))
          let h = n.source.type === 4 && n.source.constType > 0,
            p = h ? 64 : l ? 128 : 256
          return (
            (n.codegenNode = ia(
              s,
              i(Qn),
              void 0,
              a,
              p,
              void 0,
              void 0,
              !0,
              !h,
              !1,
              t.loc
            )),
            () => {
              let m,
                { children: y } = n
              o &&
                t.children.some((E) => {
                  if (E.type === 1) {
                    let g = Eo(E, 'key')
                    if (g) return s.onError(Xe(33, g.loc)), !0
                  }
                })
              let x = y.length !== 1 || y[0].type !== 1,
                C = So(t)
                  ? t
                  : o && t.children.length === 1 && So(t.children[0])
                  ? t.children[0]
                  : null
              if (
                (C
                  ? ((m = C.codegenNode), o && f && To(m, f, s))
                  : x
                  ? (m = ia(
                      s,
                      i(Qn),
                      f ? ys([f]) : void 0,
                      t.children,
                      64,
                      void 0,
                      void 0,
                      !0,
                      void 0,
                      !1
                    ))
                  : ((m = y[0].codegenNode),
                    o && f && To(m, f, s),
                    m.isBlock !== !h &&
                      (m.isBlock
                        ? (r(nr), r(rn(s.inSSR, m.isComponent)))
                        : r(sn(s.inSSR, m.isComponent))),
                    (m.isBlock = !h),
                    m.isBlock
                      ? (i(nr), i(rn(s.inSSR, m.isComponent)))
                      : i(sn(s.inSSR, m.isComponent))),
                u)
              ) {
                let E = tn(nc(n.parseResult, [Pe('_cached')]))
                ;(E.body = Nb([
                  bs(['const _memo = (', u.exp, ')']),
                  bs([
                    'if (_cached',
                    ...(c ? [' && _cached.key === ', c] : []),
                    ` && ${s.helperString(wp)}(_cached, _memo)) return _cached`,
                  ]),
                  bs(['const _item = ', m]),
                  Pe('_item.memo = _memo'),
                  Pe('return _item'),
                ])),
                  a.arguments.push(E, Pe('_cache'), Pe(String(s.cached++)))
              } else a.arguments.push(tn(nc(n.parseResult), m, !0))
            }
          )
        })
      })
    function xE(t, e, s, i) {
      if (!e.exp) {
        s.onError(Xe(31, e.loc))
        return
      }
      let r = e.forParseResult
      if (!r) {
        s.onError(Xe(32, e.loc))
        return
      }
      Jp(r, s)
      let { addIdentifiers: n, removeIdentifiers: a, scopes: o } = s,
        { source: u, value: l, key: c, index: f } = r,
        h = {
          type: 11,
          loc: e.loc,
          source: u,
          valueAlias: l,
          keyAlias: c,
          objectIndexAlias: f,
          parseResult: r,
          children: aa(t) ? t.children : [t],
        }
      s.replaceNode(h),
        o.vFor++,
        s.prefixIdentifiers && (l && n(l), c && n(c), f && n(f))
      let p = i && i(h)
      return () => {
        o.vFor--,
          s.prefixIdentifiers && (l && a(l), c && a(c), f && a(f)),
          p && p()
      }
    }
    function Jp(t, e) {
      t.finalized ||
        (e.prefixIdentifiers &&
          ((t.source = qt(t.source, e)),
          t.key && (t.key = qt(t.key, e, !0)),
          t.index && (t.index = qt(t.index, e, !0)),
          t.value && (t.value = qt(t.value, e, !0))),
        (t.finalized = !0))
    }
    function nc({ value: t, key: e, index: s }, i = []) {
      return fO([t, e, s, ...i])
    }
    function fO(t) {
      let e = t.length
      for (; e-- && !t[e]; );
      return t.slice(0, e + 1).map((s, i) => s || Pe('_'.repeat(i + 1), !1))
    }
    var AE = Pe('undefined', !1),
      PE = (t, e) => {
        if (t.type === 1 && (t.tagType === 1 || t.tagType === 3)) {
          let s = Ss(t, 'slot')
          if (s) {
            let i = s.exp
            return (
              e.prefixIdentifiers && i && e.addIdentifiers(i),
              e.scopes.vSlot++,
              () => {
                e.prefixIdentifiers && i && e.removeIdentifiers(i),
                  e.scopes.vSlot--
              }
            )
          }
        }
      },
      CE = (t, e) => {
        let s
        if (aa(t) && t.props.some(qp) && (s = Ss(t, 'for'))) {
          let i = s.forParseResult
          if (i) {
            Jp(i, e)
            let { value: r, key: n, index: a } = i,
              { addIdentifiers: o, removeIdentifiers: u } = e
            return (
              r && o(r),
              n && o(n),
              a && o(a),
              () => {
                r && u(r), n && u(n), a && u(a)
              }
            )
          }
        }
      },
      hO = (t, e, s, i) => tn(t, s, !1, !0, s.length ? s[0].loc : i)
    function vE(t, e, s = hO) {
      e.helper(Xl)
      let { children: i, loc: r } = t,
        n = [],
        a = [],
        o = e.scopes.vSlot > 0 || e.scopes.vFor > 0
      !e.ssr && e.prefixIdentifiers && (o = as(t, e.identifiers))
      let u = Ss(t, 'slot', !0)
      if (u) {
        let { arg: x, exp: C } = u
        x && !qs(x) && (o = !0),
          n.push(mt(x || Pe('default', !0), s(C, void 0, i, r)))
      }
      let l = !1,
        c = !1,
        f = [],
        h = new Set(),
        p = 0
      for (let x = 0; x < i.length; x++) {
        let C = i[x],
          E
        if (!aa(C) || !(E = Ss(C, 'slot', !0))) {
          C.type !== 3 && f.push(C)
          continue
        }
        if (u) {
          e.onError(Xe(37, E.loc))
          break
        }
        l = !0
        let { children: g, loc: S } = C,
          { arg: _ = Pe('default', !0), exp: I, loc: k } = E,
          L
        qs(_) ? (L = _ ? _.content : 'default') : (o = !0)
        let N = Ss(C, 'for'),
          O = s(I, N, g, S),
          v,
          A
        if ((v = Ss(C, 'if'))) (o = !0), a.push(Wl(v.exp, ac(_, O, p++), AE))
        else if ((A = Ss(C, /^else(-if)?$/, !0))) {
          let V = x,
            se
          for (; V-- && ((se = i[V]), se.type === 3); );
          if (se && aa(se) && Ss(se, /^(else-)?if$/)) {
            let Y = a[a.length - 1]
            for (; Y.alternate.type === 19; ) Y = Y.alternate
            Y.alternate = A.exp ? Wl(A.exp, ac(_, O, p++), AE) : ac(_, O, p++)
          } else e.onError(Xe(30, A.loc))
        } else if (N) {
          o = !0
          let V = N.forParseResult
          V
            ? (Jp(V, e),
              a.push(Dt(e.helper(Fl), [V.source, tn(nc(V), ac(_, O), !0)])))
            : e.onError(Xe(32, N.loc))
        } else {
          if (L) {
            if (h.has(L)) {
              e.onError(Xe(38, k))
              continue
            }
            h.add(L), L === 'default' && (c = !0)
          }
          n.push(mt(_, O))
        }
      }
      if (!u) {
        let x = (C, E) => {
          let g = s(C, void 0, E, r)
          return e.compatConfig && (g.isNonScopedSlot = !0), mt('default', g)
        }
        l
          ? f.length &&
            f.some((C) => NE(C)) &&
            (c ? e.onError(Xe(39, f[0].loc)) : n.push(x(void 0, f)))
          : n.push(x(void 0, i))
      }
      let m = o ? 2 : oc(t.children) ? 3 : 1,
        y = ys(
          n.concat(mt('_', Pe(m + ` /* ${re.slotFlagsText[m]} */`, !1))),
          r
        )
      return (
        a.length && (y = Dt(e.helper(Op), [y, ra(a)])),
        { slots: y, hasDynamicSlots: o }
      )
    }
    function ac(t, e, s) {
      let i = [mt('name', t), mt('fn', e)]
      return s != null && i.push(mt('key', Pe(String(s), !0))), ys(i)
    }
    function oc(t) {
      for (let e = 0; e < t.length; e++) {
        let s = t[e]
        switch (s.type) {
          case 1:
            if (s.tagType === 2 || oc(s.children)) return !0
            break
          case 9:
            if (oc(s.branches)) return !0
            break
          case 10:
          case 11:
            if (oc(s.children)) return !0
            break
        }
      }
      return !1
    }
    function NE(t) {
      return t.type !== 2 && t.type !== 12
        ? !0
        : t.type === 2
        ? !!t.content.trim()
        : NE(t.content)
    }
    var IE = new WeakMap(),
      OE = (t, e) =>
        function () {
          if (
            ((t = e.currentNode),
            !(t.type === 1 && (t.tagType === 0 || t.tagType === 1)))
          )
            return
          let { tag: i, props: r } = t,
            n = t.tagType === 1,
            a = n ? wE(t, e) : `"${i}"`,
            o = re.isObject(a) && a.callee === Rl,
            u,
            l,
            c = 0,
            f,
            h,
            p,
            m =
              o ||
              a === Zn ||
              a === Il ||
              (!n && (i === 'svg' || i === 'foreignObject' || i === 'math'))
          if (r.length > 0) {
            let y = Qp(t, e, void 0, n, o)
            ;(u = y.props), (c = y.patchFlag), (h = y.dynamicPropNames)
            let x = y.directives
            ;(p = x && x.length ? ra(x.map((C) => RE(C, e))) : void 0),
              y.shouldUseBlock && (m = !0)
          }
          if (t.children.length > 0)
            if (
              (a === fo &&
                ((m = !0),
                (c |= 1024),
                t.children.length > 1 &&
                  e.onError(
                    Xe(46, {
                      start: t.children[0].loc.start,
                      end: t.children[t.children.length - 1].loc.end,
                      source: '',
                    })
                  )),
              n && a !== Zn && a !== fo)
            ) {
              let { slots: x, hasDynamicSlots: C } = vE(t, e)
              ;(l = x), C && (c |= 1024)
            } else if (t.children.length === 1 && a !== Zn) {
              let x = t.children[0],
                C = x.type,
                E = C === 5 || C === 8
              E && ws(x, e) === 0 && (c |= 1),
                E || C === 2 ? (l = x) : (l = t.children)
            } else l = t.children
          h && h.length && (f = dO(h)),
            (t.codegenNode = ia(
              e,
              a,
              u,
              l,
              c === 0 ? void 0 : c,
              f,
              p,
              !!m,
              !1,
              n,
              t.loc
            ))
        }
    function wE(t, e, s = !1) {
      let { tag: i } = t,
        r = Zp(i),
        n = Eo(t, 'is', !1, !0)
      if (n)
        if (r || or('COMPILER_IS_ON_ELEMENT', e)) {
          let o
          if (
            (n.type === 6
              ? (o = n.value && Pe(n.value.content, !0))
              : ((o = n.exp),
                o || ((o = Pe('is', !1, n.loc)), (o = n.exp = qt(o, e)))),
            o)
          )
            return Dt(e.helper(Rl), [o])
        } else
          n.type === 6 &&
            n.value.content.startsWith('vue:') &&
            (i = n.value.content.slice(4))
      let a = Vp(i) || e.isBuiltInComponent(i)
      if (a) return s || e.helper(a), a
      {
        let o = Yp(i, e)
        if (o) return o
        let u = i.indexOf('.')
        if (u > 0) {
          let l = Yp(i.slice(0, u), e)
          if (l) return l + i.slice(u)
        }
      }
      return e.selfName && re.capitalize(re.camelize(i)) === e.selfName
        ? (e.helper(ho), e.components.add(i + '__self'), nn(i, 'component'))
        : (e.helper(ho), e.components.add(i), nn(i, 'component'))
    }
    function Yp(t, e) {
      let s = e.bindingMetadata
      if (!s || s.__isScriptSetup === !1) return
      let i = re.camelize(t),
        r = re.capitalize(i),
        n = (l) => {
          if (s[t] === l) return t
          if (s[i] === l) return i
          if (s[r] === l) return r
        },
        a = n('setup-const') || n('setup-reactive-const') || n('literal-const')
      if (a) return e.inline ? a : `$setup[${JSON.stringify(a)}]`
      let o = n('setup-let') || n('setup-ref') || n('setup-maybe-ref')
      if (o)
        return e.inline
          ? `${e.helperString(go)}(${o})`
          : `$setup[${JSON.stringify(o)}]`
      let u = n('props')
      if (u)
        return `${e.helperString(go)}(${
          e.inline ? '__props' : '$props'
        }[${JSON.stringify(u)}])`
    }
    function Qp(t, e, s = t.props, i, r, n = !1) {
      let { tag: a, loc: o, children: u } = t,
        l = [],
        c = [],
        f = [],
        h = u.length > 0,
        p = !1,
        m = 0,
        y = !1,
        x = !1,
        C = !1,
        E = !1,
        g = !1,
        S = !1,
        _ = [],
        I = (O) => {
          l.length && (c.push(ys(ME(l), o)), (l = [])), O && c.push(O)
        },
        k = () => {
          e.scopes.vFor > 0 && l.push(mt(Pe('ref_for', !0), Pe('true')))
        },
        L = ({ key: O, value: v }) => {
          if (qs(O)) {
            let A = O.content,
              V = re.isOn(A)
            if (
              (V &&
                (!i || r) &&
                A.toLowerCase() !== 'onclick' &&
                A !== 'onUpdate:modelValue' &&
                !re.isReservedProp(A) &&
                (E = !0),
              V && re.isReservedProp(A) && (S = !0),
              V && v.type === 14 && (v = v.arguments[0]),
              v.type === 20 || ((v.type === 4 || v.type === 8) && ws(v, e) > 0))
            )
              return
            A === 'ref'
              ? (y = !0)
              : A === 'class'
              ? (x = !0)
              : A === 'style'
              ? (C = !0)
              : A !== 'key' && !_.includes(A) && _.push(A),
              i &&
                (A === 'class' || A === 'style') &&
                !_.includes(A) &&
                _.push(A)
          } else g = !0
        }
      for (let O = 0; O < s.length; O++) {
        let v = s[O]
        if (v.type === 6) {
          let { loc: A, name: V, nameLoc: se, value: Y } = v,
            q = !0
          if (V === 'ref' && ((y = !0), k(), Y && e.inline)) {
            let ee = e.bindingMetadata[Y.content]
            ;(ee === 'setup-let' ||
              ee === 'setup-ref' ||
              ee === 'setup-maybe-ref') &&
              ((q = !1),
              l.push(mt(Pe('ref_key', !0), Pe(Y.content, !0, Y.loc))))
          }
          if (
            V === 'is' &&
            (Zp(a) ||
              (Y && Y.content.startsWith('vue:')) ||
              or('COMPILER_IS_ON_ELEMENT', e))
          )
            continue
          l.push(mt(Pe(V, !0, se), Pe(Y ? Y.content : '', q, Y ? Y.loc : A)))
        } else {
          let { name: A, arg: V, exp: se, loc: Y, modifiers: q } = v,
            ee = A === 'bind',
            z = A === 'on'
          if (A === 'slot') {
            i || e.onError(Xe(40, Y))
            continue
          }
          if (
            A === 'once' ||
            A === 'memo' ||
            A === 'is' ||
            (ee && ur(V, 'is') && (Zp(a) || or('COMPILER_IS_ON_ELEMENT', e))) ||
            (z && n)
          )
            continue
          if (
            (((ee && ur(V, 'key')) || (z && h && ur(V, 'vue:before-update'))) &&
              (p = !0),
            ee && ur(V, 'ref') && k(),
            !V && (ee || z))
          ) {
            if (((g = !0), se))
              if (ee) {
                if (
                  (k(),
                  I(),
                  c.some((Ze) =>
                    Ze.type === 15
                      ? Ze.properties.some(({ key: rt }) =>
                          rt.type !== 4 || !rt.isStatic
                            ? !0
                            : rt.content !== 'class' &&
                              rt.content !== 'style' &&
                              !re.isOn(rt.content)
                        )
                      : !0
                  ) && na('COMPILER_V_BIND_OBJECT_ORDER', e, Y),
                  or('COMPILER_V_BIND_OBJECT_ORDER', e))
                ) {
                  c.unshift(se)
                  continue
                }
                c.push(se)
              } else
                I({
                  type: 14,
                  loc: Y,
                  callee: e.helper(Hl),
                  arguments: i ? [se] : [se, 'true'],
                })
            else e.onError(Xe(ee ? 34 : 35, Y))
            continue
          }
          ee && q.includes('prop') && (m |= 32)
          let He = e.directiveTransforms[A]
          if (He) {
            let { props: St, needRuntime: Ze } = He(v, t, e)
            !n && St.forEach(L),
              z && V && !qs(V) ? I(ys(St, o)) : l.push(...St),
              Ze && (f.push(v), re.isSymbol(Ze) && IE.set(v, Ze))
          } else re.isBuiltInDirective(A) || (f.push(v), h && (p = !0))
        }
      }
      let N
      if (
        (c.length
          ? (I(), c.length > 1 ? (N = Dt(e.helper(po), c, o)) : (N = c[0]))
          : l.length && (N = ys(ME(l), o)),
        g
          ? (m |= 16)
          : (x && !i && (m |= 2),
            C && !i && (m |= 4),
            _.length && (m |= 8),
            E && (m |= 32)),
        !p && (m === 0 || m === 32) && (y || S || f.length > 0) && (m |= 512),
        !e.inSSR && N)
      )
        switch (N.type) {
          case 15:
            let O = -1,
              v = -1,
              A = !1
            for (let Y = 0; Y < N.properties.length; Y++) {
              let q = N.properties[Y].key
              qs(q)
                ? q.content === 'class'
                  ? (O = Y)
                  : q.content === 'style' && (v = Y)
                : q.isHandlerKey || (A = !0)
            }
            let V = N.properties[O],
              se = N.properties[v]
            A
              ? (N = Dt(e.helper(ta), [N]))
              : (V && !qs(V.value) && (V.value = Dt(e.helper(Vl), [V.value])),
                se &&
                  (C ||
                    (se.value.type === 4 &&
                      se.value.content.trim()[0] === '[') ||
                    se.value.type === 17) &&
                  (se.value = Dt(e.helper(Ul), [se.value])))
            break
          case 14:
            break
          default:
            N = Dt(e.helper(ta), [Dt(e.helper(sa), [N])])
            break
        }
      return {
        props: N,
        directives: f,
        patchFlag: m,
        dynamicPropNames: _,
        shouldUseBlock: p,
      }
    }
    function ME(t) {
      let e = new Map(),
        s = []
      for (let i = 0; i < t.length; i++) {
        let r = t[i]
        if (r.key.type === 8 || !r.key.isStatic) {
          s.push(r)
          continue
        }
        let n = r.key.content,
          a = e.get(n)
        a
          ? (n === 'style' || n === 'class' || re.isOn(n)) && pO(a, r)
          : (e.set(n, r), s.push(r))
      }
      return s
    }
    function pO(t, e) {
      t.value.type === 17
        ? t.value.elements.push(e.value)
        : (t.value = ra([t.value, e.value], t.loc))
    }
    function RE(t, e) {
      let s = [],
        i = IE.get(t)
      if (i) s.push(e.helperString(i))
      else {
        let n = Yp('v-' + t.name, e)
        n
          ? s.push(n)
          : (e.helper(Ll),
            e.directives.add(t.name),
            s.push(nn(t.name, 'directive')))
      }
      let { loc: r } = t
      if (
        (t.exp && s.push(t.exp),
        t.arg && (t.exp || s.push('void 0'), s.push(t.arg)),
        Object.keys(t.modifiers).length)
      ) {
        t.arg || (t.exp || s.push('void 0'), s.push('void 0'))
        let n = Pe('true', !1, r)
        s.push(
          ys(
            t.modifiers.map((a) => mt(a, n)),
            r
          )
        )
      }
      return ra(s, t.loc)
    }
    function dO(t) {
      let e = '['
      for (let s = 0, i = t.length; s < i; s++)
        (e += JSON.stringify(t[s])), s < i - 1 && (e += ', ')
      return e + ']'
    }
    function Zp(t) {
      return t === 'component' || t === 'Component'
    }
    var mO = (t, e) => {
      if (So(t)) {
        let { children: s, loc: i } = t,
          { slotName: r, slotProps: n } = LE(t, e),
          a = [
            e.prefixIdentifiers ? '_ctx.$slots' : '$slots',
            r,
            '{}',
            'undefined',
            'true',
          ],
          o = 2
        n && ((a[2] = n), (o = 3)),
          s.length && ((a[3] = tn([], s, !1, !1, i)), (o = 4)),
          e.scopeId && !e.slotted && (o = 5),
          a.splice(o),
          (t.codegenNode = Dt(e.helper(Ip), a, i))
      }
    }
    function LE(t, e) {
      let s = '"default"',
        i,
        r = []
      for (let n = 0; n < t.props.length; n++) {
        let a = t.props[n]
        if (a.type === 6)
          a.value &&
            (a.name === 'name'
              ? (s = JSON.stringify(a.value.content))
              : ((a.name = re.camelize(a.name)), r.push(a)))
        else if (a.name === 'bind' && ur(a.arg, 'name')) {
          if (a.exp) s = a.exp
          else if (a.arg && a.arg.type === 4) {
            let o = re.camelize(a.arg.content)
            ;(s = a.exp = Pe(o, !1, a.arg.loc)), (s = a.exp = qt(a.exp, e))
          }
        } else
          a.name === 'bind' &&
            a.arg &&
            qs(a.arg) &&
            (a.arg.content = re.camelize(a.arg.content)),
            r.push(a)
      }
      if (r.length > 0) {
        let { props: n, directives: a } = Qp(t, e, r, !1, !1)
        ;(i = n), a.length && e.onError(Xe(36, a[0].loc))
      }
      return { slotName: s, slotProps: i }
    }
    var gO =
        /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/,
      kE = (t, e, s, i) => {
        let { loc: r, modifiers: n, arg: a } = t
        !t.exp && !n.length && s.onError(Xe(35, r))
        let o
        if (a.type === 4)
          if (a.isStatic) {
            let f = a.content
            f.startsWith('vnode') && s.onError(Xe(51, a.loc)),
              f.startsWith('vue:') && (f = `vnode-${f.slice(4)}`)
            let h =
              e.tagType !== 0 || f.startsWith('vnode') || !/[A-Z]/.test(f)
                ? re.toHandlerKey(re.camelize(f))
                : `on:${f}`
            o = Pe(h, !0, a.loc)
          } else o = bs([`${s.helperString(jl)}(`, a, ')'])
        else
          (o = a),
            o.children.unshift(`${s.helperString(jl)}(`),
            o.children.push(')')
        let u = t.exp
        u && !u.content.trim() && (u = void 0)
        let l = s.cacheHandlers && !u && !s.inVOnce
        if (u) {
          let f = Up(u.content, s),
            h = !(f || gO.test(u.content)),
            p = u.content.includes(';')
          s.prefixIdentifiers &&
            (h && s.addIdentifiers('$event'),
            (u = t.exp = qt(u, s, !1, p)),
            h && s.removeIdentifiers('$event'),
            (l =
              s.cacheHandlers &&
              !s.inVOnce &&
              !(u.type === 4 && u.constType > 0) &&
              !(f && e.tagType === 1) &&
              !as(u, s.identifiers)),
            l &&
              f &&
              (u.type === 4
                ? (u.content = `${u.content} && ${u.content}(...args)`)
                : (u.children = [
                    ...u.children,
                    ' && ',
                    ...u.children,
                    '(...args)',
                  ]))),
            (h || (l && f)) &&
              (u = bs([
                `${
                  h
                    ? s.isTS
                      ? '($event: any)'
                      : '$event'
                    : `${
                        s.isTS
                          ? `
//@ts-ignore
`
                          : ''
                      }(...args)`
                } => ${p ? '{' : '('}`,
                u,
                p ? '}' : ')',
              ]))
        }
        let c = { props: [mt(o, u || Pe('() => {}', !1, r))] }
        return (
          i && (c = i(c)),
          l && (c.props[0].value = s.cache(c.props[0].value)),
          c.props.forEach((f) => (f.key.isHandlerKey = !0)),
          c
        )
      },
      yO = (t, e) => {
        if (t.type === 0 || t.type === 1 || t.type === 11 || t.type === 10)
          return () => {
            let s = t.children,
              i,
              r = !1
            for (let n = 0; n < s.length; n++) {
              let a = s[n]
              if (Yl(a)) {
                r = !0
                for (let o = n + 1; o < s.length; o++) {
                  let u = s[o]
                  if (Yl(u))
                    i || (i = s[n] = bs([a], a.loc)),
                      i.children.push(' + ', u),
                      s.splice(o, 1),
                      o--
                  else {
                    i = void 0
                    break
                  }
                }
              }
            }
            if (
              !(
                !r ||
                (s.length === 1 &&
                  (t.type === 0 ||
                    (t.type === 1 &&
                      t.tagType === 0 &&
                      !t.props.find(
                        (n) => n.type === 7 && !e.directiveTransforms[n.name]
                      ) &&
                      t.tag !== 'template')))
              )
            )
              for (let n = 0; n < s.length; n++) {
                let a = s[n]
                if (Yl(a) || a.type === 8) {
                  let o = []
                  ;(a.type !== 2 || a.content !== ' ') && o.push(a),
                    !e.ssr &&
                      ws(a, e) === 0 &&
                      o.push(1 + ` /* ${re.PatchFlagNames[1]} */`),
                    (s[n] = {
                      type: 12,
                      content: a,
                      loc: a.loc,
                      codegenNode: Dt(e.helper(Ml), o),
                    })
                }
              }
          }
      },
      DE = new WeakSet(),
      bO = (t, e) => {
        if (t.type === 1 && Ss(t, 'once', !0))
          return DE.has(t) || e.inVOnce || e.inSSR
            ? void 0
            : (DE.add(t),
              (e.inVOnce = !0),
              e.helper(mo),
              () => {
                e.inVOnce = !1
                let s = e.currentNode
                s.codegenNode && (s.codegenNode = e.cache(s.codegenNode, !0))
              })
      },
      FE = (t, e, s) => {
        let { exp: i, arg: r } = t
        if (!i) return s.onError(Xe(41, t.loc)), Po()
        let n = i.loc.source,
          a = i.type === 4 ? i.content : n,
          o = s.bindingMetadata[n]
        if (o === 'props' || o === 'props-aliased')
          return s.onError(Xe(44, i.loc)), Po()
        let u =
          s.inline &&
          (o === 'setup-let' || o === 'setup-ref' || o === 'setup-maybe-ref')
        if (!a.trim() || (!Up(a, s) && !u))
          return s.onError(Xe(42, i.loc)), Po()
        if (s.prefixIdentifiers && Ci(a) && s.identifiers[a])
          return s.onError(Xe(43, i.loc)), Po()
        let l = r || Pe('modelValue', !0),
          c = r
            ? qs(r)
              ? `onUpdate:${re.camelize(r.content)}`
              : bs(['"onUpdate:" + ', r])
            : 'onUpdate:modelValue',
          f,
          h = s.isTS ? '($event: any)' : '$event'
        if (u)
          if (o === 'setup-ref')
            f = bs([`${h} => ((`, Pe(n, !1, i.loc), ').value = $event)'])
          else {
            let m = o === 'setup-let' ? `${n} = $event` : 'null'
            f = bs([
              `${h} => (${s.helperString(yo)}(${n}) ? (`,
              Pe(n, !1, i.loc),
              `).value = $event : ${m})`,
            ])
          }
        else f = bs([`${h} => ((`, i, ') = $event)'])
        let p = [mt(l, t.exp), mt(c, f)]
        if (
          (s.prefixIdentifiers &&
            !s.inVOnce &&
            s.cacheHandlers &&
            !as(i, s.identifiers) &&
            (p[1].value = s.cache(p[1].value)),
          t.modifiers.length && e.tagType === 1)
        ) {
          let m = t.modifiers
              .map((x) => (Ci(x) ? x : JSON.stringify(x)) + ': true')
              .join(', '),
            y = r
              ? qs(r)
                ? `${r.content}Modifiers`
                : bs([r, ' + "Modifiers"'])
              : 'modelModifiers'
          p.push(mt(y, Pe(`{ ${m} }`, !1, t.loc, 2)))
        }
        return Po(p)
      }
    function Po(t = []) {
      return { props: t }
    }
    var EO = /[\w).+\-_$\]]/,
      SO = (t, e) => {
        !or('COMPILER_FILTERS', e) ||
          (t.type === 5
            ? uc(t.content, e)
            : t.type === 1 &&
              t.props.forEach((s) => {
                s.type === 7 && s.name !== 'for' && s.exp && uc(s.exp, e)
              }))
      }
    function uc(t, e) {
      if (t.type === 4) BE(t, e)
      else
        for (let s = 0; s < t.children.length; s++) {
          let i = t.children[s]
          typeof i == 'object' &&
            (i.type === 4
              ? BE(i, e)
              : i.type === 8
              ? uc(t, e)
              : i.type === 5 && uc(i.content, e))
        }
    }
    function BE(t, e) {
      let s = t.content,
        i = !1,
        r = !1,
        n = !1,
        a = !1,
        o = 0,
        u = 0,
        l = 0,
        c = 0,
        f,
        h,
        p,
        m,
        y = []
      for (p = 0; p < s.length; p++)
        if (((h = f), (f = s.charCodeAt(p)), i))
          f === 39 && h !== 92 && (i = !1)
        else if (r) f === 34 && h !== 92 && (r = !1)
        else if (n) f === 96 && h !== 92 && (n = !1)
        else if (a) f === 47 && h !== 92 && (a = !1)
        else if (
          f === 124 &&
          s.charCodeAt(p + 1) !== 124 &&
          s.charCodeAt(p - 1) !== 124 &&
          !o &&
          !u &&
          !l
        )
          m === void 0 ? ((c = p + 1), (m = s.slice(0, p).trim())) : x()
        else {
          switch (f) {
            case 34:
              r = !0
              break
            case 39:
              i = !0
              break
            case 96:
              n = !0
              break
            case 40:
              l++
              break
            case 41:
              l--
              break
            case 91:
              u++
              break
            case 93:
              u--
              break
            case 123:
              o++
              break
            case 125:
              o--
              break
          }
          if (f === 47) {
            let C = p - 1,
              E
            for (; C >= 0 && ((E = s.charAt(C)), E === ' '); C--);
            ;(!E || !EO.test(E)) && (a = !0)
          }
        }
      m === void 0 ? (m = s.slice(0, p).trim()) : c !== 0 && x()
      function x() {
        y.push(s.slice(c, p).trim()), (c = p + 1)
      }
      if (y.length) {
        for (bo('COMPILER_FILTERS', e, t.loc), p = 0; p < y.length; p++)
          m = TO(m, y[p], e)
        ;(t.content = m), (t.ast = void 0)
      }
    }
    function TO(t, e, s) {
      s.helper(kl)
      let i = e.indexOf('(')
      if (i < 0) return s.filters.add(e), `${nn(e, 'filter')}(${t})`
      {
        let r = e.slice(0, i),
          n = e.slice(i + 1)
        return (
          s.filters.add(r), `${nn(r, 'filter')}(${t}${n !== ')' ? ',' + n : n}`
        )
      }
    }
    var VE = new WeakSet(),
      _O = (t, e) => {
        if (t.type === 1) {
          let s = Ss(t, 'memo')
          return !s || VE.has(t)
            ? void 0
            : (VE.add(t),
              () => {
                let i = t.codegenNode || e.currentNode.codegenNode
                i &&
                  i.type === 13 &&
                  (t.tagType !== 1 && zl(i, e),
                  (t.codegenNode = Dt(e.helper(Gl), [
                    s.exp,
                    tn(void 0, i),
                    '_cache',
                    String(e.cached++),
                  ])))
              })
        }
      }
    function UE(t) {
      return [
        [bO, oO, _O, cO, SO, ...(t ? [CE, dE] : []), mO, OE, PE, yO],
        { on: kE, bind: SE, model: FE },
      ]
    }
    function xO(t, e = {}) {
      let s = e.onError || Rp,
        i = e.mode === 'module',
        r = e.prefixIdentifiers === !0 || i
      !r && e.cacheHandlers && s(Xe(49)), e.scopeId && !i && s(Xe(50))
      let n = re.extend({}, e, { prefixIdentifiers: r }),
        a = re.isString(t) ? tE(t, n) : t,
        [o, u] = UE(r)
      if (e.isTS) {
        let { expressionPlugins: l } = e
        ;(!l || !l.includes('typescript')) &&
          (e.expressionPlugins = [...(l || []), 'typescript'])
      }
      return (
        oE(
          a,
          re.extend({}, n, {
            nodeTransforms: [...o, ...(e.nodeTransforms || [])],
            directiveTransforms: re.extend({}, u, e.directiveTransforms || {}),
          })
        ),
        lE(a, n)
      )
    }
    var AO = {
        DATA: 'data',
        PROPS: 'props',
        PROPS_ALIASED: 'props-aliased',
        SETUP_LET: 'setup-let',
        SETUP_CONST: 'setup-const',
        SETUP_REACTIVE_CONST: 'setup-reactive-const',
        SETUP_MAYBE_REF: 'setup-maybe-ref',
        SETUP_REF: 'setup-ref',
        OPTIONS: 'options',
        LITERAL_CONST: 'literal-const',
      },
      PO = () => ({ props: [] })
    W.generateCodeFrame = re.generateCodeFrame
    W.BASE_TRANSITION = Pp
    W.BindingTypes = AO
    W.CAMELIZE = $l
    W.CAPITALIZE = Pb
    W.CREATE_BLOCK = Cp
    W.CREATE_COMMENT = ea
    W.CREATE_ELEMENT_BLOCK = vp
    W.CREATE_ELEMENT_VNODE = wl
    W.CREATE_SLOTS = Op
    W.CREATE_STATIC = Np
    W.CREATE_TEXT = Ml
    W.CREATE_VNODE = Ol
    W.CompilerDeprecationTypes = p6
    W.ConstantTypes = a6
    W.ElementTypes = n6
    W.ErrorCodes = m6
    W.FRAGMENT = Qn
    W.GUARD_REACTIVE_PROPS = sa
    W.IS_MEMO_SAME = wp
    W.IS_REF = yo
    W.KEEP_ALIVE = fo
    W.MERGE_PROPS = po
    W.NORMALIZE_CLASS = Vl
    W.NORMALIZE_PROPS = ta
    W.NORMALIZE_STYLE = Ul
    W.Namespaces = i6
    W.NodeTypes = r6
    W.OPEN_BLOCK = nr
    W.POP_SCOPE_ID = Kl
    W.PUSH_SCOPE_ID = ql
    W.RENDER_LIST = Fl
    W.RENDER_SLOT = Ip
    W.RESOLVE_COMPONENT = ho
    W.RESOLVE_DIRECTIVE = Ll
    W.RESOLVE_DYNAMIC_COMPONENT = Rl
    W.RESOLVE_FILTER = kl
    W.SET_BLOCK_TRACKING = mo
    W.SUSPENSE = Il
    W.TELEPORT = Zn
    W.TO_DISPLAY_STRING = Bl
    W.TO_HANDLERS = Hl
    W.TO_HANDLER_KEY = jl
    W.TS_NODE_TYPES = Fp
    W.UNREF = go
    W.WITH_CTX = Xl
    W.WITH_DIRECTIVES = Dl
    W.WITH_MEMO = Gl
    W.advancePositionWithClone = Hp
    W.advancePositionWithMutation = $p
    W.assert = jp
    W.baseCompile = xO
    W.baseParse = tE
    W.buildDirectiveArgs = RE
    W.buildProps = Qp
    W.buildSlots = vE
    W.checkCompatEnabled = na
    W.convertToBlock = zl
    W.createArrayExpression = ra
    W.createAssignmentExpression = c6
    W.createBlockStatement = Nb
    W.createCacheExpression = vb
    W.createCallExpression = Dt
    W.createCompilerError = Xe
    W.createCompoundExpression = bs
    W.createConditionalExpression = Wl
    W.createForLoopParams = nc
    W.createFunctionExpression = tn
    W.createIfStatement = l6
    W.createInterpolation = o6
    W.createObjectExpression = ys
    W.createObjectProperty = mt
    W.createReturnStatement = h6
    W.createRoot = Cb
    W.createSequenceExpression = f6
    W.createSimpleExpression = Pe
    W.createStructuralDirectiveTransform = Gp
    W.createTemplateLiteral = u6
    W.createTransformContext = aE
    W.createVNodeCall = ia
    W.errorMessages = Lb
    W.extractIdentifiers = Pi
    W.findDir = Ss
    W.findProp = Eo
    W.forAliasRE = Gb
    W.generate = lE
    W.getBaseTransformPreset = UE
    W.getConstantType = ws
    W.getMemoedVNodeCall = Xb
    W.getVNodeBlockHelper = rn
    W.getVNodeHelper = sn
    W.hasDynamicKeyVBind = _6
    W.hasScopeRef = as
    W.helperNameMap = ns
    W.injectProp = To
    W.isCoreComponent = Vp
    W.isFunctionType = Hb
    W.isInDestructureAssignment = Lp
    W.isInNewExpression = Fb
    W.isMemberExpression = Up
    W.isMemberExpressionBrowser = T6
    W.isMemberExpressionNode = jb
    W.isReferencedIdentifier = Db
    W.isSimpleIdentifier = Ci
    W.isSlotOutlet = So
    W.isStaticArgOf = ur
    W.isStaticExp = qs
    W.isStaticProperty = Dp
    W.isStaticPropertyKey = $b
    W.isTemplateNode = aa
    W.isText = Yl
    W.isVSlot = qp
    W.locStub = Et
    W.noopDirectiveTransform = PO
    W.processExpression = qt
    W.processFor = xE
    W.processIf = gE
    W.processSlotOutlet = LE
    W.registerRuntimeHelpers = s6
    W.resolveComponentType = wE
    W.stringifyExpression = zp
    W.toValidAssetId = nn
    W.trackSlotScopes = PE
    W.trackVForSlotScopes = CE
    W.transform = oE
    W.transformBind = SE
    W.transformElement = OE
    W.transformExpression = dE
    W.transformModel = FE
    W.transformOn = kE
    W.traverseNode = xo
    W.unwrapTSNode = Bp
    W.walkBlockDeclarations = Vb
    W.walkFunctionParams = Bb
    W.walkIdentifiers = kb
    W.warnDeprecation = bo
  })
  var td = Oe((OD, ed) => {
    'use strict'
    process.env.NODE_ENV === 'production'
      ? (ed.exports = Ab())
      : (ed.exports = HE())
  })
  var JE = Oe((nt) => {
    'use strict'
    Object.defineProperty(nt, '__esModule', { value: !0 })
    var Le = td(),
      De = fs(),
      sd = Symbol(''),
      id = Symbol(''),
      rd = Symbol(''),
      nd = Symbol(''),
      lc = Symbol(''),
      ad = Symbol(''),
      od = Symbol(''),
      ud = Symbol(''),
      ld = Symbol(''),
      cd = Symbol('')
    Le.registerRuntimeHelpers({
      [sd]: 'vModelRadio',
      [id]: 'vModelCheckbox',
      [rd]: 'vModelText',
      [nd]: 'vModelSelect',
      [lc]: 'vModelDynamic',
      [ad]: 'withModifiers',
      [od]: 'withKeys',
      [ud]: 'vShow',
      [ld]: 'Transition',
      [cd]: 'TransitionGroup',
    })
    var fd = {
        parseMode: 'html',
        isVoidTag: De.isVoidTag,
        isNativeTag: (t) =>
          De.isHTMLTag(t) || De.isSVGTag(t) || De.isMathMLTag(t),
        isPreTag: (t) => t === 'pre',
        decodeEntities: void 0,
        isBuiltInComponent: (t) => {
          if (t === 'Transition' || t === 'transition') return ld
          if (t === 'TransitionGroup' || t === 'transition-group') return cd
        },
        getNamespace(t, e, s) {
          let i = e ? e.ns : s
          if (e && i === 2)
            if (e.tag === 'annotation-xml') {
              if (t === 'svg') return 1
              e.props.some(
                (r) =>
                  r.type === 6 &&
                  r.name === 'encoding' &&
                  r.value != null &&
                  (r.value.content === 'text/html' ||
                    r.value.content === 'application/xhtml+xml')
              ) && (i = 0)
            } else
              /^m(?:[ions]|text)$/.test(e.tag) &&
                t !== 'mglyph' &&
                t !== 'malignmark' &&
                (i = 0)
          else
            e &&
              i === 1 &&
              (e.tag === 'foreignObject' ||
                e.tag === 'desc' ||
                e.tag === 'title') &&
              (i = 0)
          if (i === 0) {
            if (t === 'svg') return 1
            if (t === 'math') return 2
          }
          return i
        },
      },
      $E = (t) => {
        t.type === 1 &&
          t.props.forEach((e, s) => {
            e.type === 6 &&
              e.name === 'style' &&
              e.value &&
              (t.props[s] = {
                type: 7,
                name: 'bind',
                arg: Le.createSimpleExpression('style', !0, e.loc),
                exp: CO(e.value.content, e.loc),
                modifiers: [],
                loc: e.loc,
              })
          })
      },
      CO = (t, e) => {
        let s = De.parseStringStyle(t)
        return Le.createSimpleExpression(JSON.stringify(s), !1, e, 3)
      }
    function Ii(t, e) {
      return Le.createCompilerError(t, e, jE)
    }
    var vO = {
        X_V_HTML_NO_EXPRESSION: 53,
        53: 'X_V_HTML_NO_EXPRESSION',
        X_V_HTML_WITH_CHILDREN: 54,
        54: 'X_V_HTML_WITH_CHILDREN',
        X_V_TEXT_NO_EXPRESSION: 55,
        55: 'X_V_TEXT_NO_EXPRESSION',
        X_V_TEXT_WITH_CHILDREN: 56,
        56: 'X_V_TEXT_WITH_CHILDREN',
        X_V_MODEL_ON_INVALID_ELEMENT: 57,
        57: 'X_V_MODEL_ON_INVALID_ELEMENT',
        X_V_MODEL_ARG_ON_ELEMENT: 58,
        58: 'X_V_MODEL_ARG_ON_ELEMENT',
        X_V_MODEL_ON_FILE_INPUT_ELEMENT: 59,
        59: 'X_V_MODEL_ON_FILE_INPUT_ELEMENT',
        X_V_MODEL_UNNECESSARY_VALUE: 60,
        60: 'X_V_MODEL_UNNECESSARY_VALUE',
        X_V_SHOW_NO_EXPRESSION: 61,
        61: 'X_V_SHOW_NO_EXPRESSION',
        X_TRANSITION_INVALID_CHILDREN: 62,
        62: 'X_TRANSITION_INVALID_CHILDREN',
        X_IGNORED_SIDE_EFFECT_TAG: 63,
        63: 'X_IGNORED_SIDE_EFFECT_TAG',
        __EXTEND_POINT__: 64,
        64: '__EXTEND_POINT__',
      },
      jE = {
        [53]: 'v-html is missing expression.',
        [54]: 'v-html will override element children.',
        [55]: 'v-text is missing expression.',
        [56]: 'v-text will override element children.',
        [57]: 'v-model can only be used on <input>, <textarea> and <select> elements.',
        [58]: 'v-model argument is not supported on plain elements.',
        [59]: 'v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.',
        [60]: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
        [61]: 'v-show is missing expression.',
        [62]: '<Transition> expects exactly one child element or component.',
        [63]: 'Tags with side effect (<script> and <style>) are ignored in client component templates.',
      },
      NO = (t, e, s) => {
        let { exp: i, loc: r } = t
        return (
          i || s.onError(Ii(53, r)),
          e.children.length && (s.onError(Ii(54, r)), (e.children.length = 0)),
          {
            props: [
              Le.createObjectProperty(
                Le.createSimpleExpression('innerHTML', !0, r),
                i || Le.createSimpleExpression('', !0)
              ),
            ],
          }
        )
      },
      IO = (t, e, s) => {
        let { exp: i, loc: r } = t
        return (
          i || s.onError(Ii(55, r)),
          e.children.length && (s.onError(Ii(56, r)), (e.children.length = 0)),
          {
            props: [
              Le.createObjectProperty(
                Le.createSimpleExpression('textContent', !0),
                i
                  ? Le.getConstantType(i, s) > 0
                    ? i
                    : Le.createCallExpression(
                        s.helperString(Le.TO_DISPLAY_STRING),
                        [i],
                        r
                      )
                  : Le.createSimpleExpression('', !0)
              ),
            ],
          }
        )
      },
      OO = (t, e, s) => {
        let i = Le.transformModel(t, e, s)
        if (!i.props.length || e.tagType === 1) return i
        t.arg && s.onError(Ii(58, t.arg.loc))
        let { tag: r } = e,
          n = s.isCustomElement(r)
        if (r === 'input' || r === 'textarea' || r === 'select' || n) {
          let a = rd,
            o = !1
          if (r === 'input' || n) {
            let u = Le.findProp(e, 'type')
            if (u) {
              if (u.type === 7) a = lc
              else if (u.value)
                switch (u.value.content) {
                  case 'radio':
                    a = sd
                    break
                  case 'checkbox':
                    a = id
                    break
                  case 'file':
                    ;(o = !0), s.onError(Ii(59, t.loc))
                    break
                }
            } else Le.hasDynamicKeyVBind(e) && (a = lc)
          } else r === 'select' && (a = nd)
          o || (i.needRuntime = s.helper(a))
        } else s.onError(Ii(57, t.loc))
        return (
          (i.props = i.props.filter(
            (a) => !(a.key.type === 4 && a.key.content === 'modelValue')
          )),
          i
        )
      },
      wO = De.makeMap('passive,once,capture'),
      MO = De.makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact,middle'),
      RO = De.makeMap('left,right'),
      qE = De.makeMap('onkeyup,onkeydown,onkeypress', !0),
      LO = (t, e, s, i) => {
        let r = [],
          n = [],
          a = []
        for (let o = 0; o < e.length; o++) {
          let u = e[o]
          ;(u === 'native' &&
            Le.checkCompatEnabled('COMPILER_V_ON_NATIVE', s, i)) ||
          wO(u)
            ? a.push(u)
            : RO(u)
            ? Le.isStaticExp(t)
              ? qE(t.content)
                ? r.push(u)
                : n.push(u)
              : (r.push(u), n.push(u))
            : MO(u)
            ? n.push(u)
            : r.push(u)
        }
        return { keyModifiers: r, nonKeyModifiers: n, eventOptionModifiers: a }
      },
      KE = (t, e) =>
        Le.isStaticExp(t) && t.content.toLowerCase() === 'onclick'
          ? Le.createSimpleExpression(e, !0)
          : t.type !== 4
          ? Le.createCompoundExpression([
              '(',
              t,
              `) === "onClick" ? "${e}" : (`,
              t,
              ')',
            ])
          : t,
      kO = (t, e, s) =>
        Le.transformOn(t, e, s, (i) => {
          let { modifiers: r } = t
          if (!r.length) return i
          let { key: n, value: a } = i.props[0],
            {
              keyModifiers: o,
              nonKeyModifiers: u,
              eventOptionModifiers: l,
            } = LO(n, r, s, t.loc)
          if (
            (u.includes('right') && (n = KE(n, 'onContextmenu')),
            u.includes('middle') && (n = KE(n, 'onMouseup')),
            u.length &&
              (a = Le.createCallExpression(s.helper(ad), [
                a,
                JSON.stringify(u),
              ])),
            o.length &&
              (!Le.isStaticExp(n) || qE(n.content)) &&
              (a = Le.createCallExpression(s.helper(od), [
                a,
                JSON.stringify(o),
              ])),
            l.length)
          ) {
            let c = l.map(De.capitalize).join('')
            n = Le.isStaticExp(n)
              ? Le.createSimpleExpression(`${n.content}${c}`, !0)
              : Le.createCompoundExpression(['(', n, `) + "${c}"`])
          }
          return { props: [Le.createObjectProperty(n, a)] }
        }),
      DO = (t, e, s) => {
        let { exp: i, loc: r } = t
        return (
          i || s.onError(Ii(61, r)), { props: [], needRuntime: s.helper(ud) }
        )
      },
      FO = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g,
      BO = (t, e, s) => {
        if (e.scopes.vSlot > 0) return
        let i = 0,
          r = 0,
          n = [],
          a = (u) => {
            if (i >= 20 || r >= 5) {
              let l = Le.createCallExpression(e.helper(Le.CREATE_STATIC), [
                JSON.stringify(n.map((c) => hd(c, e)).join('')).replace(
                  FO,
                  '" + $1 + "'
                ),
                String(n.length),
              ])
              if ((GE(n[0], l, e), n.length > 1)) {
                for (let f = 1; f < n.length; f++) GE(n[f], null, e)
                let c = n.length - 1
                return t.splice(u - n.length + 1, c), c
              }
            }
            return 0
          },
          o = 0
        for (; o < t.length; o++) {
          let u = t[o]
          if (VO(u)) {
            let c = u,
              f = $O(c)
            if (f) {
              ;(i += f[0]), (r += f[1]), n.push(c)
              continue
            }
          }
          ;(o -= a(o)), (i = 0), (r = 0), (n.length = 0)
        }
        a(o)
      },
      VO = (t) =>
        ((t.type === 1 && t.tagType === 0) || t.type == 12) &&
        t.codegenNode &&
        t.codegenNode.type === 4 &&
        t.codegenNode.hoisted,
      UO = /^(data|aria)-/,
      XE = (t, e) =>
        (e === 0
          ? De.isKnownHtmlAttr(t)
          : e === 1
          ? De.isKnownSvgAttr(t)
          : !1) || UO.test(t),
      GE = (t, e, s) => {
        let i = t.codegenNode.hoisted
        s.hoists[s.hoists.indexOf(i)] = e
      },
      HO = De.makeMap('caption,thead,tr,th,tbody,td,tfoot,colgroup,col')
    function $O(t) {
      if (t.type === 1 && HO(t.tag)) return !1
      if (t.type === 12) return [1, 0]
      let e = 1,
        s = t.props.length > 0 ? 1 : 0,
        i = !1,
        r = () => ((i = !0), !1)
      function n(a) {
        let o = a.tag === 'option' && a.ns === 0
        for (let u = 0; u < a.props.length; u++) {
          let l = a.props[u]
          if (
            (l.type === 6 && !XE(l.name, a.ns)) ||
            (l.type === 7 &&
              l.name === 'bind' &&
              ((l.arg &&
                (l.arg.type === 8 ||
                  (l.arg.isStatic && !XE(l.arg.content, a.ns)))) ||
                (l.exp && (l.exp.type === 8 || l.exp.constType < 3)) ||
                (o &&
                  Le.isStaticArgOf(l.arg, 'value') &&
                  l.exp &&
                  l.exp.ast &&
                  l.exp.ast.type !== 'StringLiteral')))
          )
            return r()
        }
        for (let u = 0; u < a.children.length; u++) {
          e++
          let l = a.children[u]
          if (l.type === 1 && (l.props.length > 0 && s++, n(l), i)) return !1
        }
        return !0
      }
      return n(t) ? [e, s] : !1
    }
    function hd(t, e) {
      if (De.isString(t)) return t
      if (De.isSymbol(t)) return ''
      switch (t.type) {
        case 1:
          return jO(t, e)
        case 2:
          return De.escapeHtml(t.content)
        case 3:
          return `<!--${De.escapeHtml(t.content)}-->`
        case 5:
          return De.escapeHtml(De.toDisplayString(un(t.content)))
        case 8:
          return De.escapeHtml(un(t))
        case 12:
          return hd(t.content, e)
        default:
          return ''
      }
    }
    function jO(t, e) {
      let s = `<${t.tag}`,
        i = ''
      for (let r = 0; r < t.props.length; r++) {
        let n = t.props[r]
        if (n.type === 6)
          (s += ` ${n.name}`),
            n.value && (s += `="${De.escapeHtml(n.value.content)}"`)
        else if (n.type === 7)
          if (n.name === 'bind') {
            let a = n.exp
            if (a.content[0] === '_') {
              s += ` ${n.arg.content}="__VUE_EXP_START__${a.content}__VUE_EXP_END__"`
              continue
            }
            if (De.isBooleanAttr(n.arg.content) && a.content === 'false')
              continue
            let o = un(a)
            if (o != null) {
              let u = n.arg && n.arg.content
              u === 'class'
                ? (o = De.normalizeClass(o))
                : u === 'style' &&
                  (o = De.stringifyStyle(De.normalizeStyle(o))),
                (s += ` ${n.arg.content}="${De.escapeHtml(o)}"`)
            }
          } else
            n.name === 'html'
              ? (i = un(n.exp))
              : n.name === 'text' &&
                (i = De.escapeHtml(De.toDisplayString(un(n.exp))))
      }
      if ((e.scopeId && (s += ` ${e.scopeId}`), (s += '>'), i)) s += i
      else for (let r = 0; r < t.children.length; r++) s += hd(t.children[r], e)
      return De.isVoidTag(t.tag) || (s += `</${t.tag}>`), s
    }
    function un(t) {
      if (t.type === 4) return new Function(`return (${t.content})`)()
      {
        let e = ''
        return (
          t.children.forEach((s) => {
            De.isString(s) ||
              De.isSymbol(s) ||
              (s.type === 2
                ? (e += s.content)
                : s.type === 5
                ? (e += De.toDisplayString(un(s.content)))
                : (e += un(s)))
          }),
          e
        )
      }
    }
    var qO = (t, e) => {
        t.type === 1 &&
          t.tagType === 0 &&
          (t.tag === 'script' || t.tag === 'style') &&
          e.removeNode()
      },
      WE = [$E],
      zE = {
        cloak: Le.noopDirectiveTransform,
        html: NO,
        text: IO,
        model: OO,
        on: kO,
        show: DO,
      }
    function KO(t, e = {}) {
      return Le.baseCompile(
        t,
        De.extend({}, fd, e, {
          nodeTransforms: [qO, ...WE, ...(e.nodeTransforms || [])],
          directiveTransforms: De.extend({}, zE, e.directiveTransforms || {}),
          transformHoist: BO,
        })
      )
    }
    function XO(t, e = {}) {
      return Le.baseParse(t, De.extend({}, fd, e))
    }
    nt.DOMDirectiveTransforms = zE
    nt.DOMErrorCodes = vO
    nt.DOMErrorMessages = jE
    nt.DOMNodeTransforms = WE
    nt.TRANSITION = ld
    nt.TRANSITION_GROUP = cd
    nt.V_MODEL_CHECKBOX = id
    nt.V_MODEL_DYNAMIC = lc
    nt.V_MODEL_RADIO = sd
    nt.V_MODEL_SELECT = nd
    nt.V_MODEL_TEXT = rd
    nt.V_ON_WITH_KEYS = od
    nt.V_ON_WITH_MODIFIERS = ad
    nt.V_SHOW = ud
    nt.compile = KO
    nt.createDOMCompilerError = Ii
    nt.parse = XO
    nt.parserOptions = fd
    nt.transformStyle = $E
    Object.keys(Le).forEach(function (t) {
      t !== 'default' &&
        !Object.prototype.hasOwnProperty.call(nt, t) &&
        (nt[t] = Le[t])
    })
  })
  var aS = Oe((at) => {
    'use strict'
    Object.defineProperty(at, '__esModule', { value: !0 })
    var Ie = td(),
      Fe = fs(),
      pd = Symbol('vModelRadio'),
      dd = Symbol('vModelCheckbox'),
      md = Symbol('vModelText'),
      gd = Symbol('vModelSelect'),
      cc = Symbol('vModelDynamic'),
      yd = Symbol('vOnModifiersGuard'),
      bd = Symbol('vOnKeysGuard'),
      Ed = Symbol('vShow'),
      fc = Symbol('Transition'),
      Sd = Symbol('TransitionGroup')
    Ie.registerRuntimeHelpers({
      [pd]: 'vModelRadio',
      [dd]: 'vModelCheckbox',
      [md]: 'vModelText',
      [gd]: 'vModelSelect',
      [cc]: 'vModelDynamic',
      [yd]: 'withModifiers',
      [bd]: 'withKeys',
      [Ed]: 'vShow',
      [fc]: 'Transition',
      [Sd]: 'TransitionGroup',
    })
    var Td = {
        parseMode: 'html',
        isVoidTag: Fe.isVoidTag,
        isNativeTag: (t) =>
          Fe.isHTMLTag(t) || Fe.isSVGTag(t) || Fe.isMathMLTag(t),
        isPreTag: (t) => t === 'pre',
        decodeEntities: void 0,
        isBuiltInComponent: (t) => {
          if (t === 'Transition' || t === 'transition') return fc
          if (t === 'TransitionGroup' || t === 'transition-group') return Sd
        },
        getNamespace(t, e, s) {
          let i = e ? e.ns : s
          if (e && i === 2)
            if (e.tag === 'annotation-xml') {
              if (t === 'svg') return 1
              e.props.some(
                (r) =>
                  r.type === 6 &&
                  r.name === 'encoding' &&
                  r.value != null &&
                  (r.value.content === 'text/html' ||
                    r.value.content === 'application/xhtml+xml')
              ) && (i = 0)
            } else
              /^m(?:[ions]|text)$/.test(e.tag) &&
                t !== 'mglyph' &&
                t !== 'malignmark' &&
                (i = 0)
          else
            e &&
              i === 1 &&
              (e.tag === 'foreignObject' ||
                e.tag === 'desc' ||
                e.tag === 'title') &&
              (i = 0)
          if (i === 0) {
            if (t === 'svg') return 1
            if (t === 'math') return 2
          }
          return i
        },
      },
      YE = (t) => {
        t.type === 1 &&
          t.props.forEach((e, s) => {
            e.type === 6 &&
              e.name === 'style' &&
              e.value &&
              (t.props[s] = {
                type: 7,
                name: 'bind',
                arg: Ie.createSimpleExpression('style', !0, e.loc),
                exp: GO(e.value.content, e.loc),
                modifiers: [],
                loc: e.loc,
              })
          })
      },
      GO = (t, e) => {
        let s = Fe.parseStringStyle(t)
        return Ie.createSimpleExpression(JSON.stringify(s), !1, e, 3)
      }
    function Ms(t, e) {
      return Ie.createCompilerError(t, e, QE)
    }
    var WO = {
        X_V_HTML_NO_EXPRESSION: 53,
        53: 'X_V_HTML_NO_EXPRESSION',
        X_V_HTML_WITH_CHILDREN: 54,
        54: 'X_V_HTML_WITH_CHILDREN',
        X_V_TEXT_NO_EXPRESSION: 55,
        55: 'X_V_TEXT_NO_EXPRESSION',
        X_V_TEXT_WITH_CHILDREN: 56,
        56: 'X_V_TEXT_WITH_CHILDREN',
        X_V_MODEL_ON_INVALID_ELEMENT: 57,
        57: 'X_V_MODEL_ON_INVALID_ELEMENT',
        X_V_MODEL_ARG_ON_ELEMENT: 58,
        58: 'X_V_MODEL_ARG_ON_ELEMENT',
        X_V_MODEL_ON_FILE_INPUT_ELEMENT: 59,
        59: 'X_V_MODEL_ON_FILE_INPUT_ELEMENT',
        X_V_MODEL_UNNECESSARY_VALUE: 60,
        60: 'X_V_MODEL_UNNECESSARY_VALUE',
        X_V_SHOW_NO_EXPRESSION: 61,
        61: 'X_V_SHOW_NO_EXPRESSION',
        X_TRANSITION_INVALID_CHILDREN: 62,
        62: 'X_TRANSITION_INVALID_CHILDREN',
        X_IGNORED_SIDE_EFFECT_TAG: 63,
        63: 'X_IGNORED_SIDE_EFFECT_TAG',
        __EXTEND_POINT__: 64,
        64: '__EXTEND_POINT__',
      },
      QE = {
        [53]: 'v-html is missing expression.',
        [54]: 'v-html will override element children.',
        [55]: 'v-text is missing expression.',
        [56]: 'v-text will override element children.',
        [57]: 'v-model can only be used on <input>, <textarea> and <select> elements.',
        [58]: 'v-model argument is not supported on plain elements.',
        [59]: 'v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.',
        [60]: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
        [61]: 'v-show is missing expression.',
        [62]: '<Transition> expects exactly one child element or component.',
        [63]: 'Tags with side effect (<script> and <style>) are ignored in client component templates.',
      },
      zO = (t, e, s) => {
        let { exp: i, loc: r } = t
        return (
          i || s.onError(Ms(53, r)),
          e.children.length && (s.onError(Ms(54, r)), (e.children.length = 0)),
          {
            props: [
              Ie.createObjectProperty(
                Ie.createSimpleExpression('innerHTML', !0, r),
                i || Ie.createSimpleExpression('', !0)
              ),
            ],
          }
        )
      },
      JO = (t, e, s) => {
        let { exp: i, loc: r } = t
        return (
          i || s.onError(Ms(55, r)),
          e.children.length && (s.onError(Ms(56, r)), (e.children.length = 0)),
          {
            props: [
              Ie.createObjectProperty(
                Ie.createSimpleExpression('textContent', !0),
                i
                  ? Ie.getConstantType(i, s) > 0
                    ? i
                    : Ie.createCallExpression(
                        s.helperString(Ie.TO_DISPLAY_STRING),
                        [i],
                        r
                      )
                  : Ie.createSimpleExpression('', !0)
              ),
            ],
          }
        )
      },
      YO = (t, e, s) => {
        let i = Ie.transformModel(t, e, s)
        if (!i.props.length || e.tagType === 1) return i
        t.arg && s.onError(Ms(58, t.arg.loc))
        function r() {
          let o = Ie.findDir(e, 'bind')
          o && Ie.isStaticArgOf(o.arg, 'value') && s.onError(Ms(60, o.loc))
        }
        let { tag: n } = e,
          a = s.isCustomElement(n)
        if (n === 'input' || n === 'textarea' || n === 'select' || a) {
          let o = md,
            u = !1
          if (n === 'input' || a) {
            let l = Ie.findProp(e, 'type')
            if (l) {
              if (l.type === 7) o = cc
              else if (l.value)
                switch (l.value.content) {
                  case 'radio':
                    o = pd
                    break
                  case 'checkbox':
                    o = dd
                    break
                  case 'file':
                    ;(u = !0), s.onError(Ms(59, t.loc))
                    break
                  default:
                    r()
                    break
                }
            } else Ie.hasDynamicKeyVBind(e) ? (o = cc) : r()
          } else n === 'select' ? (o = gd) : r()
          u || (i.needRuntime = s.helper(o))
        } else s.onError(Ms(57, t.loc))
        return (
          (i.props = i.props.filter(
            (o) => !(o.key.type === 4 && o.key.content === 'modelValue')
          )),
          i
        )
      },
      QO = Fe.makeMap('passive,once,capture'),
      ZO = Fe.makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact,middle'),
      ew = Fe.makeMap('left,right'),
      ZE = Fe.makeMap('onkeyup,onkeydown,onkeypress', !0),
      tw = (t, e, s, i) => {
        let r = [],
          n = [],
          a = []
        for (let o = 0; o < e.length; o++) {
          let u = e[o]
          ;(u === 'native' &&
            Ie.checkCompatEnabled('COMPILER_V_ON_NATIVE', s, i)) ||
          QO(u)
            ? a.push(u)
            : ew(u)
            ? Ie.isStaticExp(t)
              ? ZE(t.content)
                ? r.push(u)
                : n.push(u)
              : (r.push(u), n.push(u))
            : ZO(u)
            ? n.push(u)
            : r.push(u)
        }
        return { keyModifiers: r, nonKeyModifiers: n, eventOptionModifiers: a }
      },
      eS = (t, e) =>
        Ie.isStaticExp(t) && t.content.toLowerCase() === 'onclick'
          ? Ie.createSimpleExpression(e, !0)
          : t.type !== 4
          ? Ie.createCompoundExpression([
              '(',
              t,
              `) === "onClick" ? "${e}" : (`,
              t,
              ')',
            ])
          : t,
      sw = (t, e, s) =>
        Ie.transformOn(t, e, s, (i) => {
          let { modifiers: r } = t
          if (!r.length) return i
          let { key: n, value: a } = i.props[0],
            {
              keyModifiers: o,
              nonKeyModifiers: u,
              eventOptionModifiers: l,
            } = tw(n, r, s, t.loc)
          if (
            (u.includes('right') && (n = eS(n, 'onContextmenu')),
            u.includes('middle') && (n = eS(n, 'onMouseup')),
            u.length &&
              (a = Ie.createCallExpression(s.helper(yd), [
                a,
                JSON.stringify(u),
              ])),
            o.length &&
              (!Ie.isStaticExp(n) || ZE(n.content)) &&
              (a = Ie.createCallExpression(s.helper(bd), [
                a,
                JSON.stringify(o),
              ])),
            l.length)
          ) {
            let c = l.map(Fe.capitalize).join('')
            n = Ie.isStaticExp(n)
              ? Ie.createSimpleExpression(`${n.content}${c}`, !0)
              : Ie.createCompoundExpression(['(', n, `) + "${c}"`])
          }
          return { props: [Ie.createObjectProperty(n, a)] }
        }),
      iw = (t, e, s) => {
        let { exp: i, loc: r } = t
        return (
          i || s.onError(Ms(61, r)), { props: [], needRuntime: s.helper(Ed) }
        )
      },
      rw = (t, e) => {
        if (
          t.type === 1 &&
          t.tagType === 1 &&
          e.isBuiltInComponent(t.tag) === fc
        )
          return () => {
            if (!t.children.length) return
            tS(t) &&
              e.onError(
                Ms(62, {
                  start: t.children[0].loc.start,
                  end: t.children[t.children.length - 1].loc.end,
                  source: '',
                })
              )
            let i = t.children[0]
            if (i.type === 1)
              for (let r of i.props)
                r.type === 7 &&
                  r.name === 'show' &&
                  t.props.push({
                    type: 6,
                    name: 'persisted',
                    nameLoc: t.loc,
                    value: void 0,
                    loc: t.loc,
                  })
          }
      }
    function tS(t) {
      let e = (t.children = t.children.filter(
          (i) => i.type !== 3 && !(i.type === 2 && !i.content.trim())
        )),
        s = e[0]
      return (
        e.length !== 1 || s.type === 11 || (s.type === 9 && s.branches.some(tS))
      )
    }
    var nw = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g,
      aw = (t, e, s) => {
        if (e.scopes.vSlot > 0) return
        let i = 0,
          r = 0,
          n = [],
          a = (u) => {
            if (i >= 20 || r >= 5) {
              let l = Ie.createCallExpression(e.helper(Ie.CREATE_STATIC), [
                JSON.stringify(n.map((c) => _d(c, e)).join('')).replace(
                  nw,
                  '" + $1 + "'
                ),
                String(n.length),
              ])
              if ((iS(n[0], l, e), n.length > 1)) {
                for (let f = 1; f < n.length; f++) iS(n[f], null, e)
                let c = n.length - 1
                return t.splice(u - n.length + 1, c), c
              }
            }
            return 0
          },
          o = 0
        for (; o < t.length; o++) {
          let u = t[o]
          if (ow(u)) {
            let c = u,
              f = cw(c)
            if (f) {
              ;(i += f[0]), (r += f[1]), n.push(c)
              continue
            }
          }
          ;(o -= a(o)), (i = 0), (r = 0), (n.length = 0)
        }
        a(o)
      },
      ow = (t) =>
        ((t.type === 1 && t.tagType === 0) || t.type == 12) &&
        t.codegenNode &&
        t.codegenNode.type === 4 &&
        t.codegenNode.hoisted,
      uw = /^(data|aria)-/,
      sS = (t, e) =>
        (e === 0
          ? Fe.isKnownHtmlAttr(t)
          : e === 1
          ? Fe.isKnownSvgAttr(t)
          : !1) || uw.test(t),
      iS = (t, e, s) => {
        let i = t.codegenNode.hoisted
        s.hoists[s.hoists.indexOf(i)] = e
      },
      lw = Fe.makeMap('caption,thead,tr,th,tbody,td,tfoot,colgroup,col')
    function cw(t) {
      if (t.type === 1 && lw(t.tag)) return !1
      if (t.type === 12) return [1, 0]
      let e = 1,
        s = t.props.length > 0 ? 1 : 0,
        i = !1,
        r = () => ((i = !0), !1)
      function n(a) {
        let o = a.tag === 'option' && a.ns === 0
        for (let u = 0; u < a.props.length; u++) {
          let l = a.props[u]
          if (
            (l.type === 6 && !sS(l.name, a.ns)) ||
            (l.type === 7 &&
              l.name === 'bind' &&
              ((l.arg &&
                (l.arg.type === 8 ||
                  (l.arg.isStatic && !sS(l.arg.content, a.ns)))) ||
                (l.exp && (l.exp.type === 8 || l.exp.constType < 3)) ||
                (o &&
                  Ie.isStaticArgOf(l.arg, 'value') &&
                  l.exp &&
                  l.exp.ast &&
                  l.exp.ast.type !== 'StringLiteral')))
          )
            return r()
        }
        for (let u = 0; u < a.children.length; u++) {
          e++
          let l = a.children[u]
          if (l.type === 1 && (l.props.length > 0 && s++, n(l), i)) return !1
        }
        return !0
      }
      return n(t) ? [e, s] : !1
    }
    function _d(t, e) {
      if (Fe.isString(t)) return t
      if (Fe.isSymbol(t)) return ''
      switch (t.type) {
        case 1:
          return fw(t, e)
        case 2:
          return Fe.escapeHtml(t.content)
        case 3:
          return `<!--${Fe.escapeHtml(t.content)}-->`
        case 5:
          return Fe.escapeHtml(Fe.toDisplayString(ln(t.content)))
        case 8:
          return Fe.escapeHtml(ln(t))
        case 12:
          return _d(t.content, e)
        default:
          return ''
      }
    }
    function fw(t, e) {
      let s = `<${t.tag}`,
        i = ''
      for (let r = 0; r < t.props.length; r++) {
        let n = t.props[r]
        if (n.type === 6)
          (s += ` ${n.name}`),
            n.value && (s += `="${Fe.escapeHtml(n.value.content)}"`)
        else if (n.type === 7)
          if (n.name === 'bind') {
            let a = n.exp
            if (a.content[0] === '_') {
              s += ` ${n.arg.content}="__VUE_EXP_START__${a.content}__VUE_EXP_END__"`
              continue
            }
            if (Fe.isBooleanAttr(n.arg.content) && a.content === 'false')
              continue
            let o = ln(a)
            if (o != null) {
              let u = n.arg && n.arg.content
              u === 'class'
                ? (o = Fe.normalizeClass(o))
                : u === 'style' &&
                  (o = Fe.stringifyStyle(Fe.normalizeStyle(o))),
                (s += ` ${n.arg.content}="${Fe.escapeHtml(o)}"`)
            }
          } else
            n.name === 'html'
              ? (i = ln(n.exp))
              : n.name === 'text' &&
                (i = Fe.escapeHtml(Fe.toDisplayString(ln(n.exp))))
      }
      if ((e.scopeId && (s += ` ${e.scopeId}`), (s += '>'), i)) s += i
      else for (let r = 0; r < t.children.length; r++) s += _d(t.children[r], e)
      return Fe.isVoidTag(t.tag) || (s += `</${t.tag}>`), s
    }
    function ln(t) {
      if (t.type === 4) return new Function(`return (${t.content})`)()
      {
        let e = ''
        return (
          t.children.forEach((s) => {
            Fe.isString(s) ||
              Fe.isSymbol(s) ||
              (s.type === 2
                ? (e += s.content)
                : s.type === 5
                ? (e += Fe.toDisplayString(ln(s.content)))
                : (e += ln(s)))
          }),
          e
        )
      }
    }
    var hw = (t, e) => {
        t.type === 1 &&
          t.tagType === 0 &&
          (t.tag === 'script' || t.tag === 'style') &&
          (e.onError(Ms(63, t.loc)), e.removeNode())
      },
      rS = [YE, rw],
      nS = {
        cloak: Ie.noopDirectiveTransform,
        html: zO,
        text: JO,
        model: YO,
        on: sw,
        show: iw,
      }
    function pw(t, e = {}) {
      return Ie.baseCompile(
        t,
        Fe.extend({}, Td, e, {
          nodeTransforms: [hw, ...rS, ...(e.nodeTransforms || [])],
          directiveTransforms: Fe.extend({}, nS, e.directiveTransforms || {}),
          transformHoist: aw,
        })
      )
    }
    function dw(t, e = {}) {
      return Ie.baseParse(t, Fe.extend({}, Td, e))
    }
    at.DOMDirectiveTransforms = nS
    at.DOMErrorCodes = WO
    at.DOMErrorMessages = QE
    at.DOMNodeTransforms = rS
    at.TRANSITION = fc
    at.TRANSITION_GROUP = Sd
    at.V_MODEL_CHECKBOX = dd
    at.V_MODEL_DYNAMIC = cc
    at.V_MODEL_RADIO = pd
    at.V_MODEL_SELECT = gd
    at.V_MODEL_TEXT = md
    at.V_ON_WITH_KEYS = bd
    at.V_ON_WITH_MODIFIERS = yd
    at.V_SHOW = Ed
    at.compile = pw
    at.createDOMCompilerError = Ms
    at.parse = dw
    at.parserOptions = Td
    at.transformStyle = YE
    Object.keys(Ie).forEach(function (t) {
      t !== 'default' &&
        !Object.prototype.hasOwnProperty.call(at, t) &&
        (at[t] = Ie[t])
    })
  })
  var Ad = Oe((RD, xd) => {
    'use strict'
    process.env.NODE_ENV === 'production'
      ? (xd.exports = JE())
      : (xd.exports = aS())
  })
  var MS = Oe((_e) => {
    'use strict'
    Object.defineProperty(_e, '__esModule', { value: !0 })
    var Te = fs(),
      Ts,
      Pd = class {
        constructor(e = !1) {
          ;(this.detached = e),
            (this._active = !0),
            (this.effects = []),
            (this.cleanups = []),
            (this.parent = Ts),
            !e &&
              Ts &&
              (this.index = (Ts.scopes || (Ts.scopes = [])).push(this) - 1)
        }
        get active() {
          return this._active
        }
        run(e) {
          if (this._active) {
            let s = Ts
            try {
              return (Ts = this), e()
            } finally {
              Ts = s
            }
          }
        }
        on() {
          Ts = this
        }
        off() {
          Ts = this.parent
        }
        stop(e) {
          if (this._active) {
            let s, i
            for (s = 0, i = this.effects.length; s < i; s++)
              this.effects[s].stop()
            for (s = 0, i = this.cleanups.length; s < i; s++) this.cleanups[s]()
            if (this.scopes)
              for (s = 0, i = this.scopes.length; s < i; s++)
                this.scopes[s].stop(!0)
            if (!this.detached && this.parent && !e) {
              let r = this.parent.scopes.pop()
              r &&
                r !== this &&
                ((this.parent.scopes[this.index] = r), (r.index = this.index))
            }
            ;(this.parent = void 0), (this._active = !1)
          }
        }
      }
    function mw(t) {
      return new Pd(t)
    }
    function oS(t, e = Ts) {
      e && e.active && e.effects.push(t)
    }
    function gw() {
      return Ts
    }
    function yw(t) {
      Ts && Ts.cleanups.push(t)
    }
    var cn,
      Co = class {
        constructor(e, s, i, r) {
          ;(this.fn = e),
            (this.trigger = s),
            (this.scheduler = i),
            (this.active = !0),
            (this.deps = []),
            (this._dirtyLevel = 4),
            (this._trackId = 0),
            (this._runnings = 0),
            (this._shouldSchedule = !1),
            (this._depsLength = 0),
            oS(this, r)
        }
        get dirty() {
          if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            ;(this._dirtyLevel = 1), Nd()
            for (let e = 0; e < this._depsLength; e++) {
              let s = this.deps[e]
              if (s.computed && (bw(s.computed), this._dirtyLevel >= 4)) break
            }
            this._dirtyLevel === 1 && (this._dirtyLevel = 0), Id()
          }
          return this._dirtyLevel >= 4
        }
        set dirty(e) {
          this._dirtyLevel = e ? 4 : 0
        }
        run() {
          if (((this._dirtyLevel = 0), !this.active)) return this.fn()
          let e = Zs,
            s = cn
          try {
            return (Zs = !0), (cn = this), this._runnings++, uS(this), this.fn()
          } finally {
            lS(this), this._runnings--, (cn = s), (Zs = e)
          }
        }
        stop() {
          this.active &&
            (uS(this),
            lS(this),
            this.onStop && this.onStop(),
            (this.active = !1))
        }
      }
    function bw(t) {
      return t.value
    }
    function uS(t) {
      t._trackId++, (t._depsLength = 0)
    }
    function lS(t) {
      if (t.deps.length > t._depsLength) {
        for (let e = t._depsLength; e < t.deps.length; e++) cS(t.deps[e], t)
        t.deps.length = t._depsLength
      }
    }
    function cS(t, e) {
      let s = t.get(e)
      s !== void 0 &&
        e._trackId !== s &&
        (t.delete(e), t.size === 0 && t.cleanup())
    }
    function Ew(t, e) {
      t.effect instanceof Co && (t = t.effect.fn)
      let s = new Co(t, Te.NOOP, () => {
        s.dirty && s.run()
      })
      e && (Te.extend(s, e), e.scope && oS(s, e.scope)),
        (!e || !e.lazy) && s.run()
      let i = s.run.bind(s)
      return (i.effect = s), i
    }
    function Sw(t) {
      t.effect.stop()
    }
    var Zs = !0,
      Cd = 0,
      vd = []
    function Nd() {
      vd.push(Zs), (Zs = !1)
    }
    function Tw() {
      vd.push(Zs), (Zs = !0)
    }
    function Id() {
      let t = vd.pop()
      Zs = t === void 0 ? !0 : t
    }
    function hc() {
      Cd++
    }
    function pc() {
      for (Cd--; !Cd && Od.length; ) Od.shift()()
    }
    function fS(t, e, s) {
      if (e.get(t) !== t._trackId) {
        e.set(t, t._trackId)
        let i = t.deps[t._depsLength]
        i !== e
          ? (i && cS(i, t), (t.deps[t._depsLength++] = e))
          : t._depsLength++
      }
    }
    var Od = []
    function hS(t, e, s) {
      hc()
      for (let i of t.keys()) {
        let r
        i._dirtyLevel < e &&
          (r != null ? r : (r = t.get(i) === i._trackId)) &&
          (i._shouldSchedule || (i._shouldSchedule = i._dirtyLevel === 0),
          (i._dirtyLevel = e)),
          i._shouldSchedule &&
            (r != null ? r : (r = t.get(i) === i._trackId)) &&
            (i.trigger(),
            (!i._runnings || i.allowRecurse) &&
              i._dirtyLevel !== 2 &&
              ((i._shouldSchedule = !1), i.scheduler && Od.push(i.scheduler)))
      }
      pc()
    }
    var pS = (t, e) => {
        let s = new Map()
        return (s.cleanup = t), (s.computed = e), s
      },
      dc = new WeakMap(),
      cr = Symbol(''),
      wd = Symbol('')
    function _s(t, e, s) {
      if (Zs && cn) {
        let i = dc.get(t)
        i || dc.set(t, (i = new Map()))
        let r = i.get(s)
        r || i.set(s, (r = pS(() => i.delete(s)))), fS(cn, r)
      }
    }
    function Oi(t, e, s, i, r, n) {
      let a = dc.get(t)
      if (!a) return
      let o = []
      if (e === 'clear') o = [...a.values()]
      else if (s === 'length' && Te.isArray(t)) {
        let u = Number(i)
        a.forEach((l, c) => {
          ;(c === 'length' || (!Te.isSymbol(c) && c >= u)) && o.push(l)
        })
      } else
        switch ((s !== void 0 && o.push(a.get(s)), e)) {
          case 'add':
            Te.isArray(t)
              ? Te.isIntegerKey(s) && o.push(a.get('length'))
              : (o.push(a.get(cr)), Te.isMap(t) && o.push(a.get(wd)))
            break
          case 'delete':
            Te.isArray(t) ||
              (o.push(a.get(cr)), Te.isMap(t) && o.push(a.get(wd)))
            break
          case 'set':
            Te.isMap(t) && o.push(a.get(cr))
            break
        }
      hc()
      for (let u of o) u && hS(u, 4)
      pc()
    }
    function _w(t, e) {
      let s = dc.get(t)
      return s && s.get(e)
    }
    var xw = Te.makeMap('__proto__,__v_isRef,__isVue'),
      dS = new Set(
        Object.getOwnPropertyNames(Symbol)
          .filter((t) => t !== 'arguments' && t !== 'caller')
          .map((t) => Symbol[t])
          .filter(Te.isSymbol)
      ),
      mS = Aw()
    function Aw() {
      let t = {}
      return (
        ['includes', 'indexOf', 'lastIndexOf'].forEach((e) => {
          t[e] = function (...s) {
            let i = qe(this)
            for (let n = 0, a = this.length; n < a; n++) _s(i, 'get', n + '')
            let r = i[e](...s)
            return r === -1 || r === !1 ? i[e](...s.map(qe)) : r
          }
        }),
        ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((e) => {
          t[e] = function (...s) {
            Nd(), hc()
            let i = qe(this)[e].apply(this, s)
            return pc(), Id(), i
          }
        }),
        t
      )
    }
    function Pw(t) {
      Te.isSymbol(t) || (t = String(t))
      let e = qe(this)
      return _s(e, 'has', t), e.hasOwnProperty(t)
    }
    var Md = class {
        constructor(e = !1, s = !1) {
          ;(this._isReadonly = e), (this._isShallow = s)
        }
        get(e, s, i) {
          let r = this._isReadonly,
            n = this._isShallow
          if (s === '__v_isReactive') return !r
          if (s === '__v_isReadonly') return r
          if (s === '__v_isShallow') return n
          if (s === '__v_raw')
            return i === (r ? (n ? xS : _S) : n ? TS : SS).get(e) ||
              Object.getPrototypeOf(e) === Object.getPrototypeOf(i)
              ? e
              : void 0
          let a = Te.isArray(e)
          if (!r) {
            if (a && Te.hasOwn(mS, s)) return Reflect.get(mS, s, i)
            if (s === 'hasOwnProperty') return Pw
          }
          let o = Reflect.get(e, s, i)
          return (Te.isSymbol(s) ? dS.has(s) : xw(s)) ||
            (r || _s(e, 'get', s), n)
            ? o
            : ei(o)
            ? a && Te.isIntegerKey(s)
              ? o
              : o.value
            : Te.isObject(o)
            ? r
              ? Fd(o)
              : Dd(o)
            : o
        }
      },
      Rd = class extends Md {
        constructor(e = !1) {
          super(!1, e)
        }
        set(e, s, i, r) {
          let n = e[s]
          if (!this._isShallow) {
            let u = hr(n)
            if (
              (!vo(i) && !hr(i) && ((n = qe(n)), (i = qe(i))),
              !Te.isArray(e) && ei(n) && !ei(i))
            )
              return u ? !1 : ((n.value = i), !0)
          }
          let a =
              Te.isArray(e) && Te.isIntegerKey(s)
                ? Number(s) < e.length
                : Te.hasOwn(e, s),
            o = Reflect.set(e, s, i, r)
          return (
            e === qe(r) &&
              (a
                ? Te.hasChanged(i, n) && Oi(e, 'set', s, i)
                : Oi(e, 'add', s, i)),
            o
          )
        }
        deleteProperty(e, s) {
          let i = Te.hasOwn(e, s)
          e[s]
          let r = Reflect.deleteProperty(e, s)
          return r && i && Oi(e, 'delete', s, void 0), r
        }
        has(e, s) {
          let i = Reflect.has(e, s)
          return (!Te.isSymbol(s) || !dS.has(s)) && _s(e, 'has', s), i
        }
        ownKeys(e) {
          return (
            _s(e, 'iterate', Te.isArray(e) ? 'length' : cr), Reflect.ownKeys(e)
          )
        }
      },
      Ld = class extends Md {
        constructor(e = !1) {
          super(!0, e)
        }
        set(e, s) {
          return !0
        }
        deleteProperty(e, s) {
          return !0
        }
      },
      Cw = new Rd(),
      vw = new Ld(),
      Nw = new Rd(!0),
      Iw = new Ld(!0),
      kd = (t) => t,
      mc = (t) => Reflect.getPrototypeOf(t)
    function gc(t, e, s = !1, i = !1) {
      t = t.__v_raw
      let r = qe(t),
        n = qe(e)
      s || (Te.hasChanged(e, n) && _s(r, 'get', e), _s(r, 'get', n))
      let { has: a } = mc(r),
        o = i ? kd : s ? Vd : No
      if (a.call(r, e)) return o(t.get(e))
      if (a.call(r, n)) return o(t.get(n))
      t !== r && t.get(e)
    }
    function yc(t, e = !1) {
      let s = this.__v_raw,
        i = qe(s),
        r = qe(t)
      return (
        e || (Te.hasChanged(t, r) && _s(i, 'has', t), _s(i, 'has', r)),
        t === r ? s.has(t) : s.has(t) || s.has(r)
      )
    }
    function bc(t, e = !1) {
      return (
        (t = t.__v_raw),
        !e && _s(qe(t), 'iterate', cr),
        Reflect.get(t, 'size', t)
      )
    }
    function gS(t, e = !1) {
      !e && !vo(t) && !hr(t) && (t = qe(t))
      let s = qe(this)
      return mc(s).has.call(s, t) || (s.add(t), Oi(s, 'add', t, t)), this
    }
    function yS(t, e, s = !1) {
      !s && !vo(e) && !hr(e) && (e = qe(e))
      let i = qe(this),
        { has: r, get: n } = mc(i),
        a = r.call(i, t)
      a || ((t = qe(t)), (a = r.call(i, t)))
      let o = n.call(i, t)
      return (
        i.set(t, e),
        a ? Te.hasChanged(e, o) && Oi(i, 'set', t, e) : Oi(i, 'add', t, e),
        this
      )
    }
    function bS(t) {
      let e = qe(this),
        { has: s, get: i } = mc(e),
        r = s.call(e, t)
      r || ((t = qe(t)), (r = s.call(e, t))), i && i.call(e, t)
      let n = e.delete(t)
      return r && Oi(e, 'delete', t, void 0), n
    }
    function ES() {
      let t = qe(this),
        e = t.size !== 0,
        s = t.clear()
      return e && Oi(t, 'clear', void 0, void 0), s
    }
    function Ec(t, e) {
      return function (i, r) {
        let n = this,
          a = n.__v_raw,
          o = qe(a),
          u = e ? kd : t ? Vd : No
        return (
          !t && _s(o, 'iterate', cr),
          a.forEach((l, c) => i.call(r, u(l), u(c), n))
        )
      }
    }
    function Sc(t, e, s) {
      return function (...i) {
        let r = this.__v_raw,
          n = qe(r),
          a = Te.isMap(n),
          o = t === 'entries' || (t === Symbol.iterator && a),
          u = t === 'keys' && a,
          l = r[t](...i),
          c = s ? kd : e ? Vd : No
        return (
          !e && _s(n, 'iterate', u ? wd : cr),
          {
            next() {
              let { value: f, done: h } = l.next()
              return h
                ? { value: f, done: h }
                : { value: o ? [c(f[0]), c(f[1])] : c(f), done: h }
            },
            [Symbol.iterator]() {
              return this
            },
          }
        )
      }
    }
    function fr(t) {
      return function (...e) {
        return t === 'delete' ? !1 : t === 'clear' ? void 0 : this
      }
    }
    function Ow() {
      let t = {
          get(n) {
            return gc(this, n)
          },
          get size() {
            return bc(this)
          },
          has: yc,
          add: gS,
          set: yS,
          delete: bS,
          clear: ES,
          forEach: Ec(!1, !1),
        },
        e = {
          get(n) {
            return gc(this, n, !1, !0)
          },
          get size() {
            return bc(this)
          },
          has: yc,
          add(n) {
            return gS.call(this, n, !0)
          },
          set(n, a) {
            return yS.call(this, n, a, !0)
          },
          delete: bS,
          clear: ES,
          forEach: Ec(!1, !0),
        },
        s = {
          get(n) {
            return gc(this, n, !0)
          },
          get size() {
            return bc(this, !0)
          },
          has(n) {
            return yc.call(this, n, !0)
          },
          add: fr('add'),
          set: fr('set'),
          delete: fr('delete'),
          clear: fr('clear'),
          forEach: Ec(!0, !1),
        },
        i = {
          get(n) {
            return gc(this, n, !0, !0)
          },
          get size() {
            return bc(this, !0)
          },
          has(n) {
            return yc.call(this, n, !0)
          },
          add: fr('add'),
          set: fr('set'),
          delete: fr('delete'),
          clear: fr('clear'),
          forEach: Ec(!0, !0),
        }
      return (
        ['keys', 'values', 'entries', Symbol.iterator].forEach((n) => {
          ;(t[n] = Sc(n, !1, !1)),
            (s[n] = Sc(n, !0, !1)),
            (e[n] = Sc(n, !1, !0)),
            (i[n] = Sc(n, !0, !0))
        }),
        [t, s, e, i]
      )
    }
    var [ww, Mw, Rw, Lw] = Ow()
    function Tc(t, e) {
      let s = e ? (t ? Lw : Rw) : t ? Mw : ww
      return (i, r, n) =>
        r === '__v_isReactive'
          ? !t
          : r === '__v_isReadonly'
          ? t
          : r === '__v_raw'
          ? i
          : Reflect.get(Te.hasOwn(s, r) && r in i ? s : i, r, n)
    }
    var kw = { get: Tc(!1, !1) },
      Dw = { get: Tc(!1, !0) },
      Fw = { get: Tc(!0, !1) },
      Bw = { get: Tc(!0, !0) },
      SS = new WeakMap(),
      TS = new WeakMap(),
      _S = new WeakMap(),
      xS = new WeakMap()
    function Vw(t) {
      switch (t) {
        case 'Object':
        case 'Array':
          return 1
        case 'Map':
        case 'Set':
        case 'WeakMap':
        case 'WeakSet':
          return 2
        default:
          return 0
      }
    }
    function Uw(t) {
      return t.__v_skip || !Object.isExtensible(t) ? 0 : Vw(Te.toRawType(t))
    }
    function Dd(t) {
      return hr(t) ? t : _c(t, !1, Cw, kw, SS)
    }
    function Hw(t) {
      return _c(t, !1, Nw, Dw, TS)
    }
    function Fd(t) {
      return _c(t, !0, vw, Fw, _S)
    }
    function $w(t) {
      return _c(t, !0, Iw, Bw, xS)
    }
    function _c(t, e, s, i, r) {
      if (!Te.isObject(t) || (t.__v_raw && !(e && t.__v_isReactive))) return t
      let n = r.get(t)
      if (n) return n
      let a = Uw(t)
      if (a === 0) return t
      let o = new Proxy(t, a === 2 ? i : s)
      return r.set(t, o), o
    }
    function Bd(t) {
      return hr(t) ? Bd(t.__v_raw) : !!(t && t.__v_isReactive)
    }
    function hr(t) {
      return !!(t && t.__v_isReadonly)
    }
    function vo(t) {
      return !!(t && t.__v_isShallow)
    }
    function jw(t) {
      return t ? !!t.__v_raw : !1
    }
    function qe(t) {
      let e = t && t.__v_raw
      return e ? qe(e) : t
    }
    function qw(t) {
      return Object.isExtensible(t) && Te.def(t, '__v_skip', !0), t
    }
    var No = (t) => (Te.isObject(t) ? Dd(t) : t),
      Vd = (t) => (Te.isObject(t) ? Fd(t) : t),
      Ud = class {
        constructor(e, s, i, r) {
          ;(this.getter = e),
            (this._setter = s),
            (this.dep = void 0),
            (this.__v_isRef = !0),
            (this.__v_isReadonly = !1),
            (this.effect = new Co(
              () => e(this._value),
              () => ua(this, this.effect._dirtyLevel === 2 ? 2 : 3)
            )),
            (this.effect.computed = this),
            (this.effect.active = this._cacheable = !r),
            (this.__v_isReadonly = i)
        }
        get value() {
          let e = qe(this)
          return (
            (!e._cacheable || e.effect.dirty) &&
              Te.hasChanged(e._value, (e._value = e.effect.run())) &&
              ua(e, 4),
            Hd(e),
            e.effect._dirtyLevel >= 2 && ua(e, 2),
            e._value
          )
        }
        set value(e) {
          this._setter(e)
        }
        get _dirty() {
          return this.effect.dirty
        }
        set _dirty(e) {
          this.effect.dirty = e
        }
      }
    function AS(t, e, s = !1) {
      let i,
        r,
        n = Te.isFunction(t)
      return (
        n ? ((i = t), (r = Te.NOOP)) : ((i = t.get), (r = t.set)),
        new Ud(i, r, n || !r, s)
      )
    }
    function Hd(t) {
      var e
      Zs &&
        cn &&
        ((t = qe(t)),
        fS(
          cn,
          (e = t.dep) != null
            ? e
            : (t.dep = pS(() => (t.dep = void 0), t instanceof Ud ? t : void 0))
        ))
    }
    function ua(t, e = 4, s, i) {
      t = qe(t)
      let r = t.dep
      r && hS(r, e)
    }
    function ei(t) {
      return !!(t && t.__v_isRef === !0)
    }
    function PS(t) {
      return CS(t, !1)
    }
    function Kw(t) {
      return CS(t, !0)
    }
    function CS(t, e) {
      return ei(t) ? t : new vS(t, e)
    }
    var vS = class {
      constructor(e, s) {
        ;(this.__v_isShallow = s),
          (this.dep = void 0),
          (this.__v_isRef = !0),
          (this._rawValue = s ? e : qe(e)),
          (this._value = s ? e : No(e))
      }
      get value() {
        return Hd(this), this._value
      }
      set value(e) {
        let s = this.__v_isShallow || vo(e) || hr(e)
        ;(e = s ? e : qe(e)),
          Te.hasChanged(e, this._rawValue) &&
            (this._rawValue,
            (this._rawValue = e),
            (this._value = s ? e : No(e)),
            ua(this, 4))
      }
    }
    function Xw(t) {
      ua(t, 4)
    }
    function $d(t) {
      return ei(t) ? t.value : t
    }
    function Gw(t) {
      return Te.isFunction(t) ? t() : $d(t)
    }
    var Ww = {
      get: (t, e, s) => $d(Reflect.get(t, e, s)),
      set: (t, e, s, i) => {
        let r = t[e]
        return ei(r) && !ei(s) ? ((r.value = s), !0) : Reflect.set(t, e, s, i)
      },
    }
    function zw(t) {
      return Bd(t) ? t : new Proxy(t, Ww)
    }
    var NS = class {
      constructor(e) {
        ;(this.dep = void 0), (this.__v_isRef = !0)
        let { get: s, set: i } = e(
          () => Hd(this),
          () => ua(this)
        )
        ;(this._get = s), (this._set = i)
      }
      get value() {
        return this._get()
      }
      set value(e) {
        this._set(e)
      }
    }
    function Jw(t) {
      return new NS(t)
    }
    function Yw(t) {
      let e = Te.isArray(t) ? new Array(t.length) : {}
      for (let s in t) e[s] = wS(t, s)
      return e
    }
    var IS = class {
        constructor(e, s, i) {
          ;(this._object = e),
            (this._key = s),
            (this._defaultValue = i),
            (this.__v_isRef = !0)
        }
        get value() {
          let e = this._object[this._key]
          return e === void 0 ? this._defaultValue : e
        }
        set value(e) {
          this._object[this._key] = e
        }
        get dep() {
          return _w(qe(this._object), this._key)
        }
      },
      OS = class {
        constructor(e) {
          ;(this._getter = e), (this.__v_isRef = !0), (this.__v_isReadonly = !0)
        }
        get value() {
          return this._getter()
        }
      }
    function Qw(t, e, s) {
      return ei(t)
        ? t
        : Te.isFunction(t)
        ? new OS(t)
        : Te.isObject(t) && arguments.length > 1
        ? wS(t, e, s)
        : PS(t)
    }
    function wS(t, e, s) {
      let i = t[e]
      return ei(i) ? i : new IS(t, e, s)
    }
    var Zw = AS,
      e4 = { GET: 'get', HAS: 'has', ITERATE: 'iterate' },
      t4 = { SET: 'set', ADD: 'add', DELETE: 'delete', CLEAR: 'clear' },
      s4 = {
        SKIP: '__v_skip',
        IS_REACTIVE: '__v_isReactive',
        IS_READONLY: '__v_isReadonly',
        IS_SHALLOW: '__v_isShallow',
        RAW: '__v_raw',
      }
    _e.EffectScope = Pd
    _e.ITERATE_KEY = cr
    _e.ReactiveEffect = Co
    _e.ReactiveFlags = s4
    _e.TrackOpTypes = e4
    _e.TriggerOpTypes = t4
    _e.computed = AS
    _e.customRef = Jw
    _e.deferredComputed = Zw
    _e.effect = Ew
    _e.effectScope = mw
    _e.enableTracking = Tw
    _e.getCurrentScope = gw
    _e.isProxy = jw
    _e.isReactive = Bd
    _e.isReadonly = hr
    _e.isRef = ei
    _e.isShallow = vo
    _e.markRaw = qw
    _e.onScopeDispose = yw
    _e.pauseScheduling = hc
    _e.pauseTracking = Nd
    _e.proxyRefs = zw
    _e.reactive = Dd
    _e.readonly = Fd
    _e.ref = PS
    _e.resetScheduling = pc
    _e.resetTracking = Id
    _e.shallowReactive = Hw
    _e.shallowReadonly = $w
    _e.shallowRef = Kw
    _e.stop = Sw
    _e.toRaw = qe
    _e.toRef = Qw
    _e.toRefs = Yw
    _e.toValue = Gw
    _e.track = _s
    _e.trigger = Oi
    _e.triggerRef = Xw
    _e.unref = $d
  })
  var aT = Oe((xe) => {
    'use strict'
    Object.defineProperty(xe, '__esModule', { value: !0 })
    var Se = fs()
    function ti(t, ...e) {
      console.warn(`[Vue warn] ${t}`, ...e)
    }
    var xs,
      jd = class {
        constructor(e = !1) {
          ;(this.detached = e),
            (this._active = !0),
            (this.effects = []),
            (this.cleanups = []),
            (this.parent = xs),
            !e &&
              xs &&
              (this.index = (xs.scopes || (xs.scopes = [])).push(this) - 1)
        }
        get active() {
          return this._active
        }
        run(e) {
          if (this._active) {
            let s = xs
            try {
              return (xs = this), e()
            } finally {
              xs = s
            }
          } else ti('cannot run an inactive effect scope.')
        }
        on() {
          xs = this
        }
        off() {
          xs = this.parent
        }
        stop(e) {
          if (this._active) {
            let s, i
            for (s = 0, i = this.effects.length; s < i; s++)
              this.effects[s].stop()
            for (s = 0, i = this.cleanups.length; s < i; s++) this.cleanups[s]()
            if (this.scopes)
              for (s = 0, i = this.scopes.length; s < i; s++)
                this.scopes[s].stop(!0)
            if (!this.detached && this.parent && !e) {
              let r = this.parent.scopes.pop()
              r &&
                r !== this &&
                ((this.parent.scopes[this.index] = r), (r.index = this.index))
            }
            ;(this.parent = void 0), (this._active = !1)
          }
        }
      }
    function i4(t) {
      return new jd(t)
    }
    function RS(t, e = xs) {
      e && e.active && e.effects.push(t)
    }
    function r4() {
      return xs
    }
    function n4(t) {
      xs
        ? xs.cleanups.push(t)
        : ti(
            'onScopeDispose() is called when there is no active effect scope to be associated with.'
          )
    }
    var fn,
      Io = class {
        constructor(e, s, i, r) {
          ;(this.fn = e),
            (this.trigger = s),
            (this.scheduler = i),
            (this.active = !0),
            (this.deps = []),
            (this._dirtyLevel = 4),
            (this._trackId = 0),
            (this._runnings = 0),
            (this._shouldSchedule = !1),
            (this._depsLength = 0),
            RS(this, r)
        }
        get dirty() {
          if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            ;(this._dirtyLevel = 1), Xd()
            for (let e = 0; e < this._depsLength; e++) {
              let s = this.deps[e]
              if (s.computed && (a4(s.computed), this._dirtyLevel >= 4)) break
            }
            this._dirtyLevel === 1 && (this._dirtyLevel = 0), Gd()
          }
          return this._dirtyLevel >= 4
        }
        set dirty(e) {
          this._dirtyLevel = e ? 4 : 0
        }
        run() {
          if (((this._dirtyLevel = 0), !this.active)) return this.fn()
          let e = si,
            s = fn
          try {
            return (si = !0), (fn = this), this._runnings++, LS(this), this.fn()
          } finally {
            kS(this), this._runnings--, (fn = s), (si = e)
          }
        }
        stop() {
          this.active &&
            (LS(this),
            kS(this),
            this.onStop && this.onStop(),
            (this.active = !1))
        }
      }
    function a4(t) {
      return t.value
    }
    function LS(t) {
      t._trackId++, (t._depsLength = 0)
    }
    function kS(t) {
      if (t.deps.length > t._depsLength) {
        for (let e = t._depsLength; e < t.deps.length; e++) DS(t.deps[e], t)
        t.deps.length = t._depsLength
      }
    }
    function DS(t, e) {
      let s = t.get(e)
      s !== void 0 &&
        e._trackId !== s &&
        (t.delete(e), t.size === 0 && t.cleanup())
    }
    function o4(t, e) {
      t.effect instanceof Io && (t = t.effect.fn)
      let s = new Io(t, Se.NOOP, () => {
        s.dirty && s.run()
      })
      e && (Se.extend(s, e), e.scope && RS(s, e.scope)),
        (!e || !e.lazy) && s.run()
      let i = s.run.bind(s)
      return (i.effect = s), i
    }
    function u4(t) {
      t.effect.stop()
    }
    var si = !0,
      qd = 0,
      Kd = []
    function Xd() {
      Kd.push(si), (si = !1)
    }
    function l4() {
      Kd.push(si), (si = !0)
    }
    function Gd() {
      let t = Kd.pop()
      si = t === void 0 ? !0 : t
    }
    function xc() {
      qd++
    }
    function Ac() {
      for (qd--; !qd && Wd.length; ) Wd.shift()()
    }
    function FS(t, e, s) {
      var i
      if (e.get(t) !== t._trackId) {
        e.set(t, t._trackId)
        let r = t.deps[t._depsLength]
        r !== e
          ? (r && DS(r, t), (t.deps[t._depsLength++] = e))
          : t._depsLength++,
          (i = t.onTrack) == null || i.call(t, Se.extend({ effect: t }, s))
      }
    }
    var Wd = []
    function BS(t, e, s) {
      var i
      xc()
      for (let r of t.keys()) {
        let n
        r._dirtyLevel < e &&
          (n != null ? n : (n = t.get(r) === r._trackId)) &&
          (r._shouldSchedule || (r._shouldSchedule = r._dirtyLevel === 0),
          (r._dirtyLevel = e)),
          r._shouldSchedule &&
            (n != null ? n : (n = t.get(r) === r._trackId)) &&
            ((i = r.onTrigger) == null ||
              i.call(r, Se.extend({ effect: r }, s)),
            r.trigger(),
            (!r._runnings || r.allowRecurse) &&
              r._dirtyLevel !== 2 &&
              ((r._shouldSchedule = !1), r.scheduler && Wd.push(r.scheduler)))
      }
      Ac()
    }
    var VS = (t, e) => {
        let s = new Map()
        return (s.cleanup = t), (s.computed = e), s
      },
      Pc = new WeakMap(),
      pr = Symbol('iterate'),
      zd = Symbol('Map key iterate')
    function As(t, e, s) {
      if (si && fn) {
        let i = Pc.get(t)
        i || Pc.set(t, (i = new Map()))
        let r = i.get(s)
        r || i.set(s, (r = VS(() => i.delete(s)))),
          FS(fn, r, { target: t, type: e, key: s })
      }
    }
    function wi(t, e, s, i, r, n) {
      let a = Pc.get(t)
      if (!a) return
      let o = []
      if (e === 'clear') o = [...a.values()]
      else if (s === 'length' && Se.isArray(t)) {
        let u = Number(i)
        a.forEach((l, c) => {
          ;(c === 'length' || (!Se.isSymbol(c) && c >= u)) && o.push(l)
        })
      } else
        switch ((s !== void 0 && o.push(a.get(s)), e)) {
          case 'add':
            Se.isArray(t)
              ? Se.isIntegerKey(s) && o.push(a.get('length'))
              : (o.push(a.get(pr)), Se.isMap(t) && o.push(a.get(zd)))
            break
          case 'delete':
            Se.isArray(t) ||
              (o.push(a.get(pr)), Se.isMap(t) && o.push(a.get(zd)))
            break
          case 'set':
            Se.isMap(t) && o.push(a.get(pr))
            break
        }
      xc()
      for (let u of o)
        u &&
          BS(u, 4, {
            target: t,
            type: e,
            key: s,
            newValue: i,
            oldValue: r,
            oldTarget: n,
          })
      Ac()
    }
    function c4(t, e) {
      let s = Pc.get(t)
      return s && s.get(e)
    }
    var f4 = Se.makeMap('__proto__,__v_isRef,__isVue'),
      US = new Set(
        Object.getOwnPropertyNames(Symbol)
          .filter((t) => t !== 'arguments' && t !== 'caller')
          .map((t) => Symbol[t])
          .filter(Se.isSymbol)
      ),
      HS = h4()
    function h4() {
      let t = {}
      return (
        ['includes', 'indexOf', 'lastIndexOf'].forEach((e) => {
          t[e] = function (...s) {
            let i = Ue(this)
            for (let n = 0, a = this.length; n < a; n++) As(i, 'get', n + '')
            let r = i[e](...s)
            return r === -1 || r === !1 ? i[e](...s.map(Ue)) : r
          }
        }),
        ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((e) => {
          t[e] = function (...s) {
            Xd(), xc()
            let i = Ue(this)[e].apply(this, s)
            return Ac(), Gd(), i
          }
        }),
        t
      )
    }
    function p4(t) {
      Se.isSymbol(t) || (t = String(t))
      let e = Ue(this)
      return As(e, 'has', t), e.hasOwnProperty(t)
    }
    var Jd = class {
        constructor(e = !1, s = !1) {
          ;(this._isReadonly = e), (this._isShallow = s)
        }
        get(e, s, i) {
          let r = this._isReadonly,
            n = this._isShallow
          if (s === '__v_isReactive') return !r
          if (s === '__v_isReadonly') return r
          if (s === '__v_isShallow') return n
          if (s === '__v_raw')
            return i === (r ? (n ? JS : zS) : n ? WS : GS).get(e) ||
              Object.getPrototypeOf(e) === Object.getPrototypeOf(i)
              ? e
              : void 0
          let a = Se.isArray(e)
          if (!r) {
            if (a && Se.hasOwn(HS, s)) return Reflect.get(HS, s, i)
            if (s === 'hasOwnProperty') return p4
          }
          let o = Reflect.get(e, s, i)
          return (Se.isSymbol(s) ? US.has(s) : f4(s)) ||
            (r || As(e, 'get', s), n)
            ? o
            : ii(o)
            ? a && Se.isIntegerKey(s)
              ? o
              : o.value
            : Se.isObject(o)
            ? r
              ? t0(o)
              : e0(o)
            : o
        }
      },
      Yd = class extends Jd {
        constructor(e = !1) {
          super(!1, e)
        }
        set(e, s, i, r) {
          let n = e[s]
          if (!this._isShallow) {
            let u = mr(n)
            if (
              (!Oo(i) && !mr(i) && ((n = Ue(n)), (i = Ue(i))),
              !Se.isArray(e) && ii(n) && !ii(i))
            )
              return u ? !1 : ((n.value = i), !0)
          }
          let a =
              Se.isArray(e) && Se.isIntegerKey(s)
                ? Number(s) < e.length
                : Se.hasOwn(e, s),
            o = Reflect.set(e, s, i, r)
          return (
            e === Ue(r) &&
              (a
                ? Se.hasChanged(i, n) && wi(e, 'set', s, i, n)
                : wi(e, 'add', s, i)),
            o
          )
        }
        deleteProperty(e, s) {
          let i = Se.hasOwn(e, s),
            r = e[s],
            n = Reflect.deleteProperty(e, s)
          return n && i && wi(e, 'delete', s, void 0, r), n
        }
        has(e, s) {
          let i = Reflect.has(e, s)
          return (!Se.isSymbol(s) || !US.has(s)) && As(e, 'has', s), i
        }
        ownKeys(e) {
          return (
            As(e, 'iterate', Se.isArray(e) ? 'length' : pr), Reflect.ownKeys(e)
          )
        }
      },
      Qd = class extends Jd {
        constructor(e = !1) {
          super(!0, e)
        }
        set(e, s) {
          return (
            ti(
              `Set operation on key "${String(s)}" failed: target is readonly.`,
              e
            ),
            !0
          )
        }
        deleteProperty(e, s) {
          return (
            ti(
              `Delete operation on key "${String(
                s
              )}" failed: target is readonly.`,
              e
            ),
            !0
          )
        }
      },
      d4 = new Yd(),
      m4 = new Qd(),
      g4 = new Yd(!0),
      y4 = new Qd(!0),
      Zd = (t) => t,
      Cc = (t) => Reflect.getPrototypeOf(t)
    function vc(t, e, s = !1, i = !1) {
      t = t.__v_raw
      let r = Ue(t),
        n = Ue(e)
      s || (Se.hasChanged(e, n) && As(r, 'get', e), As(r, 'get', n))
      let { has: a } = Cc(r),
        o = i ? Zd : s ? i0 : wo
      if (a.call(r, e)) return o(t.get(e))
      if (a.call(r, n)) return o(t.get(n))
      t !== r && t.get(e)
    }
    function Nc(t, e = !1) {
      let s = this.__v_raw,
        i = Ue(s),
        r = Ue(t)
      return (
        e || (Se.hasChanged(t, r) && As(i, 'has', t), As(i, 'has', r)),
        t === r ? s.has(t) : s.has(t) || s.has(r)
      )
    }
    function Ic(t, e = !1) {
      return (
        (t = t.__v_raw),
        !e && As(Ue(t), 'iterate', pr),
        Reflect.get(t, 'size', t)
      )
    }
    function $S(t, e = !1) {
      !e && !Oo(t) && !mr(t) && (t = Ue(t))
      let s = Ue(this)
      return Cc(s).has.call(s, t) || (s.add(t), wi(s, 'add', t, t)), this
    }
    function jS(t, e, s = !1) {
      !s && !Oo(e) && !mr(e) && (e = Ue(e))
      let i = Ue(this),
        { has: r, get: n } = Cc(i),
        a = r.call(i, t)
      a ? XS(i, r, t) : ((t = Ue(t)), (a = r.call(i, t)))
      let o = n.call(i, t)
      return (
        i.set(t, e),
        a ? Se.hasChanged(e, o) && wi(i, 'set', t, e, o) : wi(i, 'add', t, e),
        this
      )
    }
    function qS(t) {
      let e = Ue(this),
        { has: s, get: i } = Cc(e),
        r = s.call(e, t)
      r ? XS(e, s, t) : ((t = Ue(t)), (r = s.call(e, t)))
      let n = i ? i.call(e, t) : void 0,
        a = e.delete(t)
      return r && wi(e, 'delete', t, void 0, n), a
    }
    function KS() {
      let t = Ue(this),
        e = t.size !== 0,
        s = Se.isMap(t) ? new Map(t) : new Set(t),
        i = t.clear()
      return e && wi(t, 'clear', void 0, void 0, s), i
    }
    function Oc(t, e) {
      return function (i, r) {
        let n = this,
          a = n.__v_raw,
          o = Ue(a),
          u = e ? Zd : t ? i0 : wo
        return (
          !t && As(o, 'iterate', pr),
          a.forEach((l, c) => i.call(r, u(l), u(c), n))
        )
      }
    }
    function wc(t, e, s) {
      return function (...i) {
        let r = this.__v_raw,
          n = Ue(r),
          a = Se.isMap(n),
          o = t === 'entries' || (t === Symbol.iterator && a),
          u = t === 'keys' && a,
          l = r[t](...i),
          c = s ? Zd : e ? i0 : wo
        return (
          !e && As(n, 'iterate', u ? zd : pr),
          {
            next() {
              let { value: f, done: h } = l.next()
              return h
                ? { value: f, done: h }
                : { value: o ? [c(f[0]), c(f[1])] : c(f), done: h }
            },
            [Symbol.iterator]() {
              return this
            },
          }
        )
      }
    }
    function dr(t) {
      return function (...e) {
        {
          let s = e[0] ? `on key "${e[0]}" ` : ''
          ti(
            `${Se.capitalize(t)} operation ${s}failed: target is readonly.`,
            Ue(this)
          )
        }
        return t === 'delete' ? !1 : t === 'clear' ? void 0 : this
      }
    }
    function b4() {
      let t = {
          get(n) {
            return vc(this, n)
          },
          get size() {
            return Ic(this)
          },
          has: Nc,
          add: $S,
          set: jS,
          delete: qS,
          clear: KS,
          forEach: Oc(!1, !1),
        },
        e = {
          get(n) {
            return vc(this, n, !1, !0)
          },
          get size() {
            return Ic(this)
          },
          has: Nc,
          add(n) {
            return $S.call(this, n, !0)
          },
          set(n, a) {
            return jS.call(this, n, a, !0)
          },
          delete: qS,
          clear: KS,
          forEach: Oc(!1, !0),
        },
        s = {
          get(n) {
            return vc(this, n, !0)
          },
          get size() {
            return Ic(this, !0)
          },
          has(n) {
            return Nc.call(this, n, !0)
          },
          add: dr('add'),
          set: dr('set'),
          delete: dr('delete'),
          clear: dr('clear'),
          forEach: Oc(!0, !1),
        },
        i = {
          get(n) {
            return vc(this, n, !0, !0)
          },
          get size() {
            return Ic(this, !0)
          },
          has(n) {
            return Nc.call(this, n, !0)
          },
          add: dr('add'),
          set: dr('set'),
          delete: dr('delete'),
          clear: dr('clear'),
          forEach: Oc(!0, !0),
        }
      return (
        ['keys', 'values', 'entries', Symbol.iterator].forEach((n) => {
          ;(t[n] = wc(n, !1, !1)),
            (s[n] = wc(n, !0, !1)),
            (e[n] = wc(n, !1, !0)),
            (i[n] = wc(n, !0, !0))
        }),
        [t, s, e, i]
      )
    }
    var [E4, S4, T4, _4] = b4()
    function Mc(t, e) {
      let s = e ? (t ? _4 : T4) : t ? S4 : E4
      return (i, r, n) =>
        r === '__v_isReactive'
          ? !t
          : r === '__v_isReadonly'
          ? t
          : r === '__v_raw'
          ? i
          : Reflect.get(Se.hasOwn(s, r) && r in i ? s : i, r, n)
    }
    var x4 = { get: Mc(!1, !1) },
      A4 = { get: Mc(!1, !0) },
      P4 = { get: Mc(!0, !1) },
      C4 = { get: Mc(!0, !0) }
    function XS(t, e, s) {
      let i = Ue(s)
      if (i !== s && e.call(t, i)) {
        let r = Se.toRawType(t)
        ti(
          `Reactive ${r} contains both the raw and reactive versions of the same object${
            r === 'Map' ? ' as keys' : ''
          }, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
        )
      }
    }
    var GS = new WeakMap(),
      WS = new WeakMap(),
      zS = new WeakMap(),
      JS = new WeakMap()
    function v4(t) {
      switch (t) {
        case 'Object':
        case 'Array':
          return 1
        case 'Map':
        case 'Set':
        case 'WeakMap':
        case 'WeakSet':
          return 2
        default:
          return 0
      }
    }
    function N4(t) {
      return t.__v_skip || !Object.isExtensible(t) ? 0 : v4(Se.toRawType(t))
    }
    function e0(t) {
      return mr(t) ? t : Rc(t, !1, d4, x4, GS)
    }
    function I4(t) {
      return Rc(t, !1, g4, A4, WS)
    }
    function t0(t) {
      return Rc(t, !0, m4, P4, zS)
    }
    function O4(t) {
      return Rc(t, !0, y4, C4, JS)
    }
    function Rc(t, e, s, i, r) {
      if (!Se.isObject(t))
        return (
          ti(
            `value cannot be made ${e ? 'readonly' : 'reactive'}: ${String(t)}`
          ),
          t
        )
      if (t.__v_raw && !(e && t.__v_isReactive)) return t
      let n = r.get(t)
      if (n) return n
      let a = N4(t)
      if (a === 0) return t
      let o = new Proxy(t, a === 2 ? i : s)
      return r.set(t, o), o
    }
    function s0(t) {
      return mr(t) ? s0(t.__v_raw) : !!(t && t.__v_isReactive)
    }
    function mr(t) {
      return !!(t && t.__v_isReadonly)
    }
    function Oo(t) {
      return !!(t && t.__v_isShallow)
    }
    function YS(t) {
      return t ? !!t.__v_raw : !1
    }
    function Ue(t) {
      let e = t && t.__v_raw
      return e ? Ue(e) : t
    }
    function w4(t) {
      return Object.isExtensible(t) && Se.def(t, '__v_skip', !0), t
    }
    var wo = (t) => (Se.isObject(t) ? e0(t) : t),
      i0 = (t) => (Se.isObject(t) ? t0(t) : t),
      M4 =
        'Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free',
      r0 = class {
        constructor(e, s, i, r) {
          ;(this.getter = e),
            (this._setter = s),
            (this.dep = void 0),
            (this.__v_isRef = !0),
            (this.__v_isReadonly = !1),
            (this.effect = new Io(
              () => e(this._value),
              () => la(this, this.effect._dirtyLevel === 2 ? 2 : 3)
            )),
            (this.effect.computed = this),
            (this.effect.active = this._cacheable = !r),
            (this.__v_isReadonly = i)
        }
        get value() {
          let e = Ue(this)
          return (
            (!e._cacheable || e.effect.dirty) &&
              Se.hasChanged(e._value, (e._value = e.effect.run())) &&
              la(e, 4),
            n0(e),
            e.effect._dirtyLevel >= 2 &&
              (this._warnRecursive &&
                ti(
                  M4,
                  `

getter: `,
                  this.getter
                ),
              la(e, 2)),
            e._value
          )
        }
        set value(e) {
          this._setter(e)
        }
        get _dirty() {
          return this.effect.dirty
        }
        set _dirty(e) {
          this.effect.dirty = e
        }
      }
    function QS(t, e, s = !1) {
      let i,
        r,
        n = Se.isFunction(t)
      n
        ? ((i = t),
          (r = () => {
            ti('Write operation failed: computed value is readonly')
          }))
        : ((i = t.get), (r = t.set))
      let a = new r0(i, r, n || !r, s)
      return (
        e &&
          !s &&
          ((a.effect.onTrack = e.onTrack), (a.effect.onTrigger = e.onTrigger)),
        a
      )
    }
    function n0(t) {
      var e
      si &&
        fn &&
        ((t = Ue(t)),
        FS(
          fn,
          (e = t.dep) != null
            ? e
            : (t.dep = VS(
                () => (t.dep = void 0),
                t instanceof r0 ? t : void 0
              )),
          { target: t, type: 'get', key: 'value' }
        ))
    }
    function la(t, e = 4, s, i) {
      t = Ue(t)
      let r = t.dep
      r &&
        BS(r, e, {
          target: t,
          type: 'set',
          key: 'value',
          newValue: s,
          oldValue: i,
        })
    }
    function ii(t) {
      return !!(t && t.__v_isRef === !0)
    }
    function ZS(t) {
      return eT(t, !1)
    }
    function R4(t) {
      return eT(t, !0)
    }
    function eT(t, e) {
      return ii(t) ? t : new tT(t, e)
    }
    var tT = class {
      constructor(e, s) {
        ;(this.__v_isShallow = s),
          (this.dep = void 0),
          (this.__v_isRef = !0),
          (this._rawValue = s ? e : Ue(e)),
          (this._value = s ? e : wo(e))
      }
      get value() {
        return n0(this), this._value
      }
      set value(e) {
        let s = this.__v_isShallow || Oo(e) || mr(e)
        if (((e = s ? e : Ue(e)), Se.hasChanged(e, this._rawValue))) {
          let i = this._rawValue
          ;(this._rawValue = e),
            (this._value = s ? e : wo(e)),
            la(this, 4, e, i)
        }
      }
    }
    function L4(t) {
      la(t, 4, t.value)
    }
    function a0(t) {
      return ii(t) ? t.value : t
    }
    function k4(t) {
      return Se.isFunction(t) ? t() : a0(t)
    }
    var D4 = {
      get: (t, e, s) => a0(Reflect.get(t, e, s)),
      set: (t, e, s, i) => {
        let r = t[e]
        return ii(r) && !ii(s) ? ((r.value = s), !0) : Reflect.set(t, e, s, i)
      },
    }
    function F4(t) {
      return s0(t) ? t : new Proxy(t, D4)
    }
    var sT = class {
      constructor(e) {
        ;(this.dep = void 0), (this.__v_isRef = !0)
        let { get: s, set: i } = e(
          () => n0(this),
          () => la(this)
        )
        ;(this._get = s), (this._set = i)
      }
      get value() {
        return this._get()
      }
      set value(e) {
        this._set(e)
      }
    }
    function B4(t) {
      return new sT(t)
    }
    function V4(t) {
      YS(t) ||
        ti('toRefs() expects a reactive object but received a plain one.')
      let e = Se.isArray(t) ? new Array(t.length) : {}
      for (let s in t) e[s] = nT(t, s)
      return e
    }
    var iT = class {
        constructor(e, s, i) {
          ;(this._object = e),
            (this._key = s),
            (this._defaultValue = i),
            (this.__v_isRef = !0)
        }
        get value() {
          let e = this._object[this._key]
          return e === void 0 ? this._defaultValue : e
        }
        set value(e) {
          this._object[this._key] = e
        }
        get dep() {
          return c4(Ue(this._object), this._key)
        }
      },
      rT = class {
        constructor(e) {
          ;(this._getter = e), (this.__v_isRef = !0), (this.__v_isReadonly = !0)
        }
        get value() {
          return this._getter()
        }
      }
    function U4(t, e, s) {
      return ii(t)
        ? t
        : Se.isFunction(t)
        ? new rT(t)
        : Se.isObject(t) && arguments.length > 1
        ? nT(t, e, s)
        : ZS(t)
    }
    function nT(t, e, s) {
      let i = t[e]
      return ii(i) ? i : new iT(t, e, s)
    }
    var H4 = QS,
      $4 = { GET: 'get', HAS: 'has', ITERATE: 'iterate' },
      j4 = { SET: 'set', ADD: 'add', DELETE: 'delete', CLEAR: 'clear' },
      q4 = {
        SKIP: '__v_skip',
        IS_REACTIVE: '__v_isReactive',
        IS_READONLY: '__v_isReadonly',
        IS_SHALLOW: '__v_isShallow',
        RAW: '__v_raw',
      }
    xe.EffectScope = jd
    xe.ITERATE_KEY = pr
    xe.ReactiveEffect = Io
    xe.ReactiveFlags = q4
    xe.TrackOpTypes = $4
    xe.TriggerOpTypes = j4
    xe.computed = QS
    xe.customRef = B4
    xe.deferredComputed = H4
    xe.effect = o4
    xe.effectScope = i4
    xe.enableTracking = l4
    xe.getCurrentScope = r4
    xe.isProxy = YS
    xe.isReactive = s0
    xe.isReadonly = mr
    xe.isRef = ii
    xe.isShallow = Oo
    xe.markRaw = w4
    xe.onScopeDispose = n4
    xe.pauseScheduling = xc
    xe.pauseTracking = Xd
    xe.proxyRefs = F4
    xe.reactive = e0
    xe.readonly = t0
    xe.ref = ZS
    xe.resetScheduling = Ac
    xe.resetTracking = Gd
    xe.shallowReactive = I4
    xe.shallowReadonly = O4
    xe.shallowRef = R4
    xe.stop = u4
    xe.toRaw = Ue
    xe.toRef = U4
    xe.toRefs = V4
    xe.toValue = k4
    xe.track = As
    xe.trigger = wi
    xe.triggerRef = L4
    xe.unref = a0
  })
  var u0 = Oe((DD, o0) => {
    'use strict'
    process.env.NODE_ENV === 'production'
      ? (o0.exports = MS())
      : (o0.exports = aT())
  })
  var v2 = Oe((K) => {
    'use strict'
    Object.defineProperty(K, '__esModule', { value: !0 })
    var ue = u0(),
      P = fs()
    function K4(t, e) {}
    var X4 = {
        SETUP_FUNCTION: 0,
        0: 'SETUP_FUNCTION',
        RENDER_FUNCTION: 1,
        1: 'RENDER_FUNCTION',
        WATCH_GETTER: 2,
        2: 'WATCH_GETTER',
        WATCH_CALLBACK: 3,
        3: 'WATCH_CALLBACK',
        WATCH_CLEANUP: 4,
        4: 'WATCH_CLEANUP',
        NATIVE_EVENT_HANDLER: 5,
        5: 'NATIVE_EVENT_HANDLER',
        COMPONENT_EVENT_HANDLER: 6,
        6: 'COMPONENT_EVENT_HANDLER',
        VNODE_HOOK: 7,
        7: 'VNODE_HOOK',
        DIRECTIVE_HOOK: 8,
        8: 'DIRECTIVE_HOOK',
        TRANSITION_HOOK: 9,
        9: 'TRANSITION_HOOK',
        APP_ERROR_HANDLER: 10,
        10: 'APP_ERROR_HANDLER',
        APP_WARN_HANDLER: 11,
        11: 'APP_WARN_HANDLER',
        FUNCTION_REF: 12,
        12: 'FUNCTION_REF',
        ASYNC_COMPONENT_LOADER: 13,
        13: 'ASYNC_COMPONENT_LOADER',
        SCHEDULER: 14,
        14: 'SCHEDULER',
        COMPONENT_UPDATE: 15,
        15: 'COMPONENT_UPDATE',
      },
      G4 = {
        sp: 'serverPrefetch hook',
        bc: 'beforeCreate hook',
        c: 'created hook',
        bm: 'beforeMount hook',
        m: 'mounted hook',
        bu: 'beforeUpdate hook',
        u: 'updated',
        bum: 'beforeUnmount hook',
        um: 'unmounted hook',
        a: 'activated hook',
        da: 'deactivated hook',
        ec: 'errorCaptured hook',
        rtc: 'renderTracked hook',
        rtg: 'renderTriggered hook',
        [0]: 'setup function',
        [1]: 'render function',
        [2]: 'watcher getter',
        [3]: 'watcher callback',
        [4]: 'watcher cleanup function',
        [5]: 'native event handler',
        [6]: 'component event handler',
        [7]: 'vnode hook',
        [8]: 'directive hook',
        [9]: 'transition hook',
        [10]: 'app errorHandler',
        [11]: 'app warnHandler',
        [12]: 'ref function',
        [13]: 'async component loader',
        [14]: 'scheduler flush',
        [15]: 'component update',
      }
    function Mi(t, e, s, i) {
      try {
        return i ? t(...i) : t()
      } catch (r) {
        hn(r, e, s)
      }
    }
    function Rs(t, e, s, i) {
      if (P.isFunction(t)) {
        let r = Mi(t, e, s, i)
        return (
          r &&
            P.isPromise(r) &&
            r.catch((n) => {
              hn(n, e, s)
            }),
          r
        )
      }
      if (P.isArray(t)) {
        let r = []
        for (let n = 0; n < t.length; n++) r.push(Rs(t[n], e, s, i))
        return r
      }
    }
    function hn(t, e, s, i = !0) {
      let r = e ? e.vnode : null
      if (e) {
        let n = e.parent,
          a = e.proxy,
          o = `https://vuejs.org/error-reference/#runtime-${s}`
        for (; n; ) {
          let l = n.ec
          if (l) {
            for (let c = 0; c < l.length; c++) if (l[c](t, a, o) === !1) return
          }
          n = n.parent
        }
        let u = e.appContext.config.errorHandler
        if (u) {
          ue.pauseTracking(), Mi(u, null, 10, [t, a, o]), ue.resetTracking()
          return
        }
      }
      W4(t, s, r, i)
    }
    function W4(t, e, s, i = !0) {
      console.error(t)
    }
    var Mo = !1,
      l0 = !1,
      Kt = [],
      ri = 0,
      ca = [],
      gr = null,
      pn = 0,
      oT = Promise.resolve(),
      c0 = null
    function uT(t) {
      let e = c0 || oT
      return t ? e.then(this ? t.bind(this) : t) : e
    }
    function z4(t) {
      let e = ri + 1,
        s = Kt.length
      for (; e < s; ) {
        let i = (e + s) >>> 1,
          r = Kt[i],
          n = Ro(r)
        n < t || (n === t && r.pre) ? (e = i + 1) : (s = i)
      }
      return e
    }
    function Lc(t) {
      ;(!Kt.length || !Kt.includes(t, Mo && t.allowRecurse ? ri + 1 : ri)) &&
        (t.id == null ? Kt.push(t) : Kt.splice(z4(t.id), 0, t), lT())
    }
    function lT() {
      !Mo && !l0 && ((l0 = !0), (c0 = oT.then(fT)))
    }
    function J4(t) {
      let e = Kt.indexOf(t)
      e > ri && Kt.splice(e, 1)
    }
    function kc(t) {
      P.isArray(t)
        ? ca.push(...t)
        : (!gr || !gr.includes(t, t.allowRecurse ? pn + 1 : pn)) && ca.push(t),
        lT()
    }
    function cT(t, e, s = Mo ? ri + 1 : 0) {
      for (; s < Kt.length; s++) {
        let i = Kt[s]
        if (i && i.pre) {
          if (t && i.id !== t.uid) continue
          Kt.splice(s, 1), s--, i()
        }
      }
    }
    function Dc(t) {
      if (ca.length) {
        let e = [...new Set(ca)].sort((s, i) => Ro(s) - Ro(i))
        if (((ca.length = 0), gr)) {
          gr.push(...e)
          return
        }
        for (gr = e, pn = 0; pn < gr.length; pn++) {
          let s = gr[pn]
          s.active !== !1 && s()
        }
        ;(gr = null), (pn = 0)
      }
    }
    var Ro = (t) => (t.id == null ? 1 / 0 : t.id),
      Y4 = (t, e) => {
        let s = Ro(t) - Ro(e)
        if (s === 0) {
          if (t.pre && !e.pre) return -1
          if (e.pre && !t.pre) return 1
        }
        return s
      }
    function fT(t) {
      ;(l0 = !1), (Mo = !0), Kt.sort(Y4)
      try {
        for (ri = 0; ri < Kt.length; ri++) {
          let e = Kt[ri]
          e && e.active !== !1 && Mi(e, e.i, e.i ? 15 : 14)
        }
      } finally {
        ;(ri = 0),
          (Kt.length = 0),
          Dc(),
          (Mo = !1),
          (c0 = null),
          (Kt.length || ca.length) && fT()
      }
    }
    var xt = null,
      Fc = null
    function Lo(t) {
      let e = xt
      return (xt = t), (Fc = (t && t.type.__scopeId) || null), e
    }
    function Q4(t) {
      Fc = t
    }
    function Z4() {
      Fc = null
    }
    var eM = (t) => f0
    function f0(t, e = xt, s) {
      if (!e || t._n) return t
      let i = (...r) => {
        i._d && L0(-1)
        let n = Lo(e),
          a
        try {
          a = t(...r)
        } finally {
          Lo(n), i._d && L0(1)
        }
        return a
      }
      return (i._n = !0), (i._c = !0), (i._d = !0), i
    }
    function tM(t, e) {
      if (xt === null) return t
      let s = Go(xt),
        i = t.dirs || (t.dirs = [])
      for (let r = 0; r < e.length; r++) {
        let [n, a, o, u = P.EMPTY_OBJ] = e[r]
        n &&
          (P.isFunction(n) && (n = { mounted: n, updated: n }),
          n.deep && br(a),
          i.push({
            dir: n,
            instance: s,
            value: a,
            oldValue: void 0,
            arg: o,
            modifiers: u,
          }))
      }
      return t
    }
    function ni(t, e, s, i) {
      let r = t.dirs,
        n = e && e.dirs
      for (let a = 0; a < r.length; a++) {
        let o = r[a]
        n && (o.oldValue = n[a].value)
        let u = o.dir[i]
        u &&
          (ue.pauseTracking(), Rs(u, s, 8, [t.el, o, t, e]), ue.resetTracking())
      }
    }
    var yr = Symbol('_leaveCb'),
      Bc = Symbol('_enterCb')
    function hT() {
      let t = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map(),
      }
      return (
        $c(() => {
          t.isMounted = !0
        }),
        jc(() => {
          t.isUnmounting = !0
        }),
        t
      )
    }
    var Ls = [Function, Array],
      pT = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: Ls,
        onEnter: Ls,
        onAfterEnter: Ls,
        onEnterCancelled: Ls,
        onBeforeLeave: Ls,
        onLeave: Ls,
        onAfterLeave: Ls,
        onLeaveCancelled: Ls,
        onBeforeAppear: Ls,
        onAppear: Ls,
        onAfterAppear: Ls,
        onAppearCancelled: Ls,
      },
      dT = (t) => {
        let e = t.subTree
        return e.component ? dT(e.component) : e
      },
      sM = {
        name: 'BaseTransition',
        props: pT,
        setup(t, { slots: e }) {
          let s = ga(),
            i = hT()
          return () => {
            let r = e.default && p0(e.default(), !0)
            if (!r || !r.length) return
            let n = r[0]
            if (r.length > 1) {
              for (let h of r)
                if (h.type !== Ot) {
                  n = h
                  break
                }
            }
            let a = ue.toRaw(t),
              { mode: o } = a
            if (i.isLeaving) return h0(n)
            let u = gT(n)
            if (!u) return h0(n)
            let l = Vc(u, a, i, s, (h) => (l = h))
            fa(u, l)
            let c = s.subTree,
              f = c && gT(c)
            if (f && f.type !== Ot && !Ks(u, f) && dT(s).type !== Ot) {
              let h = Vc(f, a, i, s)
              if ((fa(f, h), o === 'out-in' && u.type !== Ot))
                return (
                  (i.isLeaving = !0),
                  (h.afterLeave = () => {
                    ;(i.isLeaving = !1),
                      s.update.active !== !1 &&
                        ((s.effect.dirty = !0), s.update())
                  }),
                  h0(n)
                )
              o === 'in-out' &&
                u.type !== Ot &&
                (h.delayLeave = (p, m, y) => {
                  let x = mT(i, f)
                  ;(x[String(f.key)] = f),
                    (p[yr] = () => {
                      m(), (p[yr] = void 0), delete l.delayedLeave
                    }),
                    (l.delayedLeave = y)
                })
            }
            return n
          }
        },
      },
      iM = sM
    function mT(t, e) {
      let { leavingVNodes: s } = t,
        i = s.get(e.type)
      return i || ((i = Object.create(null)), s.set(e.type, i)), i
    }
    function Vc(t, e, s, i, r) {
      let {
          appear: n,
          mode: a,
          persisted: o = !1,
          onBeforeEnter: u,
          onEnter: l,
          onAfterEnter: c,
          onEnterCancelled: f,
          onBeforeLeave: h,
          onLeave: p,
          onAfterLeave: m,
          onLeaveCancelled: y,
          onBeforeAppear: x,
          onAppear: C,
          onAfterAppear: E,
          onAppearCancelled: g,
        } = e,
        S = String(t.key),
        _ = mT(s, t),
        I = (N, O) => {
          N && Rs(N, i, 9, O)
        },
        k = (N, O) => {
          let v = O[1]
          I(N, O),
            P.isArray(N)
              ? N.every((A) => A.length <= 1) && v()
              : N.length <= 1 && v()
        },
        L = {
          mode: a,
          persisted: o,
          beforeEnter(N) {
            let O = u
            if (!s.isMounted)
              if (n) O = x || u
              else return
            N[yr] && N[yr](!0)
            let v = _[S]
            v && Ks(t, v) && v.el[yr] && v.el[yr](), I(O, [N])
          },
          enter(N) {
            let O = l,
              v = c,
              A = f
            if (!s.isMounted)
              if (n) (O = C || l), (v = E || c), (A = g || f)
              else return
            let V = !1,
              se = (N[Bc] = (Y) => {
                V ||
                  ((V = !0),
                  Y ? I(A, [N]) : I(v, [N]),
                  L.delayedLeave && L.delayedLeave(),
                  (N[Bc] = void 0))
              })
            O ? k(O, [N, se]) : se()
          },
          leave(N, O) {
            let v = String(t.key)
            if ((N[Bc] && N[Bc](!0), s.isUnmounting)) return O()
            I(h, [N])
            let A = !1,
              V = (N[yr] = (se) => {
                A ||
                  ((A = !0),
                  O(),
                  se ? I(y, [N]) : I(m, [N]),
                  (N[yr] = void 0),
                  _[v] === t && delete _[v])
              })
            ;(_[v] = t), p ? k(p, [N, V]) : V()
          },
          clone(N) {
            let O = Vc(N, e, s, i, r)
            return r && r(O), O
          },
        }
      return L
    }
    function h0(t) {
      if (ko(t)) return (t = ai(t)), (t.children = null), t
    }
    function gT(t) {
      if (!ko(t)) return t
      let { shapeFlag: e, children: s } = t
      if (s) {
        if (e & 16) return s[0]
        if (e & 32 && P.isFunction(s.default)) return s.default()
      }
    }
    function fa(t, e) {
      t.shapeFlag & 6 && t.component
        ? fa(t.component.subTree, e)
        : t.shapeFlag & 128
        ? ((t.ssContent.transition = e.clone(t.ssContent)),
          (t.ssFallback.transition = e.clone(t.ssFallback)))
        : (t.transition = e)
    }
    function p0(t, e = !1, s) {
      let i = [],
        r = 0
      for (let n = 0; n < t.length; n++) {
        let a = t[n],
          o = s == null ? a.key : String(s) + String(a.key != null ? a.key : n)
        a.type === es
          ? (a.patchFlag & 128 && r++, (i = i.concat(p0(a.children, e, o))))
          : (e || a.type !== Ot) && i.push(o != null ? ai(a, { key: o }) : a)
      }
      if (r > 1) for (let n = 0; n < i.length; n++) i[n].patchFlag = -2
      return i
    }
    function yT(t, e) {
      return P.isFunction(t)
        ? (() => P.extend({ name: t.name }, e, { setup: t }))()
        : t
    }
    var dn = (t) => !!t.type.__asyncLoader
    function rM(t) {
      P.isFunction(t) && (t = { loader: t })
      let {
          loader: e,
          loadingComponent: s,
          errorComponent: i,
          delay: r = 200,
          timeout: n,
          suspensible: a = !0,
          onError: o,
        } = t,
        u = null,
        l,
        c = 0,
        f = () => (c++, (u = null), h()),
        h = () => {
          let p
          return (
            u ||
            (p = u =
              e()
                .catch((m) => {
                  if (((m = m instanceof Error ? m : new Error(String(m))), o))
                    return new Promise((y, x) => {
                      o(
                        m,
                        () => y(f()),
                        () => x(m),
                        c + 1
                      )
                    })
                  throw m
                })
                .then((m) =>
                  p !== u && u
                    ? u
                    : (m &&
                        (m.__esModule || m[Symbol.toStringTag] === 'Module') &&
                        (m = m.default),
                      (l = m),
                      m)
                ))
          )
        }
      return yT({
        name: 'AsyncComponentWrapper',
        __asyncLoader: h,
        get __asyncResolved() {
          return l
        },
        setup() {
          let p = At
          if (l) return () => d0(l, p)
          let m = (E) => {
            ;(u = null), hn(E, p, 13, !i)
          }
          if ((a && p.suspense) || Xo)
            return h()
              .then((E) => () => d0(E, p))
              .catch((E) => (m(E), () => (i ? ot(i, { error: E }) : null)))
          let y = ue.ref(!1),
            x = ue.ref(),
            C = ue.ref(!!r)
          return (
            r &&
              setTimeout(() => {
                C.value = !1
              }, r),
            n != null &&
              setTimeout(() => {
                if (!y.value && !x.value) {
                  let E = new Error(`Async component timed out after ${n}ms.`)
                  m(E), (x.value = E)
                }
              }, n),
            h()
              .then(() => {
                ;(y.value = !0),
                  p.parent &&
                    ko(p.parent.vnode) &&
                    ((p.parent.effect.dirty = !0), Lc(p.parent.update))
              })
              .catch((E) => {
                m(E), (x.value = E)
              }),
            () => {
              if (y.value && l) return d0(l, p)
              if (x.value && i) return ot(i, { error: x.value })
              if (s && !C.value) return ot(s)
            }
          )
        },
      })
    }
    function d0(t, e) {
      let { ref: s, props: i, children: r, ce: n } = e.vnode,
        a = ot(t, i, r)
      return (a.ref = s), (a.ce = n), delete e.vnode.ce, a
    }
    var ko = (t) => t.type.__isKeepAlive,
      nM = {
        name: 'KeepAlive',
        __isKeepAlive: !0,
        props: {
          include: [String, RegExp, Array],
          exclude: [String, RegExp, Array],
          max: [String, Number],
        },
        setup(t, { slots: e }) {
          let s = ga(),
            i = s.ctx
          if (!i.renderer)
            return () => {
              let E = e.default && e.default()
              return E && E.length === 1 ? E[0] : E
            }
          let r = new Map(),
            n = new Set(),
            a = null,
            o = s.suspense,
            {
              renderer: {
                p: u,
                m: l,
                um: c,
                o: { createElement: f },
              },
            } = i,
            h = f('div')
          ;(i.activate = (E, g, S, _, I) => {
            let k = E.component
            l(E, g, S, 0, o),
              u(k.vnode, E, g, S, k, o, _, E.slotScopeIds, I),
              It(() => {
                ;(k.isDeactivated = !1), k.a && P.invokeArrayFns(k.a)
                let L = E.props && E.props.onVnodeMounted
                L && us(L, k.parent, E)
              }, o)
          }),
            (i.deactivate = (E) => {
              let g = E.component
              zc(g.m),
                zc(g.a),
                l(E, h, null, 1, o),
                It(() => {
                  g.da && P.invokeArrayFns(g.da)
                  let S = E.props && E.props.onVnodeUnmounted
                  S && us(S, g.parent, E), (g.isDeactivated = !0)
                }, o)
            })
          function p(E) {
            m0(E), c(E, s, o, !0)
          }
          function m(E) {
            r.forEach((g, S) => {
              let _ = j0(g.type)
              _ && (!E || !E(_)) && y(S)
            })
          }
          function y(E) {
            let g = r.get(E)
            !a || !Ks(g, a) ? p(g) : a && m0(a), r.delete(E), n.delete(E)
          }
          $o(
            () => [t.include, t.exclude],
            ([E, g]) => {
              E && m((S) => Do(E, S)), g && m((S) => !Do(g, S))
            },
            { flush: 'post', deep: !0 }
          )
          let x = null,
            C = () => {
              x != null &&
                (M0(s.subTree.type)
                  ? It(() => {
                      r.set(x, Uc(s.subTree))
                    }, s.subTree.suspense)
                  : r.set(x, Uc(s.subTree)))
            }
          return (
            $c(C),
            g0(C),
            jc(() => {
              r.forEach((E) => {
                let { subTree: g, suspense: S } = s,
                  _ = Uc(g)
                if (E.type === _.type && E.key === _.key) {
                  m0(_)
                  let I = _.component.da
                  I && It(I, S)
                  return
                }
                p(E)
              })
            }),
            () => {
              if (((x = null), !e.default)) return null
              let E = e.default(),
                g = E[0]
              if (E.length > 1) return (a = null), E
              if (!Sr(g) || (!(g.shapeFlag & 4) && !(g.shapeFlag & 128)))
                return (a = null), g
              let S = Uc(g),
                _ = S.type,
                I = j0(dn(S) ? S.type.__asyncResolved || {} : _),
                { include: k, exclude: L, max: N } = t
              if ((k && (!I || !Do(k, I))) || (L && I && Do(L, I)))
                return (a = S), g
              let O = S.key == null ? _ : S.key,
                v = r.get(O)
              return (
                S.el && ((S = ai(S)), g.shapeFlag & 128 && (g.ssContent = S)),
                (x = O),
                v
                  ? ((S.el = v.el),
                    (S.component = v.component),
                    S.transition && fa(S, S.transition),
                    (S.shapeFlag |= 512),
                    n.delete(O),
                    n.add(O))
                  : (n.add(O),
                    N &&
                      n.size > parseInt(N, 10) &&
                      y(n.values().next().value)),
                (S.shapeFlag |= 256),
                (a = S),
                M0(g.type) ? g : S
              )
            }
          )
        },
      },
      aM = nM
    function Do(t, e) {
      return P.isArray(t)
        ? t.some((s) => Do(s, e))
        : P.isString(t)
        ? t.split(',').includes(e)
        : P.isRegExp(t)
        ? t.test(e)
        : !1
    }
    function bT(t, e) {
      ST(t, 'a', e)
    }
    function ET(t, e) {
      ST(t, 'da', e)
    }
    function ST(t, e, s = At) {
      let i =
        t.__wdc ||
        (t.__wdc = () => {
          let r = s
          for (; r; ) {
            if (r.isDeactivated) return
            r = r.parent
          }
          return t()
        })
      if ((Hc(e, i, s), s)) {
        let r = s.parent
        for (; r && r.parent; )
          ko(r.parent.vnode) && oM(i, e, s, r), (r = r.parent)
      }
    }
    function oM(t, e, s, i) {
      let r = Hc(e, t, i, !0)
      y0(() => {
        P.remove(i[e], r)
      }, s)
    }
    function m0(t) {
      ;(t.shapeFlag &= ~256), (t.shapeFlag &= ~512)
    }
    function Uc(t) {
      return t.shapeFlag & 128 ? t.ssContent : t
    }
    function Hc(t, e, s = At, i = !1) {
      if (s) {
        let r = s[t] || (s[t] = []),
          n =
            e.__weh ||
            (e.__weh = (...a) => {
              ue.pauseTracking()
              let o = yn(s),
                u = Rs(e, s, t, a)
              return o(), ue.resetTracking(), u
            })
        return i ? r.unshift(n) : r.push(n), n
      }
    }
    var Ri =
        (t) =>
        (e, s = At) => {
          ;(!Xo || t === 'sp') && Hc(t, (...i) => e(...i), s)
        },
      TT = Ri('bm'),
      $c = Ri('m'),
      _T = Ri('bu'),
      g0 = Ri('u'),
      jc = Ri('bum'),
      y0 = Ri('um'),
      xT = Ri('sp'),
      AT = Ri('rtg'),
      PT = Ri('rtc')
    function CT(t, e = At) {
      Hc('ec', t, e)
    }
    var b0 = 'components',
      uM = 'directives'
    function lM(t, e) {
      return E0(b0, t, !0, e) || t
    }
    var vT = Symbol.for('v-ndc')
    function cM(t) {
      return P.isString(t) ? E0(b0, t, !1) || t : t || vT
    }
    function fM(t) {
      return E0(uM, t)
    }
    function E0(t, e, s = !0, i = !1) {
      let r = xt || At
      if (r) {
        let n = r.type
        if (t === b0) {
          let o = j0(n, !1)
          if (
            o &&
            (o === e ||
              o === P.camelize(e) ||
              o === P.capitalize(P.camelize(e)))
          )
            return n
        }
        let a = NT(r[t] || n[t], e) || NT(r.appContext[t], e)
        return !a && i ? n : a
      }
    }
    function NT(t, e) {
      return t && (t[e] || t[P.camelize(e)] || t[P.capitalize(P.camelize(e))])
    }
    function hM(t, e, s, i) {
      let r,
        n = s && s[i]
      if (P.isArray(t) || P.isString(t)) {
        r = new Array(t.length)
        for (let a = 0, o = t.length; a < o; a++)
          r[a] = e(t[a], a, void 0, n && n[a])
      } else if (typeof t == 'number') {
        r = new Array(t)
        for (let a = 0; a < t; a++) r[a] = e(a + 1, a, void 0, n && n[a])
      } else if (P.isObject(t))
        if (t[Symbol.iterator])
          r = Array.from(t, (a, o) => e(a, o, void 0, n && n[o]))
        else {
          let a = Object.keys(t)
          r = new Array(a.length)
          for (let o = 0, u = a.length; o < u; o++) {
            let l = a[o]
            r[o] = e(t[l], l, o, n && n[o])
          }
        }
      else r = []
      return s && (s[i] = r), r
    }
    function pM(t, e) {
      for (let s = 0; s < e.length; s++) {
        let i = e[s]
        if (P.isArray(i))
          for (let r = 0; r < i.length; r++) t[i[r].name] = i[r].fn
        else
          i &&
            (t[i.name] = i.key
              ? (...r) => {
                  let n = i.fn(...r)
                  return n && (n.key = i.key), n
                }
              : i.fn)
      }
      return t
    }
    function dM(t, e, s = {}, i, r) {
      if (xt.isCE || (xt.parent && dn(xt.parent) && xt.parent.isCE))
        return e !== 'default' && (s.name = e), ot('slot', s, i && i())
      let n = t[e]
      n && n._c && (n._d = !1), Zc()
      let a = n && IT(n(s)),
        o = k0(
          es,
          { key: (s.key || (a && a.key) || `_${e}`) + (!a && i ? '_fb' : '') },
          a || (i ? i() : []),
          a && t._ === 1 ? 64 : -2
        )
      return (
        !r && o.scopeId && (o.slotScopeIds = [o.scopeId + '-s']),
        n && n._c && (n._d = !0),
        o
      )
    }
    function IT(t) {
      return t.some((e) =>
        Sr(e) ? !(e.type === Ot || (e.type === es && !IT(e.children))) : !0
      )
        ? t
        : null
    }
    function mM(t, e) {
      let s = {}
      for (let i in t)
        s[e && /[A-Z]/.test(i) ? `on:${i}` : P.toHandlerKey(i)] = t[i]
      return s
    }
    var S0 = (t) => (t ? (S2(t) ? Go(t) : S0(t.parent)) : null),
      Fo = P.extend(Object.create(null), {
        $: (t) => t,
        $el: (t) => t.vnode.el,
        $data: (t) => t.data,
        $props: (t) => t.props,
        $attrs: (t) => t.attrs,
        $slots: (t) => t.slots,
        $refs: (t) => t.refs,
        $parent: (t) => S0(t.parent),
        $root: (t) => S0(t.root),
        $emit: (t) => t.emit,
        $options: (t) => A0(t),
        $forceUpdate: (t) =>
          t.f ||
          (t.f = () => {
            ;(t.effect.dirty = !0), Lc(t.update)
          }),
        $nextTick: (t) => t.n || (t.n = uT.bind(t.proxy)),
        $watch: (t) => s8.bind(t),
      }),
      T0 = (t, e) => t !== P.EMPTY_OBJ && !t.__isScriptSetup && P.hasOwn(t, e),
      _0 = {
        get({ _: t }, e) {
          if (e === '__v_skip') return !0
          let {
              ctx: s,
              setupState: i,
              data: r,
              props: n,
              accessCache: a,
              type: o,
              appContext: u,
            } = t,
            l
          if (e[0] !== '$') {
            let p = a[e]
            if (p !== void 0)
              switch (p) {
                case 1:
                  return i[e]
                case 2:
                  return r[e]
                case 4:
                  return s[e]
                case 3:
                  return n[e]
              }
            else {
              if (T0(i, e)) return (a[e] = 1), i[e]
              if (r !== P.EMPTY_OBJ && P.hasOwn(r, e)) return (a[e] = 2), r[e]
              if ((l = t.propsOptions[0]) && P.hasOwn(l, e))
                return (a[e] = 3), n[e]
              if (s !== P.EMPTY_OBJ && P.hasOwn(s, e)) return (a[e] = 4), s[e]
              x0 && (a[e] = 0)
            }
          }
          let c = Fo[e],
            f,
            h
          if (c) return e === '$attrs' && ue.track(t.attrs, 'get', ''), c(t)
          if ((f = o.__cssModules) && (f = f[e])) return f
          if (s !== P.EMPTY_OBJ && P.hasOwn(s, e)) return (a[e] = 4), s[e]
          if (((h = u.config.globalProperties), P.hasOwn(h, e))) return h[e]
        },
        set({ _: t }, e, s) {
          let { data: i, setupState: r, ctx: n } = t
          return T0(r, e)
            ? ((r[e] = s), !0)
            : i !== P.EMPTY_OBJ && P.hasOwn(i, e)
            ? ((i[e] = s), !0)
            : P.hasOwn(t.props, e) || (e[0] === '$' && e.slice(1) in t)
            ? !1
            : ((n[e] = s), !0)
        },
        has(
          {
            _: {
              data: t,
              setupState: e,
              accessCache: s,
              ctx: i,
              appContext: r,
              propsOptions: n,
            },
          },
          a
        ) {
          let o
          return (
            !!s[a] ||
            (t !== P.EMPTY_OBJ && P.hasOwn(t, a)) ||
            T0(e, a) ||
            ((o = n[0]) && P.hasOwn(o, a)) ||
            P.hasOwn(i, a) ||
            P.hasOwn(Fo, a) ||
            P.hasOwn(r.config.globalProperties, a)
          )
        },
        defineProperty(t, e, s) {
          return (
            s.get != null
              ? (t._.accessCache[e] = 0)
              : P.hasOwn(s, 'value') && this.set(t, e, s.value, null),
            Reflect.defineProperty(t, e, s)
          )
        },
      },
      gM = P.extend({}, _0, {
        get(t, e) {
          if (e !== Symbol.unscopables) return _0.get(t, e, t)
        },
        has(t, e) {
          return e[0] !== '_' && !P.isGloballyAllowed(e)
        },
      })
    function yM() {
      return null
    }
    function bM() {
      return null
    }
    function EM(t) {}
    function SM(t) {}
    function TM() {
      return null
    }
    function _M() {}
    function xM(t, e) {
      return null
    }
    function AM() {
      return OT().slots
    }
    function PM() {
      return OT().attrs
    }
    function OT() {
      let t = ga()
      return t.setupContext || (t.setupContext = x2(t))
    }
    function Bo(t) {
      return P.isArray(t) ? t.reduce((e, s) => ((e[s] = null), e), {}) : t
    }
    function CM(t, e) {
      let s = Bo(t)
      for (let i in e) {
        if (i.startsWith('__skip')) continue
        let r = s[i]
        r
          ? P.isArray(r) || P.isFunction(r)
            ? (r = s[i] = { type: r, default: e[i] })
            : (r.default = e[i])
          : r === null && (r = s[i] = { default: e[i] }),
          r && e[`__skip_${i}`] && (r.skipFactory = !0)
      }
      return s
    }
    function vM(t, e) {
      return !t || !e
        ? t || e
        : P.isArray(t) && P.isArray(e)
        ? t.concat(e)
        : P.extend({}, Bo(t), Bo(e))
    }
    function NM(t, e) {
      let s = {}
      for (let i in t)
        e.includes(i) ||
          Object.defineProperty(s, i, { enumerable: !0, get: () => t[i] })
      return s
    }
    function IM(t) {
      let e = ga(),
        s = t()
      return (
        U0(),
        P.isPromise(s) &&
          (s = s.catch((i) => {
            throw (yn(e), i)
          })),
        [s, () => yn(e)]
      )
    }
    var x0 = !0
    function OM(t) {
      let e = A0(t),
        s = t.proxy,
        i = t.ctx
      ;(x0 = !1), e.beforeCreate && wT(e.beforeCreate, t, 'bc')
      let {
        data: r,
        computed: n,
        methods: a,
        watch: o,
        provide: u,
        inject: l,
        created: c,
        beforeMount: f,
        mounted: h,
        beforeUpdate: p,
        updated: m,
        activated: y,
        deactivated: x,
        beforeDestroy: C,
        beforeUnmount: E,
        destroyed: g,
        unmounted: S,
        render: _,
        renderTracked: I,
        renderTriggered: k,
        errorCaptured: L,
        serverPrefetch: N,
        expose: O,
        inheritAttrs: v,
        components: A,
        directives: V,
        filters: se,
      } = e
      if ((l && wM(l, i, null), a))
        for (let ee in a) {
          let z = a[ee]
          P.isFunction(z) && (i[ee] = z.bind(s))
        }
      if (r) {
        let ee = r.call(s, s)
        P.isObject(ee) && (t.data = ue.reactive(ee))
      }
      if (((x0 = !0), n))
        for (let ee in n) {
          let z = n[ee],
            He = P.isFunction(z)
              ? z.bind(s, s)
              : P.isFunction(z.get)
              ? z.get.bind(s, s)
              : P.NOOP,
            St =
              !P.isFunction(z) && P.isFunction(z.set) ? z.set.bind(s) : P.NOOP,
            Ze = A2({ get: He, set: St })
          Object.defineProperty(i, ee, {
            enumerable: !0,
            configurable: !0,
            get: () => Ze.value,
            set: (rt) => (Ze.value = rt),
          })
        }
      if (o) for (let ee in o) MT(o[ee], i, s, ee)
      if (u) {
        let ee = P.isFunction(u) ? u.call(s) : u
        Reflect.ownKeys(ee).forEach((z) => {
          DT(z, ee[z])
        })
      }
      c && wT(c, t, 'c')
      function q(ee, z) {
        P.isArray(z) ? z.forEach((He) => ee(He.bind(s))) : z && ee(z.bind(s))
      }
      if (
        (q(TT, f),
        q($c, h),
        q(_T, p),
        q(g0, m),
        q(bT, y),
        q(ET, x),
        q(CT, L),
        q(PT, I),
        q(AT, k),
        q(jc, E),
        q(y0, S),
        q(xT, N),
        P.isArray(O))
      )
        if (O.length) {
          let ee = t.exposed || (t.exposed = {})
          O.forEach((z) => {
            Object.defineProperty(ee, z, {
              get: () => s[z],
              set: (He) => (s[z] = He),
            })
          })
        } else t.exposed || (t.exposed = {})
      _ && t.render === P.NOOP && (t.render = _),
        v != null && (t.inheritAttrs = v),
        A && (t.components = A),
        V && (t.directives = V)
    }
    function wM(t, e, s = P.NOOP) {
      P.isArray(t) && (t = P0(t))
      for (let i in t) {
        let r = t[i],
          n
        P.isObject(r)
          ? 'default' in r
            ? (n = Uo(r.from || i, r.default, !0))
            : (n = Uo(r.from || i))
          : (n = Uo(r)),
          ue.isRef(n)
            ? Object.defineProperty(e, i, {
                enumerable: !0,
                configurable: !0,
                get: () => n.value,
                set: (a) => (n.value = a),
              })
            : (e[i] = n)
      }
    }
    function wT(t, e, s) {
      Rs(P.isArray(t) ? t.map((i) => i.bind(e.proxy)) : t.bind(e.proxy), e, s)
    }
    function MT(t, e, s, i) {
      let r = i.includes('.') ? o2(s, i) : () => s[i]
      if (P.isString(t)) {
        let n = e[t]
        P.isFunction(n) && $o(r, n)
      } else if (P.isFunction(t)) $o(r, t.bind(s))
      else if (P.isObject(t))
        if (P.isArray(t)) t.forEach((n) => MT(n, e, s, i))
        else {
          let n = P.isFunction(t.handler) ? t.handler.bind(s) : e[t.handler]
          P.isFunction(n) && $o(r, n, t)
        }
    }
    function A0(t) {
      let e = t.type,
        { mixins: s, extends: i } = e,
        {
          mixins: r,
          optionsCache: n,
          config: { optionMergeStrategies: a },
        } = t.appContext,
        o = n.get(e),
        u
      return (
        o
          ? (u = o)
          : !r.length && !s && !i
          ? (u = e)
          : ((u = {}),
            r.length && r.forEach((l) => qc(u, l, a, !0)),
            qc(u, e, a)),
        P.isObject(e) && n.set(e, u),
        u
      )
    }
    function qc(t, e, s, i = !1) {
      let { mixins: r, extends: n } = e
      n && qc(t, n, s, !0), r && r.forEach((a) => qc(t, a, s, !0))
      for (let a in e)
        if (!(i && a === 'expose')) {
          let o = MM[a] || (s && s[a])
          t[a] = o ? o(t[a], e[a]) : e[a]
        }
      return t
    }
    var MM = {
      data: RT,
      props: LT,
      emits: LT,
      methods: Vo,
      computed: Vo,
      beforeCreate: Zt,
      created: Zt,
      beforeMount: Zt,
      mounted: Zt,
      beforeUpdate: Zt,
      updated: Zt,
      beforeDestroy: Zt,
      beforeUnmount: Zt,
      destroyed: Zt,
      unmounted: Zt,
      activated: Zt,
      deactivated: Zt,
      errorCaptured: Zt,
      serverPrefetch: Zt,
      components: Vo,
      directives: Vo,
      watch: LM,
      provide: RT,
      inject: RM,
    }
    function RT(t, e) {
      return e
        ? t
          ? function () {
              return P.extend(
                P.isFunction(t) ? t.call(this, this) : t,
                P.isFunction(e) ? e.call(this, this) : e
              )
            }
          : e
        : t
    }
    function RM(t, e) {
      return Vo(P0(t), P0(e))
    }
    function P0(t) {
      if (P.isArray(t)) {
        let e = {}
        for (let s = 0; s < t.length; s++) e[t[s]] = t[s]
        return e
      }
      return t
    }
    function Zt(t, e) {
      return t ? [...new Set([].concat(t, e))] : e
    }
    function Vo(t, e) {
      return t ? P.extend(Object.create(null), t, e) : e
    }
    function LT(t, e) {
      return t
        ? P.isArray(t) && P.isArray(e)
          ? [...new Set([...t, ...e])]
          : P.extend(Object.create(null), Bo(t), Bo(e != null ? e : {}))
        : e
    }
    function LM(t, e) {
      if (!t) return e
      if (!e) return t
      let s = P.extend(Object.create(null), t)
      for (let i in e) s[i] = Zt(t[i], e[i])
      return s
    }
    function kT() {
      return {
        app: null,
        config: {
          isNativeTag: P.NO,
          performance: !1,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {},
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap(),
      }
    }
    var kM = 0
    function DM(t, e) {
      return function (i, r = null) {
        P.isFunction(i) || (i = P.extend({}, i)),
          r != null && !P.isObject(r) && (r = null)
        let n = kT(),
          a = new WeakSet(),
          o = !1,
          u = (n.app = {
            _uid: kM++,
            _component: i,
            _props: r,
            _container: null,
            _context: n,
            _instance: null,
            version: C2,
            get config() {
              return n.config
            },
            set config(l) {},
            use(l, ...c) {
              return (
                a.has(l) ||
                  (l && P.isFunction(l.install)
                    ? (a.add(l), l.install(u, ...c))
                    : P.isFunction(l) && (a.add(l), l(u, ...c))),
                u
              )
            },
            mixin(l) {
              return n.mixins.includes(l) || n.mixins.push(l), u
            },
            component(l, c) {
              return c ? ((n.components[l] = c), u) : n.components[l]
            },
            directive(l, c) {
              return c ? ((n.directives[l] = c), u) : n.directives[l]
            },
            mount(l, c, f) {
              if (!o) {
                let h = ot(i, r)
                return (
                  (h.appContext = n),
                  f === !0 ? (f = 'svg') : f === !1 && (f = void 0),
                  c && e ? e(h, l) : t(h, l, f),
                  (o = !0),
                  (u._container = l),
                  (l.__vue_app__ = u),
                  Go(h.component)
                )
              }
            },
            unmount() {
              o && (t(null, u._container), delete u._container.__vue_app__)
            },
            provide(l, c) {
              return (n.provides[l] = c), u
            },
            runWithContext(l) {
              let c = ha
              ha = u
              try {
                return l()
              } finally {
                ha = c
              }
            },
          })
        return u
      }
    }
    var ha = null
    function DT(t, e) {
      if (At) {
        let s = At.provides,
          i = At.parent && At.parent.provides
        i === s && (s = At.provides = Object.create(i)), (s[t] = e)
      }
    }
    function Uo(t, e, s = !1) {
      let i = At || xt
      if (i || ha) {
        let r = i
          ? i.parent == null
            ? i.vnode.appContext && i.vnode.appContext.provides
            : i.parent.provides
          : ha._context.provides
        if (r && t in r) return r[t]
        if (arguments.length > 1)
          return s && P.isFunction(e) ? e.call(i && i.proxy) : e
      }
    }
    function FM() {
      return !!(At || xt || ha)
    }
    var FT = {},
      BT = () => Object.create(FT),
      VT = (t) => Object.getPrototypeOf(t) === FT
    function BM(t, e, s, i = !1) {
      let r = {},
        n = BT()
      ;(t.propsDefaults = Object.create(null)), UT(t, e, r, n)
      for (let a in t.propsOptions[0]) a in r || (r[a] = void 0)
      s
        ? (t.props = i ? r : ue.shallowReactive(r))
        : t.type.props
        ? (t.props = r)
        : (t.props = n),
        (t.attrs = n)
    }
    function VM(t, e, s, i) {
      let {
          props: r,
          attrs: n,
          vnode: { patchFlag: a },
        } = t,
        o = ue.toRaw(r),
        [u] = t.propsOptions,
        l = !1
      if ((i || a > 0) && !(a & 16)) {
        if (a & 8) {
          let c = t.vnode.dynamicProps
          for (let f = 0; f < c.length; f++) {
            let h = c[f]
            if (Yc(t.emitsOptions, h)) continue
            let p = e[h]
            if (u)
              if (P.hasOwn(n, h)) p !== n[h] && ((n[h] = p), (l = !0))
              else {
                let m = P.camelize(h)
                r[m] = C0(u, o, m, p, t, !1)
              }
            else p !== n[h] && ((n[h] = p), (l = !0))
          }
        }
      } else {
        UT(t, e, r, n) && (l = !0)
        let c
        for (let f in o)
          (!e ||
            (!P.hasOwn(e, f) &&
              ((c = P.hyphenate(f)) === f || !P.hasOwn(e, c)))) &&
            (u
              ? s &&
                (s[f] !== void 0 || s[c] !== void 0) &&
                (r[f] = C0(u, o, f, void 0, t, !0))
              : delete r[f])
        if (n !== o)
          for (let f in n)
            (!e || (!P.hasOwn(e, f) && !0)) && (delete n[f], (l = !0))
      }
      l && ue.trigger(t.attrs, 'set', '')
    }
    function UT(t, e, s, i) {
      let [r, n] = t.propsOptions,
        a = !1,
        o
      if (e)
        for (let u in e) {
          if (P.isReservedProp(u)) continue
          let l = e[u],
            c
          r && P.hasOwn(r, (c = P.camelize(u)))
            ? !n || !n.includes(c)
              ? (s[c] = l)
              : ((o || (o = {}))[c] = l)
            : Yc(t.emitsOptions, u) ||
              ((!(u in i) || l !== i[u]) && ((i[u] = l), (a = !0)))
        }
      if (n) {
        let u = ue.toRaw(s),
          l = o || P.EMPTY_OBJ
        for (let c = 0; c < n.length; c++) {
          let f = n[c]
          s[f] = C0(r, u, f, l[f], t, !P.hasOwn(l, f))
        }
      }
      return a
    }
    function C0(t, e, s, i, r, n) {
      let a = t[s]
      if (a != null) {
        let o = P.hasOwn(a, 'default')
        if (o && i === void 0) {
          let u = a.default
          if (a.type !== Function && !a.skipFactory && P.isFunction(u)) {
            let { propsDefaults: l } = r
            if (s in l) i = l[s]
            else {
              let c = yn(r)
              ;(i = l[s] = u.call(null, e)), c()
            }
          } else i = u
        }
        a[0] &&
          (n && !o
            ? (i = !1)
            : a[1] && (i === '' || i === P.hyphenate(s)) && (i = !0))
      }
      return i
    }
    var UM = new WeakMap()
    function HT(t, e, s = !1) {
      let i = s ? UM : e.propsCache,
        r = i.get(t)
      if (r) return r
      let n = t.props,
        a = {},
        o = [],
        u = !1
      if (!P.isFunction(t)) {
        let c = (f) => {
          u = !0
          let [h, p] = HT(f, e, !0)
          P.extend(a, h), p && o.push(...p)
        }
        !s && e.mixins.length && e.mixins.forEach(c),
          t.extends && c(t.extends),
          t.mixins && t.mixins.forEach(c)
      }
      if (!n && !u) return P.isObject(t) && i.set(t, P.EMPTY_ARR), P.EMPTY_ARR
      if (P.isArray(n))
        for (let c = 0; c < n.length; c++) {
          let f = P.camelize(n[c])
          $T(f) && (a[f] = P.EMPTY_OBJ)
        }
      else if (n)
        for (let c in n) {
          let f = P.camelize(c)
          if ($T(f)) {
            let h = n[c],
              p = (a[f] =
                P.isArray(h) || P.isFunction(h) ? { type: h } : P.extend({}, h))
            if (p) {
              let m = KT(Boolean, p.type),
                y = KT(String, p.type)
              ;(p[0] = m > -1),
                (p[1] = y < 0 || m < y),
                (m > -1 || P.hasOwn(p, 'default')) && o.push(f)
            }
          }
        }
      let l = [a, o]
      return P.isObject(t) && i.set(t, l), l
    }
    function $T(t) {
      return t[0] !== '$' && !P.isReservedProp(t)
    }
    function jT(t) {
      return t === null
        ? 'null'
        : typeof t == 'function'
        ? t.name || ''
        : (typeof t == 'object' && t.constructor && t.constructor.name) || ''
    }
    function qT(t, e) {
      return jT(t) === jT(e)
    }
    function KT(t, e) {
      return P.isArray(e)
        ? e.findIndex((s) => qT(s, t))
        : P.isFunction(e) && qT(e, t)
        ? 0
        : -1
    }
    var XT = (t) => t[0] === '_' || t === '$stable',
      v0 = (t) => (P.isArray(t) ? t.map(os) : [os(t)]),
      HM = (t, e, s) => {
        if (e._n) return e
        let i = f0((...r) => v0(e(...r)), s)
        return (i._c = !1), i
      },
      GT = (t, e, s) => {
        let i = t._ctx
        for (let r in t) {
          if (XT(r)) continue
          let n = t[r]
          if (P.isFunction(n)) e[r] = HM(r, n, i)
          else if (n != null) {
            let a = v0(n)
            e[r] = () => a
          }
        }
      },
      WT = (t, e) => {
        let s = v0(e)
        t.slots.default = () => s
      },
      zT = (t, e, s) => {
        for (let i in e) (s || i !== '_') && (t[i] = e[i])
      },
      $M = (t, e, s) => {
        let i = (t.slots = BT())
        if (t.vnode.shapeFlag & 32) {
          let r = e._
          r ? (zT(i, e, s), s && P.def(i, '_', r, !0)) : GT(e, i)
        } else e && WT(t, e)
      },
      jM = (t, e, s) => {
        let { vnode: i, slots: r } = t,
          n = !0,
          a = P.EMPTY_OBJ
        if (i.shapeFlag & 32) {
          let o = e._
          o
            ? s && o === 1
              ? (n = !1)
              : zT(r, e, s)
            : ((n = !e.$stable), GT(e, r)),
            (a = e)
        } else e && (WT(t, e), (a = { default: 1 }))
        if (n) for (let o in r) !XT(o) && a[o] == null && delete r[o]
      }
    function Kc(t, e, s, i, r = !1) {
      if (P.isArray(t)) {
        t.forEach((h, p) => Kc(h, e && (P.isArray(e) ? e[p] : e), s, i, r))
        return
      }
      if (dn(i) && !r) return
      let n = i.shapeFlag & 4 ? Go(i.component) : i.el,
        a = r ? null : n,
        { i: o, r: u } = t,
        l = e && e.r,
        c = o.refs === P.EMPTY_OBJ ? (o.refs = {}) : o.refs,
        f = o.setupState
      if (
        (l != null &&
          l !== u &&
          (P.isString(l)
            ? ((c[l] = null), P.hasOwn(f, l) && (f[l] = null))
            : ue.isRef(l) && (l.value = null)),
        P.isFunction(u))
      )
        Mi(u, o, 12, [a, c])
      else {
        let h = P.isString(u),
          p = ue.isRef(u)
        if (h || p) {
          let m = () => {
            if (t.f) {
              let y = h ? (P.hasOwn(f, u) ? f[u] : c[u]) : u.value
              r
                ? P.isArray(y) && P.remove(y, n)
                : P.isArray(y)
                ? y.includes(n) || y.push(n)
                : h
                ? ((c[u] = [n]), P.hasOwn(f, u) && (f[u] = c[u]))
                : ((u.value = [n]), t.k && (c[t.k] = u.value))
            } else
              h
                ? ((c[u] = a), P.hasOwn(f, u) && (f[u] = a))
                : p && ((u.value = a), t.k && (c[t.k] = a))
          }
          a ? ((m.id = -1), It(m, s)) : m()
        }
      }
    }
    var JT = Symbol('_vte'),
      qM = (t) => t.__isTeleport,
      Ho = (t) => t && (t.disabled || t.disabled === ''),
      YT = (t) => typeof SVGElement != 'undefined' && t instanceof SVGElement,
      QT = (t) =>
        typeof MathMLElement == 'function' && t instanceof MathMLElement,
      N0 = (t, e) => {
        let s = t && t.to
        return P.isString(s) ? (e ? e(s) : null) : s
      },
      KM = {
        name: 'Teleport',
        __isTeleport: !0,
        process(t, e, s, i, r, n, a, o, u, l) {
          let {
              mc: c,
              pc: f,
              pbc: h,
              o: {
                insert: p,
                querySelector: m,
                createText: y,
                createComment: x,
              },
            } = l,
            C = Ho(e.props),
            { shapeFlag: E, children: g, dynamicChildren: S } = e
          if (t == null) {
            let _ = (e.el = y('')),
              I = (e.anchor = y('')),
              k = (e.target = N0(e.props, m)),
              L = (e.targetStart = y('')),
              N = (e.targetAnchor = y(''))
            p(_, s, i),
              p(I, s, i),
              (L[JT] = N),
              k &&
                (p(L, k),
                p(N, k),
                a === 'svg' || YT(k)
                  ? (a = 'svg')
                  : (a === 'mathml' || QT(k)) && (a = 'mathml'))
            let O = (v, A) => {
              E & 16 && c(g, v, A, r, n, a, o, u)
            }
            C ? O(s, I) : k && O(k, N)
          } else {
            ;(e.el = t.el), (e.targetStart = t.targetStart)
            let _ = (e.anchor = t.anchor),
              I = (e.target = t.target),
              k = (e.targetAnchor = t.targetAnchor),
              L = Ho(t.props),
              N = L ? s : I,
              O = L ? _ : k
            if (
              (a === 'svg' || YT(I)
                ? (a = 'svg')
                : (a === 'mathml' || QT(I)) && (a = 'mathml'),
              S
                ? (h(t.dynamicChildren, S, N, r, n, a, o), O0(t, e, !0))
                : u || f(t, e, N, O, r, n, a, o, !1),
              C)
            )
              L
                ? e.props &&
                  t.props &&
                  e.props.to !== t.props.to &&
                  (e.props.to = t.props.to)
                : Xc(e, s, _, l, 1)
            else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
              let v = (e.target = N0(e.props, m))
              v && Xc(e, v, null, l, 0)
            } else L && Xc(e, I, k, l, 1)
          }
          ZT(e)
        },
        remove(t, e, s, { um: i, o: { remove: r } }, n) {
          let {
            shapeFlag: a,
            children: o,
            anchor: u,
            targetStart: l,
            targetAnchor: c,
            target: f,
            props: h,
          } = t
          if ((f && (r(l), r(c)), n && r(u), a & 16)) {
            let p = n || !Ho(h)
            for (let m = 0; m < o.length; m++) {
              let y = o[m]
              i(y, e, s, p, !!y.dynamicChildren)
            }
          }
        },
        move: Xc,
        hydrate: XM,
      }
    function Xc(t, e, s, { o: { insert: i }, m: r }, n = 2) {
      n === 0 && i(t.targetAnchor, e, s)
      let { el: a, anchor: o, shapeFlag: u, children: l, props: c } = t,
        f = n === 2
      if ((f && i(a, e, s), (!f || Ho(c)) && u & 16))
        for (let h = 0; h < l.length; h++) r(l[h], e, s, 2)
      f && i(o, e, s)
    }
    function XM(
      t,
      e,
      s,
      i,
      r,
      n,
      { o: { nextSibling: a, parentNode: o, querySelector: u } },
      l
    ) {
      let c = (e.target = N0(e.props, u))
      if (c) {
        let f = c._lpa || c.firstChild
        if (e.shapeFlag & 16)
          if (Ho(e.props))
            (e.anchor = l(a(t), e, o(t), s, i, r, n)), (e.targetAnchor = f)
          else {
            e.anchor = a(t)
            let h = f
            for (; h; )
              if (
                ((h = a(h)),
                h && h.nodeType === 8 && h.data === 'teleport anchor')
              ) {
                ;(e.targetAnchor = h),
                  (c._lpa = e.targetAnchor && a(e.targetAnchor))
                break
              }
            l(f, e, c, s, i, r, n)
          }
        ZT(e)
      }
      return e.anchor && a(e.anchor)
    }
    var GM = KM
    function ZT(t) {
      let e = t.ctx
      if (e && e.ut) {
        let s = t.children[0].el
        for (; s && s !== t.targetAnchor; )
          s.nodeType === 1 && s.setAttribute('data-v-owner', e.uid),
            (s = s.nextSibling)
        e.ut()
      }
    }
    var e2 = !1,
      pa = () => {
        e2 ||
          (console.error('Hydration completed but contains mismatches.'),
          (e2 = !0))
      },
      WM = (t) =>
        t.namespaceURI.includes('svg') && t.tagName !== 'foreignObject',
      zM = (t) => t.namespaceURI.includes('MathML'),
      Gc = (t) => {
        if (WM(t)) return 'svg'
        if (zM(t)) return 'mathml'
      },
      Wc = (t) => t.nodeType === 8
    function JM(t) {
      let {
          mt: e,
          p: s,
          o: {
            patchProp: i,
            createText: r,
            nextSibling: n,
            parentNode: a,
            remove: o,
            insert: u,
            createComment: l,
          },
        } = t,
        c = (g, S) => {
          if (!S.hasChildNodes()) {
            s(null, g, S), Dc(), (S._vnode = g)
            return
          }
          f(S.firstChild, g, null, null, null), Dc(), (S._vnode = g)
        },
        f = (g, S, _, I, k, L = !1) => {
          L = L || !!S.dynamicChildren
          let N = Wc(g) && g.data === '[',
            O = () => y(g, S, _, I, k, N),
            { type: v, ref: A, shapeFlag: V, patchFlag: se } = S,
            Y = g.nodeType
          ;(S.el = g), se === -2 && ((L = !1), (S.dynamicChildren = null))
          let q = null
          switch (v) {
            case Er:
              Y !== 3
                ? S.children === ''
                  ? (u((S.el = r('')), a(g), g), (q = g))
                  : (q = O())
                : (g.data !== S.children && (pa(), (g.data = S.children)),
                  (q = n(g)))
              break
            case Ot:
              E(g)
                ? ((q = n(g)), C((S.el = g.content.firstChild), g, _))
                : Y !== 8 || N
                ? (q = O())
                : (q = n(g))
              break
            case ma:
              if ((N && ((g = n(g)), (Y = g.nodeType)), Y === 1 || Y === 3)) {
                q = g
                let ee = !S.children.length
                for (let z = 0; z < S.staticCount; z++)
                  ee && (S.children += q.nodeType === 1 ? q.outerHTML : q.data),
                    z === S.staticCount - 1 && (S.anchor = q),
                    (q = n(q))
                return N ? n(q) : q
              } else O()
              break
            case es:
              N ? (q = m(g, S, _, I, k, L)) : (q = O())
              break
            default:
              if (V & 1)
                (Y !== 1 || S.type.toLowerCase() !== g.tagName.toLowerCase()) &&
                !E(g)
                  ? (q = O())
                  : (q = h(g, S, _, I, k, L))
              else if (V & 6) {
                S.slotScopeIds = k
                let ee = a(g)
                if (
                  (N
                    ? (q = x(g))
                    : Wc(g) && g.data === 'teleport start'
                    ? (q = x(g, g.data, 'teleport end'))
                    : (q = n(g)),
                  e(S, ee, null, _, I, Gc(ee), L),
                  dn(S))
                ) {
                  let z
                  N
                    ? ((z = ot(es)),
                      (z.anchor = q ? q.previousSibling : ee.lastChild))
                    : (z = g.nodeType === 3 ? F0('') : ot('div')),
                    (z.el = g),
                    (S.component.subTree = z)
                }
              } else
                V & 64
                  ? Y !== 8
                    ? (q = O())
                    : (q = S.type.hydrate(g, S, _, I, k, L, t, p))
                  : V & 128 &&
                    (q = S.type.hydrate(g, S, _, I, Gc(a(g)), k, L, t, f))
          }
          return A != null && Kc(A, null, I, S), q
        },
        h = (g, S, _, I, k, L) => {
          L = L || !!S.dynamicChildren
          let {
              type: N,
              props: O,
              patchFlag: v,
              shapeFlag: A,
              dirs: V,
              transition: se,
            } = S,
            Y = N === 'input' || N === 'option'
          if (Y || v !== -1) {
            V && ni(S, null, _, 'created')
            let q = !1
            if (E(g)) {
              q = s2(I, se) && _ && _.vnode.props && _.vnode.props.appear
              let z = g.content.firstChild
              q && se.beforeEnter(z), C(z, g, _), (S.el = g = z)
            }
            if (A & 16 && !(O && (O.innerHTML || O.textContent))) {
              let z = p(g.firstChild, S, g, _, I, k, L)
              for (; z; ) {
                pa()
                let He = z
                ;(z = z.nextSibling), o(He)
              }
            } else
              A & 8 &&
                g.textContent !== S.children &&
                (pa(), (g.textContent = S.children))
            if (O) {
              if (Y || !L || v & (16 | 32))
                for (let z in O)
                  ((Y && (z.endsWith('value') || z === 'indeterminate')) ||
                    (P.isOn(z) && !P.isReservedProp(z)) ||
                    z[0] === '.') &&
                    i(g, z, null, O[z], void 0, _)
              else if (O.onClick) i(g, 'onClick', null, O.onClick, void 0, _)
              else if (v & 4 && ue.isReactive(O.style))
                for (let z in O.style) O.style[z]
            }
            let ee
            ;(ee = O && O.onVnodeBeforeMount) && us(ee, _, S),
              V && ni(S, null, _, 'beforeMount'),
              ((ee = O && O.onVnodeMounted) || V || q) &&
                p2(() => {
                  ee && us(ee, _, S),
                    q && se.enter(g),
                    V && ni(S, null, _, 'mounted')
                }, I)
          }
          return g.nextSibling
        },
        p = (g, S, _, I, k, L, N) => {
          N = N || !!S.dynamicChildren
          let O = S.children,
            v = O.length
          for (let A = 0; A < v; A++) {
            let V = N ? O[A] : (O[A] = os(O[A])),
              se = V.type === Er
            if (g) {
              if (se && !N) {
                let Y = O[A + 1]
                Y &&
                  (Y = os(Y)).type === Er &&
                  (u(r(g.data.slice(V.children.length)), _, n(g)),
                  (g.data = V.children))
              }
              g = f(g, V, I, k, L, N)
            } else
              se && !V.children
                ? u((V.el = r('')), _)
                : (pa(), s(null, V, _, null, I, k, Gc(_), L))
          }
          return g
        },
        m = (g, S, _, I, k, L) => {
          let { slotScopeIds: N } = S
          N && (k = k ? k.concat(N) : N)
          let O = a(g),
            v = p(n(g), S, O, _, I, k, L)
          return v && Wc(v) && v.data === ']'
            ? n((S.anchor = v))
            : (pa(), u((S.anchor = l(']')), O, v), v)
        },
        y = (g, S, _, I, k, L) => {
          if ((pa(), (S.el = null), L)) {
            let v = x(g)
            for (;;) {
              let A = n(g)
              if (A && A !== v) o(A)
              else break
            }
          }
          let N = n(g),
            O = a(g)
          return o(g), s(null, S, O, N, _, I, Gc(O), k), N
        },
        x = (g, S = '[', _ = ']') => {
          let I = 0
          for (; g; )
            if (
              ((g = n(g)), g && Wc(g) && (g.data === S && I++, g.data === _))
            ) {
              if (I === 0) return n(g)
              I--
            }
          return g
        },
        C = (g, S, _) => {
          let I = S.parentNode
          I && I.replaceChild(g, S)
          let k = _
          for (; k; )
            k.vnode.el === S && (k.vnode.el = k.subTree.el = g), (k = k.parent)
        },
        E = (g) => g.nodeType === 1 && g.tagName.toLowerCase() === 'template'
      return [c, f]
    }
    var It = p2
    function YM(t) {
      return t2(t)
    }
    function QM(t) {
      return t2(t, JM)
    }
    function t2(t, e) {
      let s = P.getGlobalThis()
      s.__VUE__ = !0
      let {
          insert: i,
          remove: r,
          patchProp: n,
          createElement: a,
          createText: o,
          createComment: u,
          setText: l,
          setElementText: c,
          parentNode: f,
          nextSibling: h,
          setScopeId: p = P.NOOP,
          insertStaticContent: m,
        } = t,
        y = (
          w,
          d,
          T,
          M = null,
          D = null,
          F = null,
          U = void 0,
          j = null,
          $ = !!d.dynamicChildren
        ) => {
          if (w === d) return
          w && !Ks(w, d) && ((M = Ws(w)), rt(w, D, F, !0), (w = null)),
            d.patchFlag === -2 && (($ = !1), (d.dynamicChildren = null))
          let { type: B, ref: H, shapeFlag: J } = d
          switch (B) {
            case Er:
              x(w, d, T, M)
              break
            case Ot:
              C(w, d, T, M)
              break
            case ma:
              w == null && E(d, T, M, U)
              break
            case es:
              A(w, d, T, M, D, F, U, j, $)
              break
            default:
              J & 1
                ? _(w, d, T, M, D, F, U, j, $)
                : J & 6
                ? V(w, d, T, M, D, F, U, j, $)
                : (J & 64 || J & 128) &&
                  B.process(w, d, T, M, D, F, U, j, $, ci)
          }
          H != null && D && Kc(H, w && w.ref, F, d || w, !d)
        },
        x = (w, d, T, M) => {
          if (w == null) i((d.el = o(d.children)), T, M)
          else {
            let D = (d.el = w.el)
            d.children !== w.children && l(D, d.children)
          }
        },
        C = (w, d, T, M) => {
          w == null ? i((d.el = u(d.children || '')), T, M) : (d.el = w.el)
        },
        E = (w, d, T, M) => {
          ;[w.el, w.anchor] = m(w.children, d, T, M, w.el, w.anchor)
        },
        g = ({ el: w, anchor: d }, T, M) => {
          let D
          for (; w && w !== d; ) (D = h(w)), i(w, T, M), (w = D)
          i(d, T, M)
        },
        S = ({ el: w, anchor: d }) => {
          let T
          for (; w && w !== d; ) (T = h(w)), r(w), (w = T)
          r(d)
        },
        _ = (w, d, T, M, D, F, U, j, $) => {
          d.type === 'svg' ? (U = 'svg') : d.type === 'math' && (U = 'mathml'),
            w == null ? I(d, T, M, D, F, U, j, $) : N(w, d, D, F, U, j, $)
        },
        I = (w, d, T, M, D, F, U, j) => {
          let $,
            B,
            { props: H, shapeFlag: J, transition: Q, dirs: ie } = w
          if (
            (($ = w.el = a(w.type, F, H && H.is, H)),
            J & 8
              ? c($, w.children)
              : J & 16 && L(w.children, $, null, M, D, I0(w, F), U, j),
            ie && ni(w, null, M, 'created'),
            k($, w, w.scopeId, U, M),
            H)
          ) {
            for (let de in H)
              de !== 'value' &&
                !P.isReservedProp(de) &&
                n($, de, null, H[de], F, M)
            'value' in H && n($, 'value', null, H.value, F),
              (B = H.onVnodeBeforeMount) && us(B, M, w)
          }
          ie && ni(w, null, M, 'beforeMount')
          let ne = s2(D, Q)
          ne && Q.beforeEnter($),
            i($, d, T),
            ((B = H && H.onVnodeMounted) || ne || ie) &&
              It(() => {
                B && us(B, M, w),
                  ne && Q.enter($),
                  ie && ni(w, null, M, 'mounted')
              }, D)
        },
        k = (w, d, T, M, D) => {
          if ((T && p(w, T), M)) for (let F = 0; F < M.length; F++) p(w, M[F])
          if (D) {
            let F = D.subTree
            if (d === F) {
              let U = D.vnode
              k(w, U, U.scopeId, U.slotScopeIds, D.parent)
            }
          }
        },
        L = (w, d, T, M, D, F, U, j, $ = 0) => {
          for (let B = $; B < w.length; B++) {
            let H = (w[B] = j ? Tr(w[B]) : os(w[B]))
            y(null, H, d, T, M, D, F, U, j)
          }
        },
        N = (w, d, T, M, D, F, U) => {
          let j = (d.el = w.el),
            { patchFlag: $, dynamicChildren: B, dirs: H } = d
          $ |= w.patchFlag & 16
          let J = w.props || P.EMPTY_OBJ,
            Q = d.props || P.EMPTY_OBJ,
            ie
          if (
            (T && mn(T, !1),
            (ie = Q.onVnodeBeforeUpdate) && us(ie, T, d, w),
            H && ni(d, w, T, 'beforeUpdate'),
            T && mn(T, !0),
            ((J.innerHTML && Q.innerHTML == null) ||
              (J.textContent && Q.textContent == null)) &&
              c(j, ''),
            B
              ? O(w.dynamicChildren, B, j, T, M, I0(d, D), F)
              : U || z(w, d, j, null, T, M, I0(d, D), F, !1),
            $ > 0)
          ) {
            if ($ & 16) v(j, J, Q, T, D)
            else if (
              ($ & 2 && J.class !== Q.class && n(j, 'class', null, Q.class, D),
              $ & 4 && n(j, 'style', J.style, Q.style, D),
              $ & 8)
            ) {
              let ne = d.dynamicProps
              for (let de = 0; de < ne.length; de++) {
                let ye = ne[de],
                  Ee = J[ye],
                  $e = Q[ye]
                ;($e !== Ee || ye === 'value') && n(j, ye, Ee, $e, D, T)
              }
            }
            $ & 1 && w.children !== d.children && c(j, d.children)
          } else !U && B == null && v(j, J, Q, T, D)
          ;((ie = Q.onVnodeUpdated) || H) &&
            It(() => {
              ie && us(ie, T, d, w), H && ni(d, w, T, 'updated')
            }, M)
        },
        O = (w, d, T, M, D, F, U) => {
          for (let j = 0; j < d.length; j++) {
            let $ = w[j],
              B = d[j],
              H =
                $.el && ($.type === es || !Ks($, B) || $.shapeFlag & (6 | 64))
                  ? f($.el)
                  : T
            y($, B, H, null, M, D, F, U, !0)
          }
        },
        v = (w, d, T, M, D) => {
          if (d !== T) {
            if (d !== P.EMPTY_OBJ)
              for (let F in d)
                !P.isReservedProp(F) && !(F in T) && n(w, F, d[F], null, D, M)
            for (let F in T) {
              if (P.isReservedProp(F)) continue
              let U = T[F],
                j = d[F]
              U !== j && F !== 'value' && n(w, F, j, U, D, M)
            }
            'value' in T && n(w, 'value', d.value, T.value, D)
          }
        },
        A = (w, d, T, M, D, F, U, j, $) => {
          let B = (d.el = w ? w.el : o('')),
            H = (d.anchor = w ? w.anchor : o('')),
            { patchFlag: J, dynamicChildren: Q, slotScopeIds: ie } = d
          ie && (j = j ? j.concat(ie) : ie),
            w == null
              ? (i(B, T, M),
                i(H, T, M),
                L(d.children || [], T, H, D, F, U, j, $))
              : J > 0 && J & 64 && Q && w.dynamicChildren
              ? (O(w.dynamicChildren, Q, T, D, F, U, j),
                (d.key != null || (D && d === D.subTree)) && O0(w, d, !0))
              : z(w, d, T, H, D, F, U, j, $)
        },
        V = (w, d, T, M, D, F, U, j, $) => {
          ;(d.slotScopeIds = j),
            w == null
              ? d.shapeFlag & 512
                ? D.ctx.activate(d, T, M, U, $)
                : se(d, T, M, D, F, U, $)
              : Y(w, d, $)
        },
        se = (w, d, T, M, D, F, U) => {
          let j = (w.component = E2(w, M, D))
          if ((ko(w) && (j.ctx.renderer = ci), T2(j, !1, U), j.asyncDep)) {
            if ((D && D.registerDep(j, q, U), !w.el)) {
              let $ = (j.subTree = ot(Ot))
              C(null, $, d, T)
            }
          } else q(j, w, d, T, D, F, U)
        },
        Y = (w, d, T) => {
          let M = (d.component = w.component)
          if (u8(w, d, T))
            if (M.asyncDep && !M.asyncResolved) {
              ee(M, d, T)
              return
            } else (M.next = d), J4(M.update), (M.effect.dirty = !0), M.update()
          else (d.el = w.el), (M.vnode = d)
        },
        q = (w, d, T, M, D, F, U) => {
          let j = () => {
              if (w.isMounted) {
                let { next: H, bu: J, u: Q, parent: ie, vnode: ne } = w
                {
                  let Pt = i2(w)
                  if (Pt) {
                    H && ((H.el = ne.el), ee(w, H, U)),
                      Pt.asyncDep.then(() => {
                        w.isUnmounted || j()
                      })
                    return
                  }
                }
                let de = H,
                  ye
                mn(w, !1),
                  H ? ((H.el = ne.el), ee(w, H, U)) : (H = ne),
                  J && P.invokeArrayFns(J),
                  (ye = H.props && H.props.onVnodeBeforeUpdate) &&
                    us(ye, ie, H, ne),
                  mn(w, !0)
                let Ee = Qc(w),
                  $e = w.subTree
                ;(w.subTree = Ee),
                  y($e, Ee, f($e.el), Ws($e), w, D, F),
                  (H.el = Ee.el),
                  de === null && w0(w, Ee.el),
                  Q && It(Q, D),
                  (ye = H.props && H.props.onVnodeUpdated) &&
                    It(() => us(ye, ie, H, ne), D)
              } else {
                let H,
                  { el: J, props: Q } = d,
                  { bm: ie, m: ne, parent: de } = w,
                  ye = dn(d)
                if (
                  (mn(w, !1),
                  ie && P.invokeArrayFns(ie),
                  !ye && (H = Q && Q.onVnodeBeforeMount) && us(H, de, d),
                  mn(w, !0),
                  J && Dr)
                ) {
                  let Ee = () => {
                    ;(w.subTree = Qc(w)), Dr(J, w.subTree, w, D, null)
                  }
                  ye
                    ? d.type.__asyncLoader().then(() => !w.isUnmounted && Ee())
                    : Ee()
                } else {
                  let Ee = (w.subTree = Qc(w))
                  y(null, Ee, T, M, w, D, F), (d.el = Ee.el)
                }
                if ((ne && It(ne, D), !ye && (H = Q && Q.onVnodeMounted))) {
                  let Ee = d
                  It(() => us(H, de, Ee), D)
                }
                ;(d.shapeFlag & 256 ||
                  (de && dn(de.vnode) && de.vnode.shapeFlag & 256)) &&
                  w.a &&
                  It(w.a, D),
                  (w.isMounted = !0),
                  (d = T = M = null)
              }
            },
            $ = (w.effect = new ue.ReactiveEffect(
              j,
              P.NOOP,
              () => Lc(B),
              w.scope
            )),
            B = (w.update = () => {
              $.dirty && $.run()
            })
          ;(B.i = w), (B.id = w.uid), mn(w, !0), B()
        },
        ee = (w, d, T) => {
          d.component = w
          let M = w.vnode.props
          ;(w.vnode = d),
            (w.next = null),
            VM(w, d.props, M, T),
            jM(w, d.children, T),
            ue.pauseTracking(),
            cT(w),
            ue.resetTracking()
        },
        z = (w, d, T, M, D, F, U, j, $ = !1) => {
          let B = w && w.children,
            H = w ? w.shapeFlag : 0,
            J = d.children,
            { patchFlag: Q, shapeFlag: ie } = d
          if (Q > 0) {
            if (Q & 128) {
              St(B, J, T, M, D, F, U, j, $)
              return
            } else if (Q & 256) {
              He(B, J, T, M, D, F, U, j, $)
              return
            }
          }
          ie & 8
            ? (H & 16 && kr(B, D, F), J !== B && c(T, J))
            : H & 16
            ? ie & 16
              ? St(B, J, T, M, D, F, U, j, $)
              : kr(B, D, F, !0)
            : (H & 8 && c(T, ''), ie & 16 && L(J, T, M, D, F, U, j, $))
        },
        He = (w, d, T, M, D, F, U, j, $) => {
          ;(w = w || P.EMPTY_ARR), (d = d || P.EMPTY_ARR)
          let B = w.length,
            H = d.length,
            J = Math.min(B, H),
            Q
          for (Q = 0; Q < J; Q++) {
            let ie = (d[Q] = $ ? Tr(d[Q]) : os(d[Q]))
            y(w[Q], ie, T, null, D, F, U, j, $)
          }
          B > H ? kr(w, D, F, !0, !1, J) : L(d, T, M, D, F, U, j, $, J)
        },
        St = (w, d, T, M, D, F, U, j, $) => {
          let B = 0,
            H = d.length,
            J = w.length - 1,
            Q = H - 1
          for (; B <= J && B <= Q; ) {
            let ie = w[B],
              ne = (d[B] = $ ? Tr(d[B]) : os(d[B]))
            if (Ks(ie, ne)) y(ie, ne, T, null, D, F, U, j, $)
            else break
            B++
          }
          for (; B <= J && B <= Q; ) {
            let ie = w[J],
              ne = (d[Q] = $ ? Tr(d[Q]) : os(d[Q]))
            if (Ks(ie, ne)) y(ie, ne, T, null, D, F, U, j, $)
            else break
            J--, Q--
          }
          if (B > J) {
            if (B <= Q) {
              let ie = Q + 1,
                ne = ie < H ? d[ie].el : M
              for (; B <= Q; )
                y(null, (d[B] = $ ? Tr(d[B]) : os(d[B])), T, ne, D, F, U, j, $),
                  B++
            }
          } else if (B > Q) for (; B <= J; ) rt(w[B], D, F, !0), B++
          else {
            let ie = B,
              ne = B,
              de = new Map()
            for (B = ne; B <= Q; B++) {
              let Ut = (d[B] = $ ? Tr(d[B]) : os(d[B]))
              Ut.key != null && de.set(Ut.key, B)
            }
            let ye,
              Ee = 0,
              $e = Q - ne + 1,
              Pt = !1,
              fi = 0,
              Gi = new Array($e)
            for (B = 0; B < $e; B++) Gi[B] = 0
            for (B = ie; B <= J; B++) {
              let Ut = w[B]
              if (Ee >= $e) {
                rt(Ut, D, F, !0)
                continue
              }
              let We
              if (Ut.key != null) We = de.get(Ut.key)
              else
                for (ye = ne; ye <= Q; ye++)
                  if (Gi[ye - ne] === 0 && Ks(Ut, d[ye])) {
                    We = ye
                    break
                  }
              We === void 0
                ? rt(Ut, D, F, !0)
                : ((Gi[We - ne] = B + 1),
                  We >= fi ? (fi = We) : (Pt = !0),
                  y(Ut, d[We], T, null, D, F, U, j, $),
                  Ee++)
            }
            let Wi = Pt ? ZM(Gi) : P.EMPTY_ARR
            for (ye = Wi.length - 1, B = $e - 1; B >= 0; B--) {
              let Ut = ne + B,
                We = d[Ut],
                cs = Ut + 1 < H ? d[Ut + 1].el : M
              Gi[B] === 0
                ? y(null, We, T, cs, D, F, U, j, $)
                : Pt && (ye < 0 || B !== Wi[ye] ? Ze(We, T, cs, 2) : ye--)
            }
          }
        },
        Ze = (w, d, T, M, D = null) => {
          let { el: F, type: U, transition: j, children: $, shapeFlag: B } = w
          if (B & 6) {
            Ze(w.component.subTree, d, T, M)
            return
          }
          if (B & 128) {
            w.suspense.move(d, T, M)
            return
          }
          if (B & 64) {
            U.move(w, d, T, ci)
            return
          }
          if (U === es) {
            i(F, d, T)
            for (let J = 0; J < $.length; J++) Ze($[J], d, T, M)
            i(w.anchor, d, T)
            return
          }
          if (U === ma) {
            g(w, d, T)
            return
          }
          if (M !== 2 && B & 1 && j)
            if (M === 0) j.beforeEnter(F), i(F, d, T), It(() => j.enter(F), D)
            else {
              let { leave: J, delayLeave: Q, afterLeave: ie } = j,
                ne = () => i(F, d, T),
                de = () => {
                  J(F, () => {
                    ne(), ie && ie()
                  })
                }
              Q ? Q(F, ne, de) : de()
            }
          else i(F, d, T)
        },
        rt = (w, d, T, M = !1, D = !1) => {
          let {
            type: F,
            props: U,
            ref: j,
            children: $,
            dynamicChildren: B,
            shapeFlag: H,
            patchFlag: J,
            dirs: Q,
            cacheIndex: ie,
          } = w
          if (
            (J === -2 && (D = !1),
            j != null && Kc(j, null, T, w, !0),
            ie != null && (d.renderCache[ie] = void 0),
            H & 256)
          ) {
            d.ctx.deactivate(w)
            return
          }
          let ne = H & 1 && Q,
            de = !dn(w),
            ye
          if ((de && (ye = U && U.onVnodeBeforeUnmount) && us(ye, d, w), H & 6))
            qf(w.component, T, M)
          else {
            if (H & 128) {
              w.suspense.unmount(T, M)
              return
            }
            ne && ni(w, null, d, 'beforeUnmount'),
              H & 64
                ? w.type.remove(w, d, T, ci, M)
                : B && !B.hasOnce && (F !== es || (J > 0 && J & 64))
                ? kr(B, d, T, !1, !0)
                : ((F === es && J & (128 | 256)) || (!D && H & 16)) &&
                  kr($, d, T),
              M && Us(w)
          }
          ;((de && (ye = U && U.onVnodeUnmounted)) || ne) &&
            It(() => {
              ye && us(ye, d, w), ne && ni(w, null, d, 'unmounted')
            }, T)
        },
        Us = (w) => {
          let { type: d, el: T, anchor: M, transition: D } = w
          if (d === es) {
            Na(T, M)
            return
          }
          if (d === ma) {
            S(w)
            return
          }
          let F = () => {
            r(T), D && !D.persisted && D.afterLeave && D.afterLeave()
          }
          if (w.shapeFlag & 1 && D && !D.persisted) {
            let { leave: U, delayLeave: j } = D,
              $ = () => U(T, F)
            j ? j(w.el, F, $) : $()
          } else F()
        },
        Na = (w, d) => {
          let T
          for (; w !== d; ) (T = h(w)), r(w), (w = T)
          r(d)
        },
        qf = (w, d, T) => {
          let { bum: M, scope: D, update: F, subTree: U, um: j, m: $, a: B } = w
          zc($),
            zc(B),
            M && P.invokeArrayFns(M),
            D.stop(),
            F && ((F.active = !1), rt(U, w, d, T)),
            j && It(j, d),
            It(() => {
              w.isUnmounted = !0
            }, d),
            d &&
              d.pendingBranch &&
              !d.isUnmounted &&
              w.asyncDep &&
              !w.asyncResolved &&
              w.suspenseId === d.pendingId &&
              (d.deps--, d.deps === 0 && d.resolve())
        },
        kr = (w, d, T, M = !1, D = !1, F = 0) => {
          for (let U = F; U < w.length; U++) rt(w[U], d, T, M, D)
        },
        Ws = (w) => {
          if (w.shapeFlag & 6) return Ws(w.component.subTree)
          if (w.shapeFlag & 128) return w.suspense.next()
          let d = h(w.anchor || w.el),
            T = d && d[JT]
          return T ? h(T) : d
        },
        Xi = !1,
        kn = (w, d, T) => {
          w == null
            ? d._vnode && rt(d._vnode, null, null, !0)
            : y(d._vnode || null, w, d, null, null, null, T),
            Xi || ((Xi = !0), cT(), Dc(), (Xi = !1)),
            (d._vnode = w)
        },
        ci = {
          p: y,
          um: rt,
          m: Ze,
          r: Us,
          mt: se,
          mc: L,
          pc: z,
          pbc: O,
          n: Ws,
          o: t,
        },
        zs,
        Dr
      return (
        e && ([zs, Dr] = e(ci)),
        { render: kn, hydrate: zs, createApp: DM(kn, zs) }
      )
    }
    function I0({ type: t, props: e }, s) {
      return (s === 'svg' && t === 'foreignObject') ||
        (s === 'mathml' &&
          t === 'annotation-xml' &&
          e &&
          e.encoding &&
          e.encoding.includes('html'))
        ? void 0
        : s
    }
    function mn({ effect: t, update: e }, s) {
      t.allowRecurse = e.allowRecurse = s
    }
    function s2(t, e) {
      return (!t || (t && !t.pendingBranch)) && e && !e.persisted
    }
    function O0(t, e, s = !1) {
      let i = t.children,
        r = e.children
      if (P.isArray(i) && P.isArray(r))
        for (let n = 0; n < i.length; n++) {
          let a = i[n],
            o = r[n]
          o.shapeFlag & 1 &&
            !o.dynamicChildren &&
            ((o.patchFlag <= 0 || o.patchFlag === 32) &&
              ((o = r[n] = Tr(r[n])), (o.el = a.el)),
            !s && o.patchFlag !== -2 && O0(a, o)),
            o.type === Er && (o.el = a.el)
        }
    }
    function ZM(t) {
      let e = t.slice(),
        s = [0],
        i,
        r,
        n,
        a,
        o,
        u = t.length
      for (i = 0; i < u; i++) {
        let l = t[i]
        if (l !== 0) {
          if (((r = s[s.length - 1]), t[r] < l)) {
            ;(e[i] = r), s.push(i)
            continue
          }
          for (n = 0, a = s.length - 1; n < a; )
            (o = (n + a) >> 1), t[s[o]] < l ? (n = o + 1) : (a = o)
          l < t[s[n]] && (n > 0 && (e[i] = s[n - 1]), (s[n] = i))
        }
      }
      for (n = s.length, a = s[n - 1]; n-- > 0; ) (s[n] = a), (a = e[a])
      return s
    }
    function i2(t) {
      let e = t.subTree.component
      if (e) return e.asyncDep && !e.asyncResolved ? e : i2(e)
    }
    function zc(t) {
      if (t) for (let e = 0; e < t.length; e++) t[e].active = !1
    }
    var r2 = Symbol.for('v-scx'),
      n2 = () => Uo(r2)
    function e8(t, e) {
      return jo(t, null, e)
    }
    function t8(t, e) {
      return jo(t, null, { flush: 'post' })
    }
    function a2(t, e) {
      return jo(t, null, { flush: 'sync' })
    }
    var Jc = {}
    function $o(t, e, s) {
      return jo(t, e, s)
    }
    function jo(
      t,
      e,
      {
        immediate: s,
        deep: i,
        flush: r,
        once: n,
        onTrack: a,
        onTrigger: o,
      } = P.EMPTY_OBJ
    ) {
      if (e && n) {
        let I = e
        e = (...k) => {
          I(...k), _()
        }
      }
      let u = At,
        l = (I) => (i === !0 ? I : br(I, i === !1 ? 1 : void 0)),
        c,
        f = !1,
        h = !1
      if (
        (ue.isRef(t)
          ? ((c = () => t.value), (f = ue.isShallow(t)))
          : ue.isReactive(t)
          ? ((c = () => l(t)), (f = !0))
          : P.isArray(t)
          ? ((h = !0),
            (f = t.some((I) => ue.isReactive(I) || ue.isShallow(I))),
            (c = () =>
              t.map((I) => {
                if (ue.isRef(I)) return I.value
                if (ue.isReactive(I)) return l(I)
                if (P.isFunction(I)) return Mi(I, u, 2)
              })))
          : P.isFunction(t)
          ? e
            ? (c = () => Mi(t, u, 2))
            : (c = () => (p && p(), Rs(t, u, 3, [m])))
          : (c = P.NOOP),
        e && i)
      ) {
        let I = c
        c = () => br(I())
      }
      let p,
        m = (I) => {
          p = g.onStop = () => {
            Mi(I, u, 4), (p = g.onStop = void 0)
          }
        },
        y
      if (Xo)
        if (
          ((m = P.NOOP),
          e ? s && Rs(e, u, 3, [c(), h ? [] : void 0, m]) : c(),
          r === 'sync')
        ) {
          let I = n2()
          y = I.__watcherHandles || (I.__watcherHandles = [])
        } else return P.NOOP
      let x = h ? new Array(t.length).fill(Jc) : Jc,
        C = () => {
          if (!(!g.active || !g.dirty))
            if (e) {
              let I = g.run()
              ;(i ||
                f ||
                (h
                  ? I.some((k, L) => P.hasChanged(k, x[L]))
                  : P.hasChanged(I, x))) &&
                (p && p(),
                Rs(e, u, 3, [
                  I,
                  x === Jc ? void 0 : h && x[0] === Jc ? [] : x,
                  m,
                ]),
                (x = I))
            } else g.run()
        }
      C.allowRecurse = !!e
      let E
      r === 'sync'
        ? (E = C)
        : r === 'post'
        ? (E = () => It(C, u && u.suspense))
        : ((C.pre = !0), u && (C.id = u.uid), (E = () => Lc(C)))
      let g = new ue.ReactiveEffect(c, P.NOOP, E),
        S = ue.getCurrentScope(),
        _ = () => {
          g.stop(), S && P.remove(S.effects, g)
        }
      return (
        e
          ? s
            ? C()
            : (x = g.run())
          : r === 'post'
          ? It(g.run.bind(g), u && u.suspense)
          : g.run(),
        y && y.push(_),
        _
      )
    }
    function s8(t, e, s) {
      let i = this.proxy,
        r = P.isString(t)
          ? t.includes('.')
            ? o2(i, t)
            : () => i[t]
          : t.bind(i, i),
        n
      P.isFunction(e) ? (n = e) : ((n = e.handler), (s = e))
      let a = yn(this),
        o = jo(r, n.bind(i), s)
      return a(), o
    }
    function o2(t, e) {
      let s = e.split('.')
      return () => {
        let i = t
        for (let r = 0; r < s.length && i; r++) i = i[s[r]]
        return i
      }
    }
    function br(t, e = 1 / 0, s) {
      if (
        e <= 0 ||
        !P.isObject(t) ||
        t.__v_skip ||
        ((s = s || new Set()), s.has(t))
      )
        return t
      if ((s.add(t), e--, ue.isRef(t))) br(t.value, e, s)
      else if (P.isArray(t)) for (let i = 0; i < t.length; i++) br(t[i], e, s)
      else if (P.isSet(t) || P.isMap(t))
        t.forEach((i) => {
          br(i, e, s)
        })
      else if (P.isPlainObject(t)) {
        for (let i in t) br(t[i], e, s)
        for (let i of Object.getOwnPropertySymbols(t))
          Object.prototype.propertyIsEnumerable.call(t, i) && br(t[i], e, s)
      }
      return t
    }
    function i8(t, e, s = P.EMPTY_OBJ) {
      let i = ga(),
        r = P.camelize(e),
        n = P.hyphenate(e),
        a = u2(t, e),
        o = ue.customRef((u, l) => {
          let c,
            f = P.EMPTY_OBJ,
            h
          return (
            a2(() => {
              let p = t[e]
              P.hasChanged(c, p) && ((c = p), l())
            }),
            {
              get() {
                return u(), s.get ? s.get(c) : c
              },
              set(p) {
                if (
                  !P.hasChanged(p, c) &&
                  !(f !== P.EMPTY_OBJ && P.hasChanged(p, f))
                )
                  return
                let m = i.vnode.props
                ;(m &&
                  (e in m || r in m || n in m) &&
                  (`onUpdate:${e}` in m ||
                    `onUpdate:${r}` in m ||
                    `onUpdate:${n}` in m)) ||
                  ((c = p), l())
                let y = s.set ? s.set(p) : p
                i.emit(`update:${e}`, y),
                  P.hasChanged(p, y) &&
                    P.hasChanged(p, f) &&
                    !P.hasChanged(y, h) &&
                    l(),
                  (f = p),
                  (h = y)
              },
            }
          )
        })
      return (
        (o[Symbol.iterator] = () => {
          let u = 0
          return {
            next() {
              return u < 2
                ? { value: u++ ? a || P.EMPTY_OBJ : o, done: !1 }
                : { done: !0 }
            },
          }
        }),
        o
      )
    }
    var u2 = (t, e) =>
      e === 'modelValue' || e === 'model-value'
        ? t.modelModifiers
        : t[`${e}Modifiers`] ||
          t[`${P.camelize(e)}Modifiers`] ||
          t[`${P.hyphenate(e)}Modifiers`]
    function r8(t, e, ...s) {
      if (t.isUnmounted) return
      let i = t.vnode.props || P.EMPTY_OBJ,
        r = s,
        n = e.startsWith('update:'),
        a = n && u2(i, e.slice(7))
      a &&
        (a.trim && (r = s.map((c) => (P.isString(c) ? c.trim() : c))),
        a.number && (r = s.map(P.looseToNumber)))
      let o,
        u = i[(o = P.toHandlerKey(e))] || i[(o = P.toHandlerKey(P.camelize(e)))]
      !u && n && (u = i[(o = P.toHandlerKey(P.hyphenate(e)))]),
        u && Rs(u, t, 6, r)
      let l = i[o + 'Once']
      if (l) {
        if (!t.emitted) t.emitted = {}
        else if (t.emitted[o]) return
        ;(t.emitted[o] = !0), Rs(l, t, 6, r)
      }
    }
    function l2(t, e, s = !1) {
      let i = e.emitsCache,
        r = i.get(t)
      if (r !== void 0) return r
      let n = t.emits,
        a = {},
        o = !1
      if (!P.isFunction(t)) {
        let u = (l) => {
          let c = l2(l, e, !0)
          c && ((o = !0), P.extend(a, c))
        }
        !s && e.mixins.length && e.mixins.forEach(u),
          t.extends && u(t.extends),
          t.mixins && t.mixins.forEach(u)
      }
      return !n && !o
        ? (P.isObject(t) && i.set(t, null), null)
        : (P.isArray(n) ? n.forEach((u) => (a[u] = null)) : P.extend(a, n),
          P.isObject(t) && i.set(t, a),
          a)
    }
    function Yc(t, e) {
      return !t || !P.isOn(e)
        ? !1
        : ((e = e.slice(2).replace(/Once$/, '')),
          P.hasOwn(t, e[0].toLowerCase() + e.slice(1)) ||
            P.hasOwn(t, P.hyphenate(e)) ||
            P.hasOwn(t, e))
    }
    function Qc(t) {
      let {
          type: e,
          vnode: s,
          proxy: i,
          withProxy: r,
          propsOptions: [n],
          slots: a,
          attrs: o,
          emit: u,
          render: l,
          renderCache: c,
          props: f,
          data: h,
          setupState: p,
          ctx: m,
          inheritAttrs: y,
        } = t,
        x = Lo(t),
        C,
        E
      try {
        if (s.shapeFlag & 4) {
          let S = r || i,
            _ = S
          ;(C = os(l.call(_, S, c, f, p, h, m))), (E = o)
        } else {
          let S = e
          ;(C = os(
            S.length > 1 ? S(f, { attrs: o, slots: a, emit: u }) : S(f, null)
          )),
            (E = e.props ? o : a8(o))
        }
      } catch (S) {
        ;(Ko.length = 0), hn(S, t, 1), (C = ot(Ot))
      }
      let g = C
      if (E && y !== !1) {
        let S = Object.keys(E),
          { shapeFlag: _ } = g
        S.length &&
          _ & (1 | 6) &&
          (n && S.some(P.isModelListener) && (E = o8(E, n)),
          (g = ai(g, E, !1, !0)))
      }
      return (
        s.dirs &&
          ((g = ai(g, null, !1, !0)),
          (g.dirs = g.dirs ? g.dirs.concat(s.dirs) : s.dirs)),
        s.transition && (g.transition = s.transition),
        (C = g),
        Lo(x),
        C
      )
    }
    function n8(t, e = !0) {
      let s
      for (let i = 0; i < t.length; i++) {
        let r = t[i]
        if (Sr(r)) {
          if (r.type !== Ot || r.children === 'v-if') {
            if (s) return
            s = r
          }
        } else return
      }
      return s
    }
    var a8 = (t) => {
        let e
        for (let s in t)
          (s === 'class' || s === 'style' || P.isOn(s)) &&
            ((e || (e = {}))[s] = t[s])
        return e
      },
      o8 = (t, e) => {
        let s = {}
        for (let i in t)
          (!P.isModelListener(i) || !(i.slice(9) in e)) && (s[i] = t[i])
        return s
      }
    function u8(t, e, s) {
      let { props: i, children: r, component: n } = t,
        { props: a, children: o, patchFlag: u } = e,
        l = n.emitsOptions
      if (e.dirs || e.transition) return !0
      if (s && u >= 0) {
        if (u & 1024) return !0
        if (u & 16) return i ? c2(i, a, l) : !!a
        if (u & 8) {
          let c = e.dynamicProps
          for (let f = 0; f < c.length; f++) {
            let h = c[f]
            if (a[h] !== i[h] && !Yc(l, h)) return !0
          }
        }
      } else
        return (r || o) && (!o || !o.$stable)
          ? !0
          : i === a
          ? !1
          : i
          ? a
            ? c2(i, a, l)
            : !0
          : !!a
      return !1
    }
    function c2(t, e, s) {
      let i = Object.keys(e)
      if (i.length !== Object.keys(t).length) return !0
      for (let r = 0; r < i.length; r++) {
        let n = i[r]
        if (e[n] !== t[n] && !Yc(s, n)) return !0
      }
      return !1
    }
    function w0({ vnode: t, parent: e }, s) {
      for (; e; ) {
        let i = e.subTree
        if (
          (i.suspense && i.suspense.activeBranch === t && (i.el = t.el),
          i === t)
        )
          ((t = e.vnode).el = s), (e = e.parent)
        else break
      }
    }
    var M0 = (t) => t.__isSuspense,
      R0 = 0,
      l8 = {
        name: 'Suspense',
        __isSuspense: !0,
        process(t, e, s, i, r, n, a, o, u, l) {
          if (t == null) f8(e, s, i, r, n, a, o, u, l)
          else {
            if (n && n.deps > 0 && !t.suspense.isInFallback) {
              ;(e.suspense = t.suspense), (e.suspense.vnode = e), (e.el = t.el)
              return
            }
            h8(t, e, s, i, r, a, o, u, l)
          }
        },
        hydrate: p8,
        normalize: d8,
      },
      c8 = l8
    function qo(t, e) {
      let s = t.props && t.props[e]
      P.isFunction(s) && s()
    }
    function f8(t, e, s, i, r, n, a, o, u) {
      let {
          p: l,
          o: { createElement: c },
        } = u,
        f = c('div'),
        h = (t.suspense = f2(t, r, i, e, f, s, n, a, o, u))
      l(null, (h.pendingBranch = t.ssContent), f, null, i, h, n, a),
        h.deps > 0
          ? (qo(t, 'onPending'),
            qo(t, 'onFallback'),
            l(null, t.ssFallback, e, s, i, null, n, a),
            da(h, t.ssFallback))
          : h.resolve(!1, !0)
    }
    function h8(
      t,
      e,
      s,
      i,
      r,
      n,
      a,
      o,
      { p: u, um: l, o: { createElement: c } }
    ) {
      let f = (e.suspense = t.suspense)
      ;(f.vnode = e), (e.el = t.el)
      let h = e.ssContent,
        p = e.ssFallback,
        {
          activeBranch: m,
          pendingBranch: y,
          isInFallback: x,
          isHydrating: C,
        } = f
      if (y)
        (f.pendingBranch = h),
          Ks(h, y)
            ? (u(y, h, f.hiddenContainer, null, r, f, n, a, o),
              f.deps <= 0
                ? f.resolve()
                : x && (C || (u(m, p, s, i, r, null, n, a, o), da(f, p))))
            : ((f.pendingId = R0++),
              C ? ((f.isHydrating = !1), (f.activeBranch = y)) : l(y, r, f),
              (f.deps = 0),
              (f.effects.length = 0),
              (f.hiddenContainer = c('div')),
              x
                ? (u(null, h, f.hiddenContainer, null, r, f, n, a, o),
                  f.deps <= 0
                    ? f.resolve()
                    : (u(m, p, s, i, r, null, n, a, o), da(f, p)))
                : m && Ks(h, m)
                ? (u(m, h, s, i, r, f, n, a, o), f.resolve(!0))
                : (u(null, h, f.hiddenContainer, null, r, f, n, a, o),
                  f.deps <= 0 && f.resolve()))
      else if (m && Ks(h, m)) u(m, h, s, i, r, f, n, a, o), da(f, h)
      else if (
        (qo(e, 'onPending'),
        (f.pendingBranch = h),
        h.shapeFlag & 512
          ? (f.pendingId = h.component.suspenseId)
          : (f.pendingId = R0++),
        u(null, h, f.hiddenContainer, null, r, f, n, a, o),
        f.deps <= 0)
      )
        f.resolve()
      else {
        let { timeout: E, pendingId: g } = f
        E > 0
          ? setTimeout(() => {
              f.pendingId === g && f.fallback(p)
            }, E)
          : E === 0 && f.fallback(p)
      }
    }
    function f2(t, e, s, i, r, n, a, o, u, l, c = !1) {
      let {
          p: f,
          m: h,
          um: p,
          n: m,
          o: { parentNode: y, remove: x },
        } = l,
        C,
        E = m8(t)
      E && e && e.pendingBranch && ((C = e.pendingId), e.deps++)
      let g = t.props ? P.toNumber(t.props.timeout) : void 0,
        S = n,
        _ = {
          vnode: t,
          parent: e,
          parentComponent: s,
          namespace: a,
          container: i,
          hiddenContainer: r,
          deps: 0,
          pendingId: R0++,
          timeout: typeof g == 'number' ? g : -1,
          activeBranch: null,
          pendingBranch: null,
          isInFallback: !c,
          isHydrating: c,
          isUnmounted: !1,
          effects: [],
          resolve(I = !1, k = !1) {
            let {
                vnode: L,
                activeBranch: N,
                pendingBranch: O,
                pendingId: v,
                effects: A,
                parentComponent: V,
                container: se,
              } = _,
              Y = !1
            _.isHydrating
              ? (_.isHydrating = !1)
              : I ||
                ((Y = N && O.transition && O.transition.mode === 'out-in'),
                Y &&
                  (N.transition.afterLeave = () => {
                    v === _.pendingId &&
                      (h(O, se, n === S ? m(N) : n, 0), kc(A))
                  }),
                N &&
                  (y(N.el) !== _.hiddenContainer && (n = m(N)), p(N, V, _, !0)),
                Y || h(O, se, n, 0)),
              da(_, O),
              (_.pendingBranch = null),
              (_.isInFallback = !1)
            let q = _.parent,
              ee = !1
            for (; q; ) {
              if (q.pendingBranch) {
                q.effects.push(...A), (ee = !0)
                break
              }
              q = q.parent
            }
            !ee && !Y && kc(A),
              (_.effects = []),
              E &&
                e &&
                e.pendingBranch &&
                C === e.pendingId &&
                (e.deps--, e.deps === 0 && !k && e.resolve()),
              qo(L, 'onResolve')
          },
          fallback(I) {
            if (!_.pendingBranch) return
            let {
              vnode: k,
              activeBranch: L,
              parentComponent: N,
              container: O,
              namespace: v,
            } = _
            qo(k, 'onFallback')
            let A = m(L),
              V = () => {
                !_.isInFallback ||
                  (f(null, I, O, A, N, null, v, o, u), da(_, I))
              },
              se = I.transition && I.transition.mode === 'out-in'
            se && (L.transition.afterLeave = V),
              (_.isInFallback = !0),
              p(L, N, null, !0),
              se || V()
          },
          move(I, k, L) {
            _.activeBranch && h(_.activeBranch, I, k, L), (_.container = I)
          },
          next() {
            return _.activeBranch && m(_.activeBranch)
          },
          registerDep(I, k, L) {
            let N = !!_.pendingBranch
            N && _.deps++
            let O = I.vnode.el
            I.asyncDep
              .catch((v) => {
                hn(v, I, 0)
              })
              .then((v) => {
                if (
                  I.isUnmounted ||
                  _.isUnmounted ||
                  _.pendingId !== I.suspenseId
                )
                  return
                I.asyncResolved = !0
                let { vnode: A } = I
                H0(I, v, !1), O && (A.el = O)
                let V = !O && I.subTree.el
                k(I, A, y(O || I.subTree.el), O ? null : m(I.subTree), _, a, L),
                  V && x(V),
                  w0(I, A.el),
                  N && --_.deps == 0 && _.resolve()
              })
          },
          unmount(I, k) {
            ;(_.isUnmounted = !0),
              _.activeBranch && p(_.activeBranch, s, I, k),
              _.pendingBranch && p(_.pendingBranch, s, I, k)
          },
        }
      return _
    }
    function p8(t, e, s, i, r, n, a, o, u) {
      let l = (e.suspense = f2(
          e,
          i,
          s,
          t.parentNode,
          document.createElement('div'),
          null,
          r,
          n,
          a,
          o,
          !0
        )),
        c = u(t, (l.pendingBranch = e.ssContent), s, l, n, a)
      return l.deps === 0 && l.resolve(!1, !0), c
    }
    function d8(t) {
      let { shapeFlag: e, children: s } = t,
        i = e & 32
      ;(t.ssContent = h2(i ? s.default : s)),
        (t.ssFallback = i ? h2(s.fallback) : ot(Ot))
    }
    function h2(t) {
      let e
      if (P.isFunction(t)) {
        let s = gn && t._c
        s && ((t._d = !1), Zc()), (t = t()), s && ((t._d = !0), (e = Xt), d2())
      }
      return (
        P.isArray(t) && (t = n8(t)),
        (t = os(t)),
        e &&
          !t.dynamicChildren &&
          (t.dynamicChildren = e.filter((s) => s !== t)),
        t
      )
    }
    function p2(t, e) {
      e && e.pendingBranch
        ? P.isArray(t)
          ? e.effects.push(...t)
          : e.effects.push(t)
        : kc(t)
    }
    function da(t, e) {
      t.activeBranch = e
      let { vnode: s, parentComponent: i } = t,
        r = e.el
      for (; !r && e.component; ) (e = e.component.subTree), (r = e.el)
      ;(s.el = r), i && i.subTree === s && ((i.vnode.el = r), w0(i, r))
    }
    function m8(t) {
      let e = t.props && t.props.suspensible
      return e != null && e !== !1
    }
    var es = Symbol.for('v-fgt'),
      Er = Symbol.for('v-txt'),
      Ot = Symbol.for('v-cmt'),
      ma = Symbol.for('v-stc'),
      Ko = [],
      Xt = null
    function Zc(t = !1) {
      Ko.push((Xt = t ? null : []))
    }
    function d2() {
      Ko.pop(), (Xt = Ko[Ko.length - 1] || null)
    }
    var gn = 1
    function L0(t) {
      ;(gn += t), t < 0 && Xt && (Xt.hasOnce = !0)
    }
    function m2(t) {
      return (
        (t.dynamicChildren = gn > 0 ? Xt || P.EMPTY_ARR : null),
        d2(),
        gn > 0 && Xt && Xt.push(t),
        t
      )
    }
    function g8(t, e, s, i, r, n) {
      return m2(D0(t, e, s, i, r, n, !0))
    }
    function k0(t, e, s, i, r) {
      return m2(ot(t, e, s, i, r, !0))
    }
    function Sr(t) {
      return t ? t.__v_isVNode === !0 : !1
    }
    function Ks(t, e) {
      return t.type === e.type && t.key === e.key
    }
    function y8(t) {}
    var g2 = ({ key: t }) => (t != null ? t : null),
      ef = ({ ref: t, ref_key: e, ref_for: s }) => (
        typeof t == 'number' && (t = '' + t),
        t != null
          ? P.isString(t) || ue.isRef(t) || P.isFunction(t)
            ? { i: xt, r: t, k: e, f: !!s }
            : t
          : null
      )
    function D0(
      t,
      e = null,
      s = null,
      i = 0,
      r = null,
      n = t === es ? 0 : 1,
      a = !1,
      o = !1
    ) {
      let u = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && g2(e),
        ref: e && ef(e),
        scopeId: Fc,
        slotScopeIds: null,
        children: s,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: n,
        patchFlag: i,
        dynamicProps: r,
        dynamicChildren: null,
        appContext: null,
        ctx: xt,
      }
      return (
        o
          ? (B0(u, s), n & 128 && t.normalize(u))
          : s && (u.shapeFlag |= P.isString(s) ? 8 : 16),
        gn > 0 &&
          !a &&
          Xt &&
          (u.patchFlag > 0 || n & 6) &&
          u.patchFlag !== 32 &&
          Xt.push(u),
        u
      )
    }
    var ot = b8
    function b8(t, e = null, s = null, i = 0, r = null, n = !1) {
      if (((!t || t === vT) && (t = Ot), Sr(t))) {
        let o = ai(t, e, !0)
        return (
          s && B0(o, s),
          gn > 0 &&
            !n &&
            Xt &&
            (o.shapeFlag & 6 ? (Xt[Xt.indexOf(t)] = o) : Xt.push(o)),
          (o.patchFlag = -2),
          o
        )
      }
      if ((v8(t) && (t = t.__vccOpts), e)) {
        e = y2(e)
        let { class: o, style: u } = e
        o && !P.isString(o) && (e.class = P.normalizeClass(o)),
          P.isObject(u) &&
            (ue.isProxy(u) && !P.isArray(u) && (u = P.extend({}, u)),
            (e.style = P.normalizeStyle(u)))
      }
      let a = P.isString(t)
        ? 1
        : M0(t)
        ? 128
        : qM(t)
        ? 64
        : P.isObject(t)
        ? 4
        : P.isFunction(t)
        ? 2
        : 0
      return D0(t, e, s, i, r, a, n, !0)
    }
    function y2(t) {
      return t ? (ue.isProxy(t) || VT(t) ? P.extend({}, t) : t) : null
    }
    function ai(t, e, s = !1, i = !1) {
      let { props: r, ref: n, patchFlag: a, children: o, transition: u } = t,
        l = e ? b2(r || {}, e) : r,
        c = {
          __v_isVNode: !0,
          __v_skip: !0,
          type: t.type,
          props: l,
          key: l && g2(l),
          ref:
            e && e.ref
              ? s && n
                ? P.isArray(n)
                  ? n.concat(ef(e))
                  : [n, ef(e)]
                : ef(e)
              : n,
          scopeId: t.scopeId,
          slotScopeIds: t.slotScopeIds,
          children: o,
          target: t.target,
          targetStart: t.targetStart,
          targetAnchor: t.targetAnchor,
          staticCount: t.staticCount,
          shapeFlag: t.shapeFlag,
          patchFlag: e && t.type !== es ? (a === -1 ? 16 : a | 16) : a,
          dynamicProps: t.dynamicProps,
          dynamicChildren: t.dynamicChildren,
          appContext: t.appContext,
          dirs: t.dirs,
          transition: u,
          component: t.component,
          suspense: t.suspense,
          ssContent: t.ssContent && ai(t.ssContent),
          ssFallback: t.ssFallback && ai(t.ssFallback),
          el: t.el,
          anchor: t.anchor,
          ctx: t.ctx,
          ce: t.ce,
        }
      return u && i && fa(c, u.clone(c)), c
    }
    function F0(t = ' ', e = 0) {
      return ot(Er, null, t, e)
    }
    function E8(t, e) {
      let s = ot(ma, null, t)
      return (s.staticCount = e), s
    }
    function S8(t = '', e = !1) {
      return e ? (Zc(), k0(Ot, null, t)) : ot(Ot, null, t)
    }
    function os(t) {
      return t == null || typeof t == 'boolean'
        ? ot(Ot)
        : P.isArray(t)
        ? ot(es, null, t.slice())
        : typeof t == 'object'
        ? Tr(t)
        : ot(Er, null, String(t))
    }
    function Tr(t) {
      return (t.el === null && t.patchFlag !== -1) || t.memo ? t : ai(t)
    }
    function B0(t, e) {
      let s = 0,
        { shapeFlag: i } = t
      if (e == null) e = null
      else if (P.isArray(e)) s = 16
      else if (typeof e == 'object')
        if (i & (1 | 64)) {
          let r = e.default
          r && (r._c && (r._d = !1), B0(t, r()), r._c && (r._d = !0))
          return
        } else {
          s = 32
          let r = e._
          !r && !VT(e)
            ? (e._ctx = xt)
            : r === 3 &&
              xt &&
              (xt.slots._ === 1
                ? (e._ = 1)
                : ((e._ = 2), (t.patchFlag |= 1024)))
        }
      else
        P.isFunction(e)
          ? ((e = { default: e, _ctx: xt }), (s = 32))
          : ((e = String(e)), i & 64 ? ((s = 16), (e = [F0(e)])) : (s = 8))
      ;(t.children = e), (t.shapeFlag |= s)
    }
    function b2(...t) {
      let e = {}
      for (let s = 0; s < t.length; s++) {
        let i = t[s]
        for (let r in i)
          if (r === 'class')
            e.class !== i.class &&
              (e.class = P.normalizeClass([e.class, i.class]))
          else if (r === 'style') e.style = P.normalizeStyle([e.style, i.style])
          else if (P.isOn(r)) {
            let n = e[r],
              a = i[r]
            a &&
              n !== a &&
              !(P.isArray(n) && n.includes(a)) &&
              (e[r] = n ? [].concat(n, a) : a)
          } else r !== '' && (e[r] = i[r])
      }
      return e
    }
    function us(t, e, s, i = null) {
      Rs(t, e, 7, [s, i])
    }
    var T8 = kT(),
      _8 = 0
    function E2(t, e, s) {
      let i = t.type,
        r = (e ? e.appContext : t.appContext) || T8,
        n = {
          uid: _8++,
          vnode: t,
          type: i,
          parent: e,
          appContext: r,
          root: null,
          next: null,
          subTree: null,
          effect: null,
          update: null,
          scope: new ue.EffectScope(!0),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: e ? e.provides : Object.create(r.provides),
          accessCache: null,
          renderCache: [],
          components: null,
          directives: null,
          propsOptions: HT(i, r),
          emitsOptions: l2(i, r),
          emit: null,
          emitted: null,
          propsDefaults: P.EMPTY_OBJ,
          inheritAttrs: i.inheritAttrs,
          ctx: P.EMPTY_OBJ,
          data: P.EMPTY_OBJ,
          props: P.EMPTY_OBJ,
          attrs: P.EMPTY_OBJ,
          slots: P.EMPTY_OBJ,
          refs: P.EMPTY_OBJ,
          setupState: P.EMPTY_OBJ,
          setupContext: null,
          suspense: s,
          suspenseId: s ? s.pendingId : 0,
          asyncDep: null,
          asyncResolved: !1,
          isMounted: !1,
          isUnmounted: !1,
          isDeactivated: !1,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null,
        }
      return (
        (n.ctx = { _: n }),
        (n.root = e ? e.root : n),
        (n.emit = r8.bind(null, n)),
        t.ce && t.ce(n),
        n
      )
    }
    var At = null,
      ga = () => At || xt,
      tf,
      V0
    {
      let t = P.getGlobalThis(),
        e = (s, i) => {
          let r
          return (
            (r = t[s]) || (r = t[s] = []),
            r.push(i),
            (n) => {
              r.length > 1 ? r.forEach((a) => a(n)) : r[0](n)
            }
          )
        }
      ;(tf = e('__VUE_INSTANCE_SETTERS__', (s) => (At = s))),
        (V0 = e('__VUE_SSR_SETTERS__', (s) => (Xo = s)))
    }
    var yn = (t) => {
        let e = At
        return (
          tf(t),
          t.scope.on(),
          () => {
            t.scope.off(), tf(e)
          }
        )
      },
      U0 = () => {
        At && At.scope.off(), tf(null)
      }
    function S2(t) {
      return t.vnode.shapeFlag & 4
    }
    var Xo = !1
    function T2(t, e = !1, s = !1) {
      e && V0(e)
      let { props: i, children: r } = t.vnode,
        n = S2(t)
      BM(t, i, n, e), $M(t, r, s)
      let a = n ? x8(t, e) : void 0
      return e && V0(!1), a
    }
    function x8(t, e) {
      let s = t.type
      ;(t.accessCache = Object.create(null)), (t.proxy = new Proxy(t.ctx, _0))
      let { setup: i } = s
      if (i) {
        let r = (t.setupContext = i.length > 1 ? x2(t) : null),
          n = yn(t)
        ue.pauseTracking()
        let a = Mi(i, t, 0, [t.props, r])
        if ((ue.resetTracking(), n(), P.isPromise(a))) {
          if ((a.then(U0, U0), e))
            return a
              .then((o) => {
                H0(t, o, e)
              })
              .catch((o) => {
                hn(o, t, 0)
              })
          t.asyncDep = a
        } else H0(t, a, e)
      } else _2(t, e)
    }
    function H0(t, e, s) {
      P.isFunction(e)
        ? t.type.__ssrInlineRender
          ? (t.ssrRender = e)
          : (t.render = e)
        : P.isObject(e) && (t.setupState = ue.proxyRefs(e)),
        _2(t, s)
    }
    var sf, $0
    function A8(t) {
      ;(sf = t),
        ($0 = (e) => {
          e.render._rc && (e.withProxy = new Proxy(e.ctx, gM))
        })
    }
    var P8 = () => !sf
    function _2(t, e, s) {
      let i = t.type
      if (!t.render) {
        if (!e && sf && !i.render) {
          let r = i.template || A0(t).template
          if (r) {
            let { isCustomElement: n, compilerOptions: a } =
                t.appContext.config,
              { delimiters: o, compilerOptions: u } = i,
              l = P.extend(
                P.extend({ isCustomElement: n, delimiters: o }, a),
                u
              )
            i.render = sf(r, l)
          }
        }
        ;(t.render = i.render || P.NOOP), $0 && $0(t)
      }
      {
        let r = yn(t)
        ue.pauseTracking()
        try {
          OM(t)
        } finally {
          ue.resetTracking(), r()
        }
      }
    }
    var C8 = {
      get(t, e) {
        return ue.track(t, 'get', ''), t[e]
      },
    }
    function x2(t) {
      let e = (s) => {
        t.exposed = s || {}
      }
      return {
        attrs: new Proxy(t.attrs, C8),
        slots: t.slots,
        emit: t.emit,
        expose: e,
      }
    }
    function Go(t) {
      return t.exposed
        ? t.exposeProxy ||
            (t.exposeProxy = new Proxy(ue.proxyRefs(ue.markRaw(t.exposed)), {
              get(e, s) {
                if (s in e) return e[s]
                if (s in Fo) return Fo[s](t)
              },
              has(e, s) {
                return s in e || s in Fo
              },
            }))
        : t.proxy
    }
    function j0(t, e = !0) {
      return P.isFunction(t)
        ? t.displayName || t.name
        : t.name || (e && t.__name)
    }
    function v8(t) {
      return P.isFunction(t) && '__vccOpts' in t
    }
    var A2 = (t, e) => ue.computed(t, e, Xo)
    function N8(t, e, s) {
      let i = arguments.length
      return i === 2
        ? P.isObject(e) && !P.isArray(e)
          ? Sr(e)
            ? ot(t, null, [e])
            : ot(t, e)
          : ot(t, null, e)
        : (i > 3
            ? (s = Array.prototype.slice.call(arguments, 2))
            : i === 3 && Sr(s) && (s = [s]),
          ot(t, e, s))
    }
    function I8() {}
    function O8(t, e, s, i) {
      let r = s[i]
      if (r && P2(r, t)) return r
      let n = e()
      return (n.memo = t.slice()), (n.cacheIndex = i), (s[i] = n)
    }
    function P2(t, e) {
      let s = t.memo
      if (s.length != e.length) return !1
      for (let i = 0; i < s.length; i++) if (P.hasChanged(s[i], e[i])) return !1
      return gn > 0 && Xt && Xt.push(t), !0
    }
    var C2 = '3.4.34',
      w8 = P.NOOP,
      M8 = G4,
      R8 = void 0,
      L8 = P.NOOP,
      k8 = {
        createComponentInstance: E2,
        setupComponent: T2,
        renderComponentRoot: Qc,
        setCurrentRenderingInstance: Lo,
        isVNode: Sr,
        normalizeVNode: os,
        getComponentPublicInstance: Go,
      },
      D8 = k8,
      F8 = null,
      B8 = null,
      V8 = null
    K.EffectScope = ue.EffectScope
    K.ReactiveEffect = ue.ReactiveEffect
    K.TrackOpTypes = ue.TrackOpTypes
    K.TriggerOpTypes = ue.TriggerOpTypes
    K.customRef = ue.customRef
    K.effect = ue.effect
    K.effectScope = ue.effectScope
    K.getCurrentScope = ue.getCurrentScope
    K.isProxy = ue.isProxy
    K.isReactive = ue.isReactive
    K.isReadonly = ue.isReadonly
    K.isRef = ue.isRef
    K.isShallow = ue.isShallow
    K.markRaw = ue.markRaw
    K.onScopeDispose = ue.onScopeDispose
    K.proxyRefs = ue.proxyRefs
    K.reactive = ue.reactive
    K.readonly = ue.readonly
    K.ref = ue.ref
    K.shallowReactive = ue.shallowReactive
    K.shallowReadonly = ue.shallowReadonly
    K.shallowRef = ue.shallowRef
    K.stop = ue.stop
    K.toRaw = ue.toRaw
    K.toRef = ue.toRef
    K.toRefs = ue.toRefs
    K.toValue = ue.toValue
    K.triggerRef = ue.triggerRef
    K.unref = ue.unref
    K.camelize = P.camelize
    K.capitalize = P.capitalize
    K.normalizeClass = P.normalizeClass
    K.normalizeProps = P.normalizeProps
    K.normalizeStyle = P.normalizeStyle
    K.toDisplayString = P.toDisplayString
    K.toHandlerKey = P.toHandlerKey
    K.BaseTransition = iM
    K.BaseTransitionPropsValidators = pT
    K.Comment = Ot
    K.DeprecationTypes = V8
    K.ErrorCodes = X4
    K.ErrorTypeStrings = M8
    K.Fragment = es
    K.KeepAlive = aM
    K.Static = ma
    K.Suspense = c8
    K.Teleport = GM
    K.Text = Er
    K.assertNumber = K4
    K.callWithAsyncErrorHandling = Rs
    K.callWithErrorHandling = Mi
    K.cloneVNode = ai
    K.compatUtils = B8
    K.computed = A2
    K.createBlock = k0
    K.createCommentVNode = S8
    K.createElementBlock = g8
    K.createElementVNode = D0
    K.createHydrationRenderer = QM
    K.createPropsRestProxy = NM
    K.createRenderer = YM
    K.createSlots = pM
    K.createStaticVNode = E8
    K.createTextVNode = F0
    K.createVNode = ot
    K.defineAsyncComponent = rM
    K.defineComponent = yT
    K.defineEmits = bM
    K.defineExpose = EM
    K.defineModel = _M
    K.defineOptions = SM
    K.defineProps = yM
    K.defineSlots = TM
    K.devtools = R8
    K.getCurrentInstance = ga
    K.getTransitionRawChildren = p0
    K.guardReactiveProps = y2
    K.h = N8
    K.handleError = hn
    K.hasInjectionContext = FM
    K.initCustomFormatter = I8
    K.inject = Uo
    K.isMemoSame = P2
    K.isRuntimeOnly = P8
    K.isVNode = Sr
    K.mergeDefaults = CM
    K.mergeModels = vM
    K.mergeProps = b2
    K.nextTick = uT
    K.onActivated = bT
    K.onBeforeMount = TT
    K.onBeforeUnmount = jc
    K.onBeforeUpdate = _T
    K.onDeactivated = ET
    K.onErrorCaptured = CT
    K.onMounted = $c
    K.onRenderTracked = PT
    K.onRenderTriggered = AT
    K.onServerPrefetch = xT
    K.onUnmounted = y0
    K.onUpdated = g0
    K.openBlock = Zc
    K.popScopeId = Z4
    K.provide = DT
    K.pushScopeId = Q4
    K.queuePostFlushCb = kc
    K.registerRuntimeCompiler = A8
    K.renderList = hM
    K.renderSlot = dM
    K.resolveComponent = lM
    K.resolveDirective = fM
    K.resolveDynamicComponent = cM
    K.resolveFilter = F8
    K.resolveTransitionHooks = Vc
    K.setBlockTracking = L0
    K.setDevtoolsHook = L8
    K.setTransitionHooks = fa
    K.ssrContextKey = r2
    K.ssrUtils = D8
    K.toHandlers = mM
    K.transformVNodeArgs = y8
    K.useAttrs = PM
    K.useModel = i8
    K.useSSRContext = n2
    K.useSlots = AM
    K.useTransitionState = hT
    K.version = C2
    K.warn = w8
    K.watch = $o
    K.watchEffect = e8
    K.watchPostEffect = t8
    K.watchSyncEffect = a2
    K.withAsyncContext = IM
    K.withCtx = f0
    K.withDefaults = xM
    K.withDirectives = tM
    K.withMemo = O8
    K.withScopeId = eM
  })
  var lx = Oe((X) => {
    'use strict'
    Object.defineProperty(X, '__esModule', { value: !0 })
    var te = u0(),
      b = fs(),
      bn = []
    function Wo(t) {
      bn.push(t)
    }
    function zo() {
      bn.pop()
    }
    var q0 = !1
    function Z(t, ...e) {
      if (q0) return
      ;(q0 = !0), te.pauseTracking()
      let s = bn.length ? bn[bn.length - 1].component : null,
        i = s && s.appContext.config.warnHandler,
        r = U8()
      if (i)
        oi(i, s, 11, [
          t +
            e
              .map((n) => {
                var a, o
                return (o = (a = n.toString) == null ? void 0 : a.call(n)) !=
                  null
                  ? o
                  : JSON.stringify(n)
              })
              .join(''),
          s && s.proxy,
          r.map(({ vnode: n }) => `at <${wf(s, n.type)}>`).join(`
`),
          r,
        ])
      else {
        let n = [`[Vue warn]: ${t}`, ...e]
        r.length &&
          n.push(
            `
`,
            ...H8(r)
          ),
          console.warn(...n)
      }
      te.resetTracking(), (q0 = !1)
    }
    function U8() {
      let t = bn[bn.length - 1]
      if (!t) return []
      let e = []
      for (; t; ) {
        let s = e[0]
        s && s.vnode === t
          ? s.recurseCount++
          : e.push({ vnode: t, recurseCount: 0 })
        let i = t.component && t.component.parent
        t = i && i.vnode
      }
      return e
    }
    function H8(t) {
      let e = []
      return (
        t.forEach((s, i) => {
          e.push(
            ...(i === 0
              ? []
              : [
                  `
`,
                ]),
            ...$8(s)
          )
        }),
        e
      )
    }
    function $8({ vnode: t, recurseCount: e }) {
      let s = e > 0 ? `... (${e} recursive calls)` : '',
        i = t.component ? t.component.parent == null : !1,
        r = ` at <${wf(t.component, t.type, i)}`,
        n = '>' + s
      return t.props ? [r, ...j8(t.props), n] : [r + n]
    }
    function j8(t) {
      let e = [],
        s = Object.keys(t)
      return (
        s.slice(0, 3).forEach((i) => {
          e.push(...N2(i, t[i]))
        }),
        s.length > 3 && e.push(' ...'),
        e
      )
    }
    function N2(t, e, s) {
      return b.isString(e)
        ? ((e = JSON.stringify(e)), s ? e : [`${t}=${e}`])
        : typeof e == 'number' || typeof e == 'boolean' || e == null
        ? s
          ? e
          : [`${t}=${e}`]
        : te.isRef(e)
        ? ((e = N2(t, te.toRaw(e.value), !0)), s ? e : [`${t}=Ref<`, e, '>'])
        : b.isFunction(e)
        ? [`${t}=fn${e.name ? `<${e.name}>` : ''}`]
        : ((e = te.toRaw(e)), s ? e : [`${t}=`, e])
    }
    function I2(t, e) {
      t !== void 0 &&
        (typeof t != 'number'
          ? Z(`${e} is not a valid number - got ${JSON.stringify(t)}.`)
          : isNaN(t) &&
            Z(`${e} is NaN - the duration expression might be incorrect.`))
    }
    var q8 = {
        SETUP_FUNCTION: 0,
        0: 'SETUP_FUNCTION',
        RENDER_FUNCTION: 1,
        1: 'RENDER_FUNCTION',
        WATCH_GETTER: 2,
        2: 'WATCH_GETTER',
        WATCH_CALLBACK: 3,
        3: 'WATCH_CALLBACK',
        WATCH_CLEANUP: 4,
        4: 'WATCH_CLEANUP',
        NATIVE_EVENT_HANDLER: 5,
        5: 'NATIVE_EVENT_HANDLER',
        COMPONENT_EVENT_HANDLER: 6,
        6: 'COMPONENT_EVENT_HANDLER',
        VNODE_HOOK: 7,
        7: 'VNODE_HOOK',
        DIRECTIVE_HOOK: 8,
        8: 'DIRECTIVE_HOOK',
        TRANSITION_HOOK: 9,
        9: 'TRANSITION_HOOK',
        APP_ERROR_HANDLER: 10,
        10: 'APP_ERROR_HANDLER',
        APP_WARN_HANDLER: 11,
        11: 'APP_WARN_HANDLER',
        FUNCTION_REF: 12,
        12: 'FUNCTION_REF',
        ASYNC_COMPONENT_LOADER: 13,
        13: 'ASYNC_COMPONENT_LOADER',
        SCHEDULER: 14,
        14: 'SCHEDULER',
        COMPONENT_UPDATE: 15,
        15: 'COMPONENT_UPDATE',
      },
      rf = {
        sp: 'serverPrefetch hook',
        bc: 'beforeCreate hook',
        c: 'created hook',
        bm: 'beforeMount hook',
        m: 'mounted hook',
        bu: 'beforeUpdate hook',
        u: 'updated',
        bum: 'beforeUnmount hook',
        um: 'unmounted hook',
        a: 'activated hook',
        da: 'deactivated hook',
        ec: 'errorCaptured hook',
        rtc: 'renderTracked hook',
        rtg: 'renderTriggered hook',
        [0]: 'setup function',
        [1]: 'render function',
        [2]: 'watcher getter',
        [3]: 'watcher callback',
        [4]: 'watcher cleanup function',
        [5]: 'native event handler',
        [6]: 'component event handler',
        [7]: 'vnode hook',
        [8]: 'directive hook',
        [9]: 'transition hook',
        [10]: 'app errorHandler',
        [11]: 'app warnHandler',
        [12]: 'ref function',
        [13]: 'async component loader',
        [14]: 'scheduler flush',
        [15]: 'component update',
      }
    function oi(t, e, s, i) {
      try {
        return i ? t(...i) : t()
      } catch (r) {
        _r(r, e, s)
      }
    }
    function ks(t, e, s, i) {
      if (b.isFunction(t)) {
        let r = oi(t, e, s, i)
        return (
          r &&
            b.isPromise(r) &&
            r.catch((n) => {
              _r(n, e, s)
            }),
          r
        )
      }
      if (b.isArray(t)) {
        let r = []
        for (let n = 0; n < t.length; n++) r.push(ks(t[n], e, s, i))
        return r
      } else
        Z(
          `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof t}`
        )
    }
    function _r(t, e, s, i = !0) {
      let r = e ? e.vnode : null
      if (e) {
        let n = e.parent,
          a = e.proxy,
          o = rf[s]
        for (; n; ) {
          let l = n.ec
          if (l) {
            for (let c = 0; c < l.length; c++) if (l[c](t, a, o) === !1) return
          }
          n = n.parent
        }
        let u = e.appContext.config.errorHandler
        if (u) {
          te.pauseTracking(), oi(u, null, 10, [t, a, o]), te.resetTracking()
          return
        }
      }
      K8(t, s, r, i)
    }
    function K8(t, e, s, i = !0) {
      {
        let r = rf[e]
        if (
          (s && Wo(s),
          Z(`Unhandled error${r ? ` during execution of ${r}` : ''}`),
          s && zo(),
          i)
        )
          throw t
        console.error(t)
      }
    }
    var Jo = !1,
      K0 = !1,
      Gt = [],
      ui = 0,
      ya = [],
      xr = null,
      En = 0,
      O2 = Promise.resolve(),
      X0 = null,
      X8 = 100
    function w2(t) {
      let e = X0 || O2
      return t ? e.then(this ? t.bind(this) : t) : e
    }
    function G8(t) {
      let e = ui + 1,
        s = Gt.length
      for (; e < s; ) {
        let i = (e + s) >>> 1,
          r = Gt[i],
          n = Zo(r)
        n < t || (n === t && r.pre) ? (e = i + 1) : (s = i)
      }
      return e
    }
    function Yo(t) {
      ;(!Gt.length || !Gt.includes(t, Jo && t.allowRecurse ? ui + 1 : ui)) &&
        (t.id == null ? Gt.push(t) : Gt.splice(G8(t.id), 0, t), M2())
    }
    function M2() {
      !Jo && !K0 && ((K0 = !0), (X0 = O2.then(L2)))
    }
    function W8(t) {
      let e = Gt.indexOf(t)
      e > ui && Gt.splice(e, 1)
    }
    function Qo(t) {
      b.isArray(t)
        ? ya.push(...t)
        : (!xr || !xr.includes(t, t.allowRecurse ? En + 1 : En)) && ya.push(t),
        M2()
    }
    function R2(t, e, s = Jo ? ui + 1 : 0) {
      for (e = e || new Map(); s < Gt.length; s++) {
        let i = Gt[s]
        if (i && i.pre) {
          if ((t && i.id !== t.uid) || G0(e, i)) continue
          Gt.splice(s, 1), s--, i()
        }
      }
    }
    function nf(t) {
      if (ya.length) {
        let e = [...new Set(ya)].sort((s, i) => Zo(s) - Zo(i))
        if (((ya.length = 0), xr)) {
          xr.push(...e)
          return
        }
        for (xr = e, t = t || new Map(), En = 0; En < xr.length; En++) {
          let s = xr[En]
          G0(t, s) || (s.active !== !1 && s())
        }
        ;(xr = null), (En = 0)
      }
    }
    var Zo = (t) => (t.id == null ? 1 / 0 : t.id),
      z8 = (t, e) => {
        let s = Zo(t) - Zo(e)
        if (s === 0) {
          if (t.pre && !e.pre) return -1
          if (e.pre && !t.pre) return 1
        }
        return s
      }
    function L2(t) {
      ;(K0 = !1), (Jo = !0), (t = t || new Map()), Gt.sort(z8)
      let e = (s) => G0(t, s)
      try {
        for (ui = 0; ui < Gt.length; ui++) {
          let s = Gt[ui]
          if (s && s.active !== !1) {
            if (e(s)) continue
            oi(s, s.i, s.i ? 15 : 14)
          }
        }
      } finally {
        ;(ui = 0),
          (Gt.length = 0),
          nf(t),
          (Jo = !1),
          (X0 = null),
          (Gt.length || ya.length) && L2(t)
      }
    }
    function G0(t, e) {
      if (!t.has(e)) t.set(e, 1)
      else {
        let s = t.get(e)
        if (s > X8) {
          let i = e.i,
            r = i && yu(i.type)
          return (
            _r(
              `Maximum recursive updates exceeded${
                r ? ` in component <${r}>` : ''
              }. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
              null,
              10
            ),
            !0
          )
        } else t.set(e, s + 1)
      }
    }
    var Ar = !1,
      af = new Map()
    b.getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: W0(k2),
      rerender: W0(Q8),
      reload: W0(Z8),
    }
    var Sn = new Map()
    function J8(t) {
      let e = t.type.__hmrId,
        s = Sn.get(e)
      s || (k2(e, t.type), (s = Sn.get(e))), s.instances.add(t)
    }
    function Y8(t) {
      Sn.get(t.type.__hmrId).instances.delete(t)
    }
    function k2(t, e) {
      return Sn.has(t)
        ? !1
        : (Sn.set(t, { initialDef: of(e), instances: new Set() }), !0)
    }
    function of(t) {
      return ax(t) ? t.__vccOpts : t
    }
    function Q8(t, e) {
      let s = Sn.get(t)
      !s ||
        ((s.initialDef.render = e),
        [...s.instances].forEach((i) => {
          e && ((i.render = e), (of(i.type).render = e)),
            (i.renderCache = []),
            (Ar = !0),
            (i.effect.dirty = !0),
            i.update(),
            (Ar = !1)
        }))
    }
    function Z8(t, e) {
      let s = Sn.get(t)
      if (!s) return
      ;(e = of(e)), D2(s.initialDef, e)
      let i = [...s.instances]
      for (let r = 0; r < i.length; r++) {
        let n = i[r],
          a = of(n.type),
          o = af.get(a)
        o || (a !== s.initialDef && D2(a, e), af.set(a, (o = new Set()))),
          o.add(n),
          n.appContext.propsCache.delete(n.type),
          n.appContext.emitsCache.delete(n.type),
          n.appContext.optionsCache.delete(n.type),
          n.ceReload
            ? (o.add(n), n.ceReload(e.styles), o.delete(n))
            : n.parent
            ? ((n.parent.effect.dirty = !0),
              Yo(() => {
                n.parent.update(), o.delete(n)
              }))
            : n.appContext.reload
            ? n.appContext.reload()
            : typeof window != 'undefined'
            ? window.location.reload()
            : console.warn(
                '[HMR] Root or manually mounted instance modified. Full reload required.'
              )
      }
      Qo(() => {
        af.clear()
      })
    }
    function D2(t, e) {
      b.extend(t, e)
      for (let s in t) s !== '__file' && !(s in e) && delete t[s]
    }
    function W0(t) {
      return (e, s) => {
        try {
          return t(e, s)
        } catch (i) {
          console.error(i),
            console.warn(
              '[HMR] Something went wrong during Vue component hot-reload. Full reload required.'
            )
        }
      }
    }
    var Xs,
      eu = [],
      z0 = !1
    function tu(t, ...e) {
      Xs ? Xs.emit(t, ...e) : z0 || eu.push({ event: t, args: e })
    }
    function J0(t, e) {
      var s, i
      ;(Xs = t),
        Xs
          ? ((Xs.enabled = !0),
            eu.forEach(({ event: r, args: n }) => Xs.emit(r, ...n)),
            (eu = []))
          : typeof window != 'undefined' &&
            window.HTMLElement &&
            !((i = (s = window.navigator) == null ? void 0 : s.userAgent) ==
            null
              ? void 0
              : i.includes('jsdom'))
          ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ =
              e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((n) => {
              J0(n, e)
            }),
            setTimeout(() => {
              Xs ||
                ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null), (z0 = !0), (eu = []))
            }, 3e3))
          : ((z0 = !0), (eu = []))
    }
    function eR(t, e) {
      tu('app:init', t, e, { Fragment: Vt, Text: Fi, Comment: ut, Static: vn })
    }
    function tR(t) {
      tu('app:unmount', t)
    }
    var Y0 = Q0('component:added'),
      F2 = Q0('component:updated'),
      sR = Q0('component:removed'),
      iR = (t) => {
        Xs &&
          typeof Xs.cleanupBuffer == 'function' &&
          !Xs.cleanupBuffer(t) &&
          sR(t)
      }
    function Q0(t) {
      return (e) => {
        tu(t, e.appContext.app, e.uid, e.parent ? e.parent.uid : void 0, e)
      }
    }
    var rR = B2('perf:start'),
      nR = B2('perf:end')
    function B2(t) {
      return (e, s, i) => {
        tu(t, e.appContext.app, e.uid, e, s, i)
      }
    }
    function aR(t, e, s) {
      tu('component:emit', t.appContext.app, t, e, s)
    }
    var ht = null,
      uf = null
    function su(t) {
      let e = ht
      return (ht = t), (uf = (t && t.type.__scopeId) || null), e
    }
    function oR(t) {
      uf = t
    }
    function uR() {
      uf = null
    }
    var lR = (t) => Z0
    function Z0(t, e = ht, s) {
      if (!e || t._n) return t
      let i = (...r) => {
        i._d && Am(-1)
        let n = su(e),
          a
        try {
          a = t(...r)
        } finally {
          su(n), i._d && Am(1)
        }
        return F2(e), a
      }
      return (i._n = !0), (i._c = !0), (i._d = !0), i
    }
    function V2(t) {
      b.isBuiltInDirective(t) &&
        Z('Do not use built-in directive ids as custom directive id: ' + t)
    }
    function cR(t, e) {
      if (ht === null)
        return Z('withDirectives can only be used inside render functions.'), t
      let s = gu(ht),
        i = t.dirs || (t.dirs = [])
      for (let r = 0; r < e.length; r++) {
        let [n, a, o, u = b.EMPTY_OBJ] = e[r]
        n &&
          (b.isFunction(n) && (n = { mounted: n, updated: n }),
          n.deep && vr(a),
          i.push({
            dir: n,
            instance: s,
            value: a,
            oldValue: void 0,
            arg: o,
            modifiers: u,
          }))
      }
      return t
    }
    function li(t, e, s, i) {
      let r = t.dirs,
        n = e && e.dirs
      for (let a = 0; a < r.length; a++) {
        let o = r[a]
        n && (o.oldValue = n[a].value)
        let u = o.dir[i]
        u &&
          (te.pauseTracking(), ks(u, s, 8, [t.el, o, t, e]), te.resetTracking())
      }
    }
    var Pr = Symbol('_leaveCb'),
      lf = Symbol('_enterCb')
    function U2() {
      let t = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map(),
      }
      return (
        pf(() => {
          t.isMounted = !0
        }),
        df(() => {
          t.isUnmounting = !0
        }),
        t
      )
    }
    var Ds = [Function, Array],
      H2 = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: Ds,
        onEnter: Ds,
        onAfterEnter: Ds,
        onEnterCancelled: Ds,
        onBeforeLeave: Ds,
        onLeave: Ds,
        onAfterLeave: Ds,
        onLeaveCancelled: Ds,
        onBeforeAppear: Ds,
        onAppear: Ds,
        onAfterAppear: Ds,
        onAppearCancelled: Ds,
      },
      $2 = (t) => {
        let e = t.subTree
        return e.component ? $2(e.component) : e
      },
      fR = {
        name: 'BaseTransition',
        props: H2,
        setup(t, { slots: e }) {
          let s = In(),
            i = U2()
          return () => {
            let r = e.default && tm(e.default(), !0)
            if (!r || !r.length) return
            let n = r[0]
            if (r.length > 1) {
              let h = !1
              for (let p of r)
                if (p.type !== ut) {
                  if (h) {
                    Z(
                      '<transition> can only be used on a single element or component. Use <transition-group> for lists.'
                    )
                    break
                  }
                  ;(n = p), (h = !0)
                }
            }
            let a = te.toRaw(t),
              { mode: o } = a
            if (
              (o &&
                o !== 'in-out' &&
                o !== 'out-in' &&
                o !== 'default' &&
                Z(`invalid <transition> mode: ${o}`),
              i.isLeaving)
            )
              return em(n)
            let u = q2(n)
            if (!u) return em(n)
            let l = cf(u, a, i, s, (h) => (l = h))
            ba(u, l)
            let c = s.subTree,
              f = c && q2(c)
            if (f && f.type !== ut && !Gs(u, f) && $2(s).type !== ut) {
              let h = cf(f, a, i, s)
              if ((ba(f, h), o === 'out-in' && u.type !== ut))
                return (
                  (i.isLeaving = !0),
                  (h.afterLeave = () => {
                    ;(i.isLeaving = !1),
                      s.update.active !== !1 &&
                        ((s.effect.dirty = !0), s.update())
                  }),
                  em(n)
                )
              o === 'in-out' &&
                u.type !== ut &&
                (h.delayLeave = (p, m, y) => {
                  let x = j2(i, f)
                  ;(x[String(f.key)] = f),
                    (p[Pr] = () => {
                      m(), (p[Pr] = void 0), delete l.delayedLeave
                    }),
                    (l.delayedLeave = y)
                })
            }
            return n
          }
        },
      },
      hR = fR
    function j2(t, e) {
      let { leavingVNodes: s } = t,
        i = s.get(e.type)
      return i || ((i = Object.create(null)), s.set(e.type, i)), i
    }
    function cf(t, e, s, i, r) {
      let {
          appear: n,
          mode: a,
          persisted: o = !1,
          onBeforeEnter: u,
          onEnter: l,
          onAfterEnter: c,
          onEnterCancelled: f,
          onBeforeLeave: h,
          onLeave: p,
          onAfterLeave: m,
          onLeaveCancelled: y,
          onBeforeAppear: x,
          onAppear: C,
          onAfterAppear: E,
          onAppearCancelled: g,
        } = e,
        S = String(t.key),
        _ = j2(s, t),
        I = (N, O) => {
          N && ks(N, i, 9, O)
        },
        k = (N, O) => {
          let v = O[1]
          I(N, O),
            b.isArray(N)
              ? N.every((A) => A.length <= 1) && v()
              : N.length <= 1 && v()
        },
        L = {
          mode: a,
          persisted: o,
          beforeEnter(N) {
            let O = u
            if (!s.isMounted)
              if (n) O = x || u
              else return
            N[Pr] && N[Pr](!0)
            let v = _[S]
            v && Gs(t, v) && v.el[Pr] && v.el[Pr](), I(O, [N])
          },
          enter(N) {
            let O = l,
              v = c,
              A = f
            if (!s.isMounted)
              if (n) (O = C || l), (v = E || c), (A = g || f)
              else return
            let V = !1,
              se = (N[lf] = (Y) => {
                V ||
                  ((V = !0),
                  Y ? I(A, [N]) : I(v, [N]),
                  L.delayedLeave && L.delayedLeave(),
                  (N[lf] = void 0))
              })
            O ? k(O, [N, se]) : se()
          },
          leave(N, O) {
            let v = String(t.key)
            if ((N[lf] && N[lf](!0), s.isUnmounting)) return O()
            I(h, [N])
            let A = !1,
              V = (N[Pr] = (se) => {
                A ||
                  ((A = !0),
                  O(),
                  se ? I(y, [N]) : I(m, [N]),
                  (N[Pr] = void 0),
                  _[v] === t && delete _[v])
              })
            ;(_[v] = t), p ? k(p, [N, V]) : V()
          },
          clone(N) {
            let O = cf(N, e, s, i, r)
            return r && r(O), O
          },
        }
      return L
    }
    function em(t) {
      if (Ea(t)) return (t = Fs(t)), (t.children = null), t
    }
    function q2(t) {
      if (!Ea(t)) return t
      if (t.component) return t.component.subTree
      let { shapeFlag: e, children: s } = t
      if (s) {
        if (e & 16) return s[0]
        if (e & 32 && b.isFunction(s.default)) return s.default()
      }
    }
    function ba(t, e) {
      t.shapeFlag & 6 && t.component
        ? ba(t.component.subTree, e)
        : t.shapeFlag & 128
        ? ((t.ssContent.transition = e.clone(t.ssContent)),
          (t.ssFallback.transition = e.clone(t.ssFallback)))
        : (t.transition = e)
    }
    function tm(t, e = !1, s) {
      let i = [],
        r = 0
      for (let n = 0; n < t.length; n++) {
        let a = t[n],
          o = s == null ? a.key : String(s) + String(a.key != null ? a.key : n)
        a.type === Vt
          ? (a.patchFlag & 128 && r++, (i = i.concat(tm(a.children, e, o))))
          : (e || a.type !== ut) && i.push(o != null ? Fs(a, { key: o }) : a)
      }
      if (r > 1) for (let n = 0; n < i.length; n++) i[n].patchFlag = -2
      return i
    }
    function K2(t, e) {
      return b.isFunction(t)
        ? (() => b.extend({ name: t.name }, e, { setup: t }))()
        : t
    }
    var Tn = (t) => !!t.type.__asyncLoader
    function pR(t) {
      b.isFunction(t) && (t = { loader: t })
      let {
          loader: e,
          loadingComponent: s,
          errorComponent: i,
          delay: r = 200,
          timeout: n,
          suspensible: a = !0,
          onError: o,
        } = t,
        u = null,
        l,
        c = 0,
        f = () => (c++, (u = null), h()),
        h = () => {
          let p
          return (
            u ||
            (p = u =
              e()
                .catch((m) => {
                  if (((m = m instanceof Error ? m : new Error(String(m))), o))
                    return new Promise((y, x) => {
                      o(
                        m,
                        () => y(f()),
                        () => x(m),
                        c + 1
                      )
                    })
                  throw m
                })
                .then((m) => {
                  if (p !== u && u) return u
                  if (
                    (m ||
                      Z(
                        'Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.'
                      ),
                    m &&
                      (m.__esModule || m[Symbol.toStringTag] === 'Module') &&
                      (m = m.default),
                    m && !b.isObject(m) && !b.isFunction(m))
                  )
                    throw new Error(`Invalid async component load result: ${m}`)
                  return (l = m), m
                }))
          )
        }
      return K2({
        name: 'AsyncComponentWrapper',
        __asyncLoader: h,
        get __asyncResolved() {
          return l
        },
        setup() {
          let p = gt
          if (l) return () => sm(l, p)
          let m = (E) => {
            ;(u = null), _r(E, p, 13, !i)
          }
          if ((a && p.suspense) || du)
            return h()
              .then((E) => () => sm(E, p))
              .catch((E) => (m(E), () => (i ? lt(i, { error: E }) : null)))
          let y = te.ref(!1),
            x = te.ref(),
            C = te.ref(!!r)
          return (
            r &&
              setTimeout(() => {
                C.value = !1
              }, r),
            n != null &&
              setTimeout(() => {
                if (!y.value && !x.value) {
                  let E = new Error(`Async component timed out after ${n}ms.`)
                  m(E), (x.value = E)
                }
              }, n),
            h()
              .then(() => {
                ;(y.value = !0),
                  p.parent &&
                    Ea(p.parent.vnode) &&
                    ((p.parent.effect.dirty = !0), Yo(p.parent.update))
              })
              .catch((E) => {
                m(E), (x.value = E)
              }),
            () => {
              if (y.value && l) return sm(l, p)
              if (x.value && i) return lt(i, { error: x.value })
              if (s && !C.value) return lt(s)
            }
          )
        },
      })
    }
    function sm(t, e) {
      let { ref: s, props: i, children: r, ce: n } = e.vnode,
        a = lt(t, i, r)
      return (a.ref = s), (a.ce = n), delete e.vnode.ce, a
    }
    var Ea = (t) => t.type.__isKeepAlive,
      dR = {
        name: 'KeepAlive',
        __isKeepAlive: !0,
        props: {
          include: [String, RegExp, Array],
          exclude: [String, RegExp, Array],
          max: [String, Number],
        },
        setup(t, { slots: e }) {
          let s = In(),
            i = s.ctx
          if (!i.renderer)
            return () => {
              let E = e.default && e.default()
              return E && E.length === 1 ? E[0] : E
            }
          let r = new Map(),
            n = new Set(),
            a = null
          s.__v_cache = r
          let o = s.suspense,
            {
              renderer: {
                p: u,
                m: l,
                um: c,
                o: { createElement: f },
              },
            } = i,
            h = f('div')
          ;(i.activate = (E, g, S, _, I) => {
            let k = E.component
            l(E, g, S, 0, o),
              u(k.vnode, E, g, S, k, o, _, E.slotScopeIds, I),
              wt(() => {
                ;(k.isDeactivated = !1), k.a && b.invokeArrayFns(k.a)
                let L = E.props && E.props.onVnodeMounted
                L && ls(L, k.parent, E)
              }, o),
              Y0(k)
          }),
            (i.deactivate = (E) => {
              let g = E.component
              _f(g.m),
                _f(g.a),
                l(E, h, null, 1, o),
                wt(() => {
                  g.da && b.invokeArrayFns(g.da)
                  let S = E.props && E.props.onVnodeUnmounted
                  S && ls(S, g.parent, E), (g.isDeactivated = !0)
                }, o),
                Y0(g)
            })
          function p(E) {
            im(E), c(E, s, o, !0)
          }
          function m(E) {
            r.forEach((g, S) => {
              let _ = yu(g.type)
              _ && (!E || !E(_)) && y(S)
            })
          }
          function y(E) {
            let g = r.get(E)
            !a || !Gs(g, a) ? p(g) : a && im(a), r.delete(E), n.delete(E)
          }
          cu(
            () => [t.include, t.exclude],
            ([E, g]) => {
              E && m((S) => iu(E, S)), g && m((S) => !iu(g, S))
            },
            { flush: 'post', deep: !0 }
          )
          let x = null,
            C = () => {
              x != null &&
                (_m(s.subTree.type)
                  ? wt(() => {
                      r.set(x, ff(s.subTree))
                    }, s.subTree.suspense)
                  : r.set(x, ff(s.subTree)))
            }
          return (
            pf(C),
            rm(C),
            df(() => {
              r.forEach((E) => {
                let { subTree: g, suspense: S } = s,
                  _ = ff(g)
                if (E.type === _.type && E.key === _.key) {
                  im(_)
                  let I = _.component.da
                  I && wt(I, S)
                  return
                }
                p(E)
              })
            }),
            () => {
              if (((x = null), !e.default)) return null
              let E = e.default(),
                g = E[0]
              if (E.length > 1)
                return (
                  Z('KeepAlive should contain exactly one component child.'),
                  (a = null),
                  E
                )
              if (!Bi(g) || (!(g.shapeFlag & 4) && !(g.shapeFlag & 128)))
                return (a = null), g
              let S = ff(g),
                _ = S.type,
                I = yu(Tn(S) ? S.type.__asyncResolved || {} : _),
                { include: k, exclude: L, max: N } = t
              if ((k && (!I || !iu(k, I))) || (L && I && iu(L, I)))
                return (a = S), g
              let O = S.key == null ? _ : S.key,
                v = r.get(O)
              return (
                S.el && ((S = Fs(S)), g.shapeFlag & 128 && (g.ssContent = S)),
                (x = O),
                v
                  ? ((S.el = v.el),
                    (S.component = v.component),
                    S.transition && ba(S, S.transition),
                    (S.shapeFlag |= 512),
                    n.delete(O),
                    n.add(O))
                  : (n.add(O),
                    N &&
                      n.size > parseInt(N, 10) &&
                      y(n.values().next().value)),
                (S.shapeFlag |= 256),
                (a = S),
                _m(g.type) ? g : S
              )
            }
          )
        },
      },
      mR = dR
    function iu(t, e) {
      return b.isArray(t)
        ? t.some((s) => iu(s, e))
        : b.isString(t)
        ? t.split(',').includes(e)
        : b.isRegExp(t)
        ? t.test(e)
        : !1
    }
    function X2(t, e) {
      W2(t, 'a', e)
    }
    function G2(t, e) {
      W2(t, 'da', e)
    }
    function W2(t, e, s = gt) {
      let i =
        t.__wdc ||
        (t.__wdc = () => {
          let r = s
          for (; r; ) {
            if (r.isDeactivated) return
            r = r.parent
          }
          return t()
        })
      if ((hf(e, i, s), s)) {
        let r = s.parent
        for (; r && r.parent; )
          Ea(r.parent.vnode) && gR(i, e, s, r), (r = r.parent)
      }
    }
    function gR(t, e, s, i) {
      let r = hf(e, t, i, !0)
      nm(() => {
        b.remove(i[e], r)
      }, s)
    }
    function im(t) {
      ;(t.shapeFlag &= ~256), (t.shapeFlag &= ~512)
    }
    function ff(t) {
      return t.shapeFlag & 128 ? t.ssContent : t
    }
    function hf(t, e, s = gt, i = !1) {
      if (s) {
        let r = s[t] || (s[t] = []),
          n =
            e.__weh ||
            (e.__weh = (...a) => {
              te.pauseTracking()
              let o = On(s),
                u = ks(e, s, t, a)
              return o(), te.resetTracking(), u
            })
        return i ? r.unshift(n) : r.push(n), n
      } else {
        let r = b.toHandlerKey(rf[t].replace(/ hook$/, ''))
        Z(
          `${r} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
        )
      }
    }
    var Li =
        (t) =>
        (e, s = gt) => {
          ;(!du || t === 'sp') && hf(t, (...i) => e(...i), s)
        },
      z2 = Li('bm'),
      pf = Li('m'),
      J2 = Li('bu'),
      rm = Li('u'),
      df = Li('bum'),
      nm = Li('um'),
      Y2 = Li('sp'),
      Q2 = Li('rtg'),
      Z2 = Li('rtc')
    function e_(t, e = gt) {
      hf('ec', t, e)
    }
    var mf = 'components',
      yR = 'directives'
    function bR(t, e) {
      return om(mf, t, !0, e) || t
    }
    var am = Symbol.for('v-ndc')
    function ER(t) {
      return b.isString(t) ? om(mf, t, !1) || t : t || am
    }
    function SR(t) {
      return om(yR, t)
    }
    function om(t, e, s = !0, i = !1) {
      let r = ht || gt
      if (r) {
        let n = r.type
        if (t === mf) {
          let o = yu(n, !1)
          if (
            o &&
            (o === e ||
              o === b.camelize(e) ||
              o === b.capitalize(b.camelize(e)))
          )
            return n
        }
        let a = t_(r[t] || n[t], e) || t_(r.appContext[t], e)
        if (!a && i) return n
        if (s && !a) {
          let o =
            t === mf
              ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.`
              : ''
          Z(`Failed to resolve ${t.slice(0, -1)}: ${e}${o}`)
        }
        return a
      } else
        Z(
          `resolve${b.capitalize(
            t.slice(0, -1)
          )} can only be used in render() or setup().`
        )
    }
    function t_(t, e) {
      return t && (t[e] || t[b.camelize(e)] || t[b.capitalize(b.camelize(e))])
    }
    function TR(t, e, s, i) {
      let r,
        n = s && s[i]
      if (b.isArray(t) || b.isString(t)) {
        r = new Array(t.length)
        for (let a = 0, o = t.length; a < o; a++)
          r[a] = e(t[a], a, void 0, n && n[a])
      } else if (typeof t == 'number') {
        Number.isInteger(t) ||
          Z(`The v-for range expect an integer value but got ${t}.`),
          (r = new Array(t))
        for (let a = 0; a < t; a++) r[a] = e(a + 1, a, void 0, n && n[a])
      } else if (b.isObject(t))
        if (t[Symbol.iterator])
          r = Array.from(t, (a, o) => e(a, o, void 0, n && n[o]))
        else {
          let a = Object.keys(t)
          r = new Array(a.length)
          for (let o = 0, u = a.length; o < u; o++) {
            let l = a[o]
            r[o] = e(t[l], l, o, n && n[o])
          }
        }
      else r = []
      return s && (s[i] = r), r
    }
    function _R(t, e) {
      for (let s = 0; s < e.length; s++) {
        let i = e[s]
        if (b.isArray(i))
          for (let r = 0; r < i.length; r++) t[i[r].name] = i[r].fn
        else
          i &&
            (t[i.name] = i.key
              ? (...r) => {
                  let n = i.fn(...r)
                  return n && (n.key = i.key), n
                }
              : i.fn)
      }
      return t
    }
    function xR(t, e, s = {}, i, r) {
      if (ht.isCE || (ht.parent && Tn(ht.parent) && ht.parent.isCE))
        return e !== 'default' && (s.name = e), lt('slot', s, i && i())
      let n = t[e]
      n &&
        n.length > 1 &&
        (Z(
          'SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.'
        ),
        (n = () => [])),
        n && n._c && (n._d = !1),
        Nf()
      let a = n && s_(n(s)),
        o = Pm(
          Vt,
          { key: (s.key || (a && a.key) || `_${e}`) + (!a && i ? '_fb' : '') },
          a || (i ? i() : []),
          a && t._ === 1 ? 64 : -2
        )
      return (
        !r && o.scopeId && (o.slotScopeIds = [o.scopeId + '-s']),
        n && n._c && (n._d = !0),
        o
      )
    }
    function s_(t) {
      return t.some((e) =>
        Bi(e) ? !(e.type === ut || (e.type === Vt && !s_(e.children))) : !0
      )
        ? t
        : null
    }
    function AR(t, e) {
      let s = {}
      if (!b.isObject(t))
        return Z('v-on with no argument expects an object value.'), s
      for (let i in t)
        s[e && /[A-Z]/.test(i) ? `on:${i}` : b.toHandlerKey(i)] = t[i]
      return s
    }
    var um = (t) => (t ? (tx(t) ? gu(t) : um(t.parent)) : null),
      _n = b.extend(Object.create(null), {
        $: (t) => t,
        $el: (t) => t.vnode.el,
        $data: (t) => t.data,
        $props: (t) => te.shallowReadonly(t.props),
        $attrs: (t) => te.shallowReadonly(t.attrs),
        $slots: (t) => te.shallowReadonly(t.slots),
        $refs: (t) => te.shallowReadonly(t.refs),
        $parent: (t) => um(t.parent),
        $root: (t) => um(t.root),
        $emit: (t) => t.emit,
        $options: (t) => hm(t),
        $forceUpdate: (t) =>
          t.f ||
          (t.f = () => {
            ;(t.effect.dirty = !0), Yo(t.update)
          }),
        $nextTick: (t) => t.n || (t.n = w2.bind(t.proxy)),
        $watch: (t) => AL.bind(t),
      }),
      lm = (t) => t === '_' || t === '$',
      cm = (t, e) => t !== b.EMPTY_OBJ && !t.__isScriptSetup && b.hasOwn(t, e),
      ru = {
        get({ _: t }, e) {
          if (e === '__v_skip') return !0
          let {
            ctx: s,
            setupState: i,
            data: r,
            props: n,
            accessCache: a,
            type: o,
            appContext: u,
          } = t
          if (e === '__isVue') return !0
          let l
          if (e[0] !== '$') {
            let p = a[e]
            if (p !== void 0)
              switch (p) {
                case 1:
                  return i[e]
                case 2:
                  return r[e]
                case 4:
                  return s[e]
                case 3:
                  return n[e]
              }
            else {
              if (cm(i, e)) return (a[e] = 1), i[e]
              if (r !== b.EMPTY_OBJ && b.hasOwn(r, e)) return (a[e] = 2), r[e]
              if ((l = t.propsOptions[0]) && b.hasOwn(l, e))
                return (a[e] = 3), n[e]
              if (s !== b.EMPTY_OBJ && b.hasOwn(s, e)) return (a[e] = 4), s[e]
              fm && (a[e] = 0)
            }
          }
          let c = _n[e],
            f,
            h
          if (c)
            return (
              e === '$attrs'
                ? (te.track(t.attrs, 'get', ''), Pf())
                : e === '$slots' && te.track(t, 'get', e),
              c(t)
            )
          if ((f = o.__cssModules) && (f = f[e])) return f
          if (s !== b.EMPTY_OBJ && b.hasOwn(s, e)) return (a[e] = 4), s[e]
          if (((h = u.config.globalProperties), b.hasOwn(h, e))) return h[e]
          ht &&
            (!b.isString(e) || e.indexOf('__v') !== 0) &&
            (r !== b.EMPTY_OBJ && lm(e[0]) && b.hasOwn(r, e)
              ? Z(
                  `Property ${JSON.stringify(
                    e
                  )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
                )
              : t === ht &&
                Z(
                  `Property ${JSON.stringify(
                    e
                  )} was accessed during render but is not defined on instance.`
                ))
        },
        set({ _: t }, e, s) {
          let { data: i, setupState: r, ctx: n } = t
          return cm(r, e)
            ? ((r[e] = s), !0)
            : r.__isScriptSetup && b.hasOwn(r, e)
            ? (Z(
                `Cannot mutate <script setup> binding "${e}" from Options API.`
              ),
              !1)
            : i !== b.EMPTY_OBJ && b.hasOwn(i, e)
            ? ((i[e] = s), !0)
            : b.hasOwn(t.props, e)
            ? (Z(`Attempting to mutate prop "${e}". Props are readonly.`), !1)
            : e[0] === '$' && e.slice(1) in t
            ? (Z(
                `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
              ),
              !1)
            : (e in t.appContext.config.globalProperties
                ? Object.defineProperty(n, e, {
                    enumerable: !0,
                    configurable: !0,
                    value: s,
                  })
                : (n[e] = s),
              !0)
        },
        has(
          {
            _: {
              data: t,
              setupState: e,
              accessCache: s,
              ctx: i,
              appContext: r,
              propsOptions: n,
            },
          },
          a
        ) {
          let o
          return (
            !!s[a] ||
            (t !== b.EMPTY_OBJ && b.hasOwn(t, a)) ||
            cm(e, a) ||
            ((o = n[0]) && b.hasOwn(o, a)) ||
            b.hasOwn(i, a) ||
            b.hasOwn(_n, a) ||
            b.hasOwn(r.config.globalProperties, a)
          )
        },
        defineProperty(t, e, s) {
          return (
            s.get != null
              ? (t._.accessCache[e] = 0)
              : b.hasOwn(s, 'value') && this.set(t, e, s.value, null),
            Reflect.defineProperty(t, e, s)
          )
        },
      }
    ru.ownKeys = (t) => (
      Z(
        'Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.'
      ),
      Reflect.ownKeys(t)
    )
    var PR = b.extend({}, ru, {
      get(t, e) {
        if (e !== Symbol.unscopables) return ru.get(t, e, t)
      },
      has(t, e) {
        let s = e[0] !== '_' && !b.isGloballyAllowed(e)
        return (
          !s &&
            ru.has(t, e) &&
            Z(
              `Property ${JSON.stringify(
                e
              )} should not start with _ which is a reserved prefix for Vue internals.`
            ),
          s
        )
      },
    })
    function CR(t) {
      let e = {}
      return (
        Object.defineProperty(e, '_', {
          configurable: !0,
          enumerable: !1,
          get: () => t,
        }),
        Object.keys(_n).forEach((s) => {
          Object.defineProperty(e, s, {
            configurable: !0,
            enumerable: !1,
            get: () => _n[s](t),
            set: b.NOOP,
          })
        }),
        e
      )
    }
    function vR(t) {
      let {
        ctx: e,
        propsOptions: [s],
      } = t
      s &&
        Object.keys(s).forEach((i) => {
          Object.defineProperty(e, i, {
            enumerable: !0,
            configurable: !0,
            get: () => t.props[i],
            set: b.NOOP,
          })
        })
    }
    function NR(t) {
      let { ctx: e, setupState: s } = t
      Object.keys(te.toRaw(s)).forEach((i) => {
        if (!s.__isScriptSetup) {
          if (lm(i[0])) {
            Z(
              `setup() return property ${JSON.stringify(
                i
              )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
            )
            return
          }
          Object.defineProperty(e, i, {
            enumerable: !0,
            configurable: !0,
            get: () => s[i],
            set: b.NOOP,
          })
        }
      })
    }
    var xn = (t) =>
      Z(
        `${t}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
      )
    function IR() {
      return xn('defineProps'), null
    }
    function OR() {
      return xn('defineEmits'), null
    }
    function wR(t) {
      xn('defineExpose')
    }
    function MR(t) {
      xn('defineOptions')
    }
    function RR() {
      return xn('defineSlots'), null
    }
    function LR() {
      xn('defineModel')
    }
    function kR(t, e) {
      return xn('withDefaults'), null
    }
    function DR() {
      return i_().slots
    }
    function FR() {
      return i_().attrs
    }
    function i_() {
      let t = In()
      return (
        t || Z('useContext() called without active instance.'),
        t.setupContext || (t.setupContext = nx(t))
      )
    }
    function nu(t) {
      return b.isArray(t) ? t.reduce((e, s) => ((e[s] = null), e), {}) : t
    }
    function BR(t, e) {
      let s = nu(t)
      for (let i in e) {
        if (i.startsWith('__skip')) continue
        let r = s[i]
        r
          ? b.isArray(r) || b.isFunction(r)
            ? (r = s[i] = { type: r, default: e[i] })
            : (r.default = e[i])
          : r === null
          ? (r = s[i] = { default: e[i] })
          : Z(`props default key "${i}" has no corresponding declaration.`),
          r && e[`__skip_${i}`] && (r.skipFactory = !0)
      }
      return s
    }
    function VR(t, e) {
      return !t || !e
        ? t || e
        : b.isArray(t) && b.isArray(e)
        ? t.concat(e)
        : b.extend({}, nu(t), nu(e))
    }
    function UR(t, e) {
      let s = {}
      for (let i in t)
        e.includes(i) ||
          Object.defineProperty(s, i, { enumerable: !0, get: () => t[i] })
      return s
    }
    function HR(t) {
      let e = In()
      e ||
        Z(
          'withAsyncContext called without active current instance. This is likely a bug.'
        )
      let s = t()
      return (
        wm(),
        b.isPromise(s) &&
          (s = s.catch((i) => {
            throw (On(e), i)
          })),
        [s, () => On(e)]
      )
    }
    function $R() {
      let t = Object.create(null)
      return (e, s) => {
        t[s]
          ? Z(`${e} property "${s}" is already defined in ${t[s]}.`)
          : (t[s] = e)
      }
    }
    var fm = !0
    function jR(t) {
      let e = hm(t),
        s = t.proxy,
        i = t.ctx
      ;(fm = !1), e.beforeCreate && r_(e.beforeCreate, t, 'bc')
      let {
          data: r,
          computed: n,
          methods: a,
          watch: o,
          provide: u,
          inject: l,
          created: c,
          beforeMount: f,
          mounted: h,
          beforeUpdate: p,
          updated: m,
          activated: y,
          deactivated: x,
          beforeDestroy: C,
          beforeUnmount: E,
          destroyed: g,
          unmounted: S,
          render: _,
          renderTracked: I,
          renderTriggered: k,
          errorCaptured: L,
          serverPrefetch: N,
          expose: O,
          inheritAttrs: v,
          components: A,
          directives: V,
          filters: se,
        } = e,
        Y = $R()
      {
        let [ee] = t.propsOptions
        if (ee) for (let z in ee) Y('Props', z)
      }
      if ((l && qR(l, i, Y), a))
        for (let ee in a) {
          let z = a[ee]
          b.isFunction(z)
            ? (Object.defineProperty(i, ee, {
                value: z.bind(s),
                configurable: !0,
                enumerable: !0,
                writable: !0,
              }),
              Y('Methods', ee))
            : Z(
                `Method "${ee}" has type "${typeof z}" in the component definition. Did you reference the function correctly?`
              )
        }
      if (r) {
        b.isFunction(r) ||
          Z(
            'The data option must be a function. Plain object usage is no longer supported.'
          )
        let ee = r.call(s, s)
        if (
          (b.isPromise(ee) &&
            Z(
              'data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.'
            ),
          !b.isObject(ee))
        )
          Z('data() should return an object.')
        else {
          t.data = te.reactive(ee)
          for (let z in ee)
            Y('Data', z),
              lm(z[0]) ||
                Object.defineProperty(i, z, {
                  configurable: !0,
                  enumerable: !0,
                  get: () => ee[z],
                  set: b.NOOP,
                })
        }
      }
      if (((fm = !0), n))
        for (let ee in n) {
          let z = n[ee],
            He = b.isFunction(z)
              ? z.bind(s, s)
              : b.isFunction(z.get)
              ? z.get.bind(s, s)
              : b.NOOP
          He === b.NOOP && Z(`Computed property "${ee}" has no getter.`)
          let St =
              !b.isFunction(z) && b.isFunction(z.set)
                ? z.set.bind(s)
                : () => {
                    Z(
                      `Write operation failed: computed property "${ee}" is readonly.`
                    )
                  },
            Ze = ox({ get: He, set: St })
          Object.defineProperty(i, ee, {
            enumerable: !0,
            configurable: !0,
            get: () => Ze.value,
            set: (rt) => (Ze.value = rt),
          }),
            Y('Computed', ee)
        }
      if (o) for (let ee in o) n_(o[ee], i, s, ee)
      if (u) {
        let ee = b.isFunction(u) ? u.call(s) : u
        Reflect.ownKeys(ee).forEach((z) => {
          l_(z, ee[z])
        })
      }
      c && r_(c, t, 'c')
      function q(ee, z) {
        b.isArray(z) ? z.forEach((He) => ee(He.bind(s))) : z && ee(z.bind(s))
      }
      if (
        (q(z2, f),
        q(pf, h),
        q(J2, p),
        q(rm, m),
        q(X2, y),
        q(G2, x),
        q(e_, L),
        q(Z2, I),
        q(Q2, k),
        q(df, E),
        q(nm, S),
        q(Y2, N),
        b.isArray(O))
      )
        if (O.length) {
          let ee = t.exposed || (t.exposed = {})
          O.forEach((z) => {
            Object.defineProperty(ee, z, {
              get: () => s[z],
              set: (He) => (s[z] = He),
            })
          })
        } else t.exposed || (t.exposed = {})
      _ && t.render === b.NOOP && (t.render = _),
        v != null && (t.inheritAttrs = v),
        A && (t.components = A),
        V && (t.directives = V)
    }
    function qR(t, e, s = b.NOOP) {
      b.isArray(t) && (t = pm(t))
      for (let i in t) {
        let r = t[i],
          n
        b.isObject(r)
          ? 'default' in r
            ? (n = ou(r.from || i, r.default, !0))
            : (n = ou(r.from || i))
          : (n = ou(r)),
          te.isRef(n)
            ? Object.defineProperty(e, i, {
                enumerable: !0,
                configurable: !0,
                get: () => n.value,
                set: (a) => (n.value = a),
              })
            : (e[i] = n),
          s('Inject', i)
      }
    }
    function r_(t, e, s) {
      ks(b.isArray(t) ? t.map((i) => i.bind(e.proxy)) : t.bind(e.proxy), e, s)
    }
    function n_(t, e, s, i) {
      let r = i.includes('.') ? B_(s, i) : () => s[i]
      if (b.isString(t)) {
        let n = e[t]
        b.isFunction(n)
          ? cu(r, n)
          : Z(`Invalid watch handler specified by key "${t}"`, n)
      } else if (b.isFunction(t)) cu(r, t.bind(s))
      else if (b.isObject(t))
        if (b.isArray(t)) t.forEach((n) => n_(n, e, s, i))
        else {
          let n = b.isFunction(t.handler) ? t.handler.bind(s) : e[t.handler]
          b.isFunction(n)
            ? cu(r, n, t)
            : Z(`Invalid watch handler specified by key "${t.handler}"`, n)
        }
      else Z(`Invalid watch option: "${i}"`, t)
    }
    function hm(t) {
      let e = t.type,
        { mixins: s, extends: i } = e,
        {
          mixins: r,
          optionsCache: n,
          config: { optionMergeStrategies: a },
        } = t.appContext,
        o = n.get(e),
        u
      return (
        o
          ? (u = o)
          : !r.length && !s && !i
          ? (u = e)
          : ((u = {}),
            r.length && r.forEach((l) => gf(u, l, a, !0)),
            gf(u, e, a)),
        b.isObject(e) && n.set(e, u),
        u
      )
    }
    function gf(t, e, s, i = !1) {
      let { mixins: r, extends: n } = e
      n && gf(t, n, s, !0), r && r.forEach((a) => gf(t, a, s, !0))
      for (let a in e)
        if (i && a === 'expose')
          Z(
            '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
          )
        else {
          let o = KR[a] || (s && s[a])
          t[a] = o ? o(t[a], e[a]) : e[a]
        }
      return t
    }
    var KR = {
      data: a_,
      props: o_,
      emits: o_,
      methods: au,
      computed: au,
      beforeCreate: ts,
      created: ts,
      beforeMount: ts,
      mounted: ts,
      beforeUpdate: ts,
      updated: ts,
      beforeDestroy: ts,
      beforeUnmount: ts,
      destroyed: ts,
      unmounted: ts,
      activated: ts,
      deactivated: ts,
      errorCaptured: ts,
      serverPrefetch: ts,
      components: au,
      directives: au,
      watch: GR,
      provide: a_,
      inject: XR,
    }
    function a_(t, e) {
      return e
        ? t
          ? function () {
              return b.extend(
                b.isFunction(t) ? t.call(this, this) : t,
                b.isFunction(e) ? e.call(this, this) : e
              )
            }
          : e
        : t
    }
    function XR(t, e) {
      return au(pm(t), pm(e))
    }
    function pm(t) {
      if (b.isArray(t)) {
        let e = {}
        for (let s = 0; s < t.length; s++) e[t[s]] = t[s]
        return e
      }
      return t
    }
    function ts(t, e) {
      return t ? [...new Set([].concat(t, e))] : e
    }
    function au(t, e) {
      return t ? b.extend(Object.create(null), t, e) : e
    }
    function o_(t, e) {
      return t
        ? b.isArray(t) && b.isArray(e)
          ? [...new Set([...t, ...e])]
          : b.extend(Object.create(null), nu(t), nu(e != null ? e : {}))
        : e
    }
    function GR(t, e) {
      if (!t) return e
      if (!e) return t
      let s = b.extend(Object.create(null), t)
      for (let i in e) s[i] = ts(t[i], e[i])
      return s
    }
    function u_() {
      return {
        app: null,
        config: {
          isNativeTag: b.NO,
          performance: !1,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {},
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap(),
      }
    }
    var WR = 0
    function zR(t, e) {
      return function (i, r = null) {
        b.isFunction(i) || (i = b.extend({}, i)),
          r != null &&
            !b.isObject(r) &&
            (Z('root props passed to app.mount() must be an object.'),
            (r = null))
        let n = u_(),
          a = new WeakSet(),
          o = !1,
          u = (n.app = {
            _uid: WR++,
            _component: i,
            _props: r,
            _container: null,
            _context: n,
            _instance: null,
            version: km,
            get config() {
              return n.config
            },
            set config(l) {
              Z(
                'app.config cannot be replaced. Modify individual options instead.'
              )
            },
            use(l, ...c) {
              return (
                a.has(l)
                  ? Z('Plugin has already been applied to target app.')
                  : l && b.isFunction(l.install)
                  ? (a.add(l), l.install(u, ...c))
                  : b.isFunction(l)
                  ? (a.add(l), l(u, ...c))
                  : Z(
                      'A plugin must either be a function or an object with an "install" function.'
                    ),
                u
              )
            },
            mixin(l) {
              return (
                n.mixins.includes(l)
                  ? Z(
                      'Mixin has already been applied to target app' +
                        (l.name ? `: ${l.name}` : '')
                    )
                  : n.mixins.push(l),
                u
              )
            },
            component(l, c) {
              return (
                Mm(l, n.config),
                c
                  ? (n.components[l] &&
                      Z(
                        `Component "${l}" has already been registered in target app.`
                      ),
                    (n.components[l] = c),
                    u)
                  : n.components[l]
              )
            },
            directive(l, c) {
              return (
                V2(l),
                c
                  ? (n.directives[l] &&
                      Z(
                        `Directive "${l}" has already been registered in target app.`
                      ),
                    (n.directives[l] = c),
                    u)
                  : n.directives[l]
              )
            },
            mount(l, c, f) {
              if (o)
                Z(
                  'App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`'
                )
              else {
                l.__vue_app__ &&
                  Z(
                    'There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.'
                  )
                let h = lt(i, r)
                return (
                  (h.appContext = n),
                  f === !0 ? (f = 'svg') : f === !1 && (f = void 0),
                  (n.reload = () => {
                    t(Fs(h), l, f)
                  }),
                  c && e ? e(h, l) : t(h, l, f),
                  (o = !0),
                  (u._container = l),
                  (l.__vue_app__ = u),
                  (u._instance = h.component),
                  eR(u, km),
                  gu(h.component)
                )
              }
            },
            unmount() {
              o
                ? (t(null, u._container),
                  (u._instance = null),
                  tR(u),
                  delete u._container.__vue_app__)
                : Z('Cannot unmount an app that is not mounted.')
            },
            provide(l, c) {
              return (
                l in n.provides &&
                  Z(
                    `App already provides property with key "${String(
                      l
                    )}". It will be overwritten with the new value.`
                  ),
                (n.provides[l] = c),
                u
              )
            },
            runWithContext(l) {
              let c = Sa
              Sa = u
              try {
                return l()
              } finally {
                Sa = c
              }
            },
          })
        return u
      }
    }
    var Sa = null
    function l_(t, e) {
      if (!gt) Z('provide() can only be used inside setup().')
      else {
        let s = gt.provides,
          i = gt.parent && gt.parent.provides
        i === s && (s = gt.provides = Object.create(i)), (s[t] = e)
      }
    }
    function ou(t, e, s = !1) {
      let i = gt || ht
      if (i || Sa) {
        let r = i
          ? i.parent == null
            ? i.vnode.appContext && i.vnode.appContext.provides
            : i.parent.provides
          : Sa._context.provides
        if (r && t in r) return r[t]
        if (arguments.length > 1)
          return s && b.isFunction(e) ? e.call(i && i.proxy) : e
        Z(`injection "${String(t)}" not found.`)
      } else
        Z('inject() can only be used inside setup() or functional components.')
    }
    function JR() {
      return !!(gt || ht || Sa)
    }
    var c_ = {},
      f_ = () => Object.create(c_),
      h_ = (t) => Object.getPrototypeOf(t) === c_
    function YR(t, e, s, i = !1) {
      let r = {},
        n = f_()
      ;(t.propsDefaults = Object.create(null)), p_(t, e, r, n)
      for (let a in t.propsOptions[0]) a in r || (r[a] = void 0)
      b_(e || {}, r, t),
        s
          ? (t.props = i ? r : te.shallowReactive(r))
          : t.type.props
          ? (t.props = r)
          : (t.props = n),
        (t.attrs = n)
    }
    function QR(t) {
      for (; t; ) {
        if (t.type.__hmrId) return !0
        t = t.parent
      }
    }
    function ZR(t, e, s, i) {
      let {
          props: r,
          attrs: n,
          vnode: { patchFlag: a },
        } = t,
        o = te.toRaw(r),
        [u] = t.propsOptions,
        l = !1
      if (!QR(t) && (i || a > 0) && !(a & 16)) {
        if (a & 8) {
          let c = t.vnode.dynamicProps
          for (let f = 0; f < c.length; f++) {
            let h = c[f]
            if (Af(t.emitsOptions, h)) continue
            let p = e[h]
            if (u)
              if (b.hasOwn(n, h)) p !== n[h] && ((n[h] = p), (l = !0))
              else {
                let m = b.camelize(h)
                r[m] = dm(u, o, m, p, t, !1)
              }
            else p !== n[h] && ((n[h] = p), (l = !0))
          }
        }
      } else {
        p_(t, e, r, n) && (l = !0)
        let c
        for (let f in o)
          (!e ||
            (!b.hasOwn(e, f) &&
              ((c = b.hyphenate(f)) === f || !b.hasOwn(e, c)))) &&
            (u
              ? s &&
                (s[f] !== void 0 || s[c] !== void 0) &&
                (r[f] = dm(u, o, f, void 0, t, !0))
              : delete r[f])
        if (n !== o)
          for (let f in n)
            (!e || (!b.hasOwn(e, f) && !0)) && (delete n[f], (l = !0))
      }
      l && te.trigger(t.attrs, 'set', ''), b_(e || {}, r, t)
    }
    function p_(t, e, s, i) {
      let [r, n] = t.propsOptions,
        a = !1,
        o
      if (e)
        for (let u in e) {
          if (b.isReservedProp(u)) continue
          let l = e[u],
            c
          r && b.hasOwn(r, (c = b.camelize(u)))
            ? !n || !n.includes(c)
              ? (s[c] = l)
              : ((o || (o = {}))[c] = l)
            : Af(t.emitsOptions, u) ||
              ((!(u in i) || l !== i[u]) && ((i[u] = l), (a = !0)))
        }
      if (n) {
        let u = te.toRaw(s),
          l = o || b.EMPTY_OBJ
        for (let c = 0; c < n.length; c++) {
          let f = n[c]
          s[f] = dm(r, u, f, l[f], t, !b.hasOwn(l, f))
        }
      }
      return a
    }
    function dm(t, e, s, i, r, n) {
      let a = t[s]
      if (a != null) {
        let o = b.hasOwn(a, 'default')
        if (o && i === void 0) {
          let u = a.default
          if (a.type !== Function && !a.skipFactory && b.isFunction(u)) {
            let { propsDefaults: l } = r
            if (s in l) i = l[s]
            else {
              let c = On(r)
              ;(i = l[s] = u.call(null, e)), c()
            }
          } else i = u
        }
        a[0] &&
          (n && !o
            ? (i = !1)
            : a[1] && (i === '' || i === b.hyphenate(s)) && (i = !0))
      }
      return i
    }
    var eL = new WeakMap()
    function d_(t, e, s = !1) {
      let i = s ? eL : e.propsCache,
        r = i.get(t)
      if (r) return r
      let n = t.props,
        a = {},
        o = [],
        u = !1
      if (!b.isFunction(t)) {
        let c = (f) => {
          u = !0
          let [h, p] = d_(f, e, !0)
          b.extend(a, h), p && o.push(...p)
        }
        !s && e.mixins.length && e.mixins.forEach(c),
          t.extends && c(t.extends),
          t.mixins && t.mixins.forEach(c)
      }
      if (!n && !u) return b.isObject(t) && i.set(t, b.EMPTY_ARR), b.EMPTY_ARR
      if (b.isArray(n))
        for (let c = 0; c < n.length; c++) {
          b.isString(n[c]) ||
            Z('props must be strings when using array syntax.', n[c])
          let f = b.camelize(n[c])
          m_(f) && (a[f] = b.EMPTY_OBJ)
        }
      else if (n) {
        b.isObject(n) || Z('invalid props options', n)
        for (let c in n) {
          let f = b.camelize(c)
          if (m_(f)) {
            let h = n[c],
              p = (a[f] =
                b.isArray(h) || b.isFunction(h) ? { type: h } : b.extend({}, h))
            if (p) {
              let m = y_(Boolean, p.type),
                y = y_(String, p.type)
              ;(p[0] = m > -1),
                (p[1] = y < 0 || m < y),
                (m > -1 || b.hasOwn(p, 'default')) && o.push(f)
            }
          }
        }
      }
      let l = [a, o]
      return b.isObject(t) && i.set(t, l), l
    }
    function m_(t) {
      return t[0] !== '$' && !b.isReservedProp(t)
        ? !0
        : (Z(`Invalid prop name: "${t}" is a reserved property.`), !1)
    }
    function mm(t) {
      return t === null
        ? 'null'
        : typeof t == 'function'
        ? t.name || ''
        : (typeof t == 'object' && t.constructor && t.constructor.name) || ''
    }
    function g_(t, e) {
      return mm(t) === mm(e)
    }
    function y_(t, e) {
      return b.isArray(e)
        ? e.findIndex((s) => g_(s, t))
        : b.isFunction(e) && g_(e, t)
        ? 0
        : -1
    }
    function b_(t, e, s) {
      let i = te.toRaw(e),
        r = s.propsOptions[0]
      for (let n in r) {
        let a = r[n]
        a != null &&
          tL(
            n,
            i[n],
            a,
            te.shallowReadonly(i),
            !b.hasOwn(t, n) && !b.hasOwn(t, b.hyphenate(n))
          )
      }
    }
    function tL(t, e, s, i, r) {
      let { type: n, required: a, validator: o, skipCheck: u } = s
      if (a && r) {
        Z('Missing required prop: "' + t + '"')
        return
      }
      if (!(e == null && !a)) {
        if (n != null && n !== !0 && !u) {
          let l = !1,
            c = b.isArray(n) ? n : [n],
            f = []
          for (let h = 0; h < c.length && !l; h++) {
            let { valid: p, expectedType: m } = iL(e, c[h])
            f.push(m || ''), (l = p)
          }
          if (!l) {
            Z(rL(t, e, f))
            return
          }
        }
        o &&
          !o(e, i) &&
          Z('Invalid prop: custom validator check failed for prop "' + t + '".')
      }
    }
    var sL = b.makeMap('String,Number,Boolean,Function,Symbol,BigInt')
    function iL(t, e) {
      let s,
        i = mm(e)
      if (sL(i)) {
        let r = typeof t
        ;(s = r === i.toLowerCase()),
          !s && r === 'object' && (s = t instanceof e)
      } else
        i === 'Object'
          ? (s = b.isObject(t))
          : i === 'Array'
          ? (s = b.isArray(t))
          : i === 'null'
          ? (s = t === null)
          : (s = t instanceof e)
      return { valid: s, expectedType: i }
    }
    function rL(t, e, s) {
      if (s.length === 0)
        return `Prop type [] for prop "${t}" won't match anything. Did you mean to use type Array instead?`
      let i = `Invalid prop: type check failed for prop "${t}". Expected ${s
          .map(b.capitalize)
          .join(' | ')}`,
        r = s[0],
        n = b.toRawType(e),
        a = E_(e, r),
        o = E_(e, n)
      return (
        s.length === 1 && S_(r) && !nL(r, n) && (i += ` with value ${a}`),
        (i += `, got ${n} `),
        S_(n) && (i += `with value ${o}.`),
        i
      )
    }
    function E_(t, e) {
      return e === 'String'
        ? `"${t}"`
        : e === 'Number'
        ? `${Number(t)}`
        : `${t}`
    }
    function S_(t) {
      return ['string', 'number', 'boolean'].some((s) => t.toLowerCase() === s)
    }
    function nL(...t) {
      return t.some((e) => e.toLowerCase() === 'boolean')
    }
    var T_ = (t) => t[0] === '_' || t === '$stable',
      gm = (t) => (b.isArray(t) ? t.map(ss) : [ss(t)]),
      aL = (t, e, s) => {
        if (e._n) return e
        let i = Z0(
          (...r) => (
            gt &&
              (!s || s.root === gt.root) &&
              Z(
                `Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
              ),
            gm(e(...r))
          ),
          s
        )
        return (i._c = !1), i
      },
      __ = (t, e, s) => {
        let i = t._ctx
        for (let r in t) {
          if (T_(r)) continue
          let n = t[r]
          if (b.isFunction(n)) e[r] = aL(r, n, i)
          else if (n != null) {
            Z(
              `Non-function value encountered for slot "${r}". Prefer function slots for better performance.`
            )
            let a = gm(n)
            e[r] = () => a
          }
        }
      },
      x_ = (t, e) => {
        Ea(t.vnode) ||
          Z(
            'Non-function value encountered for default slot. Prefer function slots for better performance.'
          )
        let s = gm(e)
        t.slots.default = () => s
      },
      ym = (t, e, s) => {
        for (let i in e) (s || i !== '_') && (t[i] = e[i])
      },
      oL = (t, e, s) => {
        let i = (t.slots = f_())
        if (t.vnode.shapeFlag & 32) {
          let r = e._
          r ? (ym(i, e, s), s && b.def(i, '_', r, !0)) : __(e, i)
        } else e && x_(t, e)
      },
      uL = (t, e, s) => {
        let { vnode: i, slots: r } = t,
          n = !0,
          a = b.EMPTY_OBJ
        if (i.shapeFlag & 32) {
          let o = e._
          o
            ? Ar
              ? (ym(r, e, s), te.trigger(t, 'set', '$slots'))
              : s && o === 1
              ? (n = !1)
              : ym(r, e, s)
            : ((n = !e.$stable), __(e, r)),
            (a = e)
        } else e && (x_(t, e), (a = { default: 1 }))
        if (n) for (let o in r) !T_(o) && a[o] == null && delete r[o]
      }
    function yf(t, e, s, i, r = !1) {
      if (b.isArray(t)) {
        t.forEach((h, p) => yf(h, e && (b.isArray(e) ? e[p] : e), s, i, r))
        return
      }
      if (Tn(i) && !r) return
      let n = i.shapeFlag & 4 ? gu(i.component) : i.el,
        a = r ? null : n,
        { i: o, r: u } = t
      if (!o) {
        Z(
          'Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.'
        )
        return
      }
      let l = e && e.r,
        c = o.refs === b.EMPTY_OBJ ? (o.refs = {}) : o.refs,
        f = o.setupState
      if (
        (l != null &&
          l !== u &&
          (b.isString(l)
            ? ((c[l] = null), b.hasOwn(f, l) && (f[l] = null))
            : te.isRef(l) && (l.value = null)),
        b.isFunction(u))
      )
        oi(u, o, 12, [a, c])
      else {
        let h = b.isString(u),
          p = te.isRef(u)
        if (h || p) {
          let m = () => {
            if (t.f) {
              let y = h ? (b.hasOwn(f, u) ? f[u] : c[u]) : u.value
              r
                ? b.isArray(y) && b.remove(y, n)
                : b.isArray(y)
                ? y.includes(n) || y.push(n)
                : h
                ? ((c[u] = [n]), b.hasOwn(f, u) && (f[u] = c[u]))
                : ((u.value = [n]), t.k && (c[t.k] = u.value))
            } else
              h
                ? ((c[u] = a), b.hasOwn(f, u) && (f[u] = a))
                : p
                ? ((u.value = a), t.k && (c[t.k] = a))
                : Z('Invalid template ref type:', u, `(${typeof u})`)
          }
          a ? ((m.id = -1), wt(m, s)) : m()
        } else Z('Invalid template ref type:', u, `(${typeof u})`)
      }
    }
    var A_ = Symbol('_vte'),
      lL = (t) => t.__isTeleport,
      An = (t) => t && (t.disabled || t.disabled === ''),
      P_ = (t) => typeof SVGElement != 'undefined' && t instanceof SVGElement,
      C_ = (t) =>
        typeof MathMLElement == 'function' && t instanceof MathMLElement,
      bm = (t, e) => {
        let s = t && t.to
        if (b.isString(s))
          if (e) {
            let i = e(s)
            return (
              !i &&
                !An(t) &&
                Z(
                  `Failed to locate Teleport target with selector "${s}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
                ),
              i
            )
          } else
            return (
              Z(
                'Current renderer does not support string target for Teleports. (missing querySelector renderer option)'
              ),
              null
            )
        else return !s && !An(t) && Z(`Invalid Teleport target: ${s}`), s
      },
      cL = {
        name: 'Teleport',
        __isTeleport: !0,
        process(t, e, s, i, r, n, a, o, u, l) {
          let {
              mc: c,
              pc: f,
              pbc: h,
              o: {
                insert: p,
                querySelector: m,
                createText: y,
                createComment: x,
              },
            } = l,
            C = An(e.props),
            { shapeFlag: E, children: g, dynamicChildren: S } = e
          if ((Ar && ((u = !1), (S = null)), t == null)) {
            let _ = (e.el = x('teleport start')),
              I = (e.anchor = x('teleport end')),
              k = (e.target = bm(e.props, m)),
              L = (e.targetStart = y('')),
              N = (e.targetAnchor = y(''))
            p(_, s, i),
              p(I, s, i),
              (L[A_] = N),
              k
                ? (p(L, k),
                  p(N, k),
                  a === 'svg' || P_(k)
                    ? (a = 'svg')
                    : (a === 'mathml' || C_(k)) && (a = 'mathml'))
                : C ||
                  Z('Invalid Teleport target on mount:', k, `(${typeof k})`)
            let O = (v, A) => {
              E & 16 && c(g, v, A, r, n, a, o, u)
            }
            C ? O(s, I) : k && O(k, N)
          } else {
            ;(e.el = t.el), (e.targetStart = t.targetStart)
            let _ = (e.anchor = t.anchor),
              I = (e.target = t.target),
              k = (e.targetAnchor = t.targetAnchor),
              L = An(t.props),
              N = L ? s : I,
              O = L ? _ : k
            if (
              (a === 'svg' || P_(I)
                ? (a = 'svg')
                : (a === 'mathml' || C_(I)) && (a = 'mathml'),
              S
                ? (h(t.dynamicChildren, S, N, r, n, a, o), Tf(t, e, !0))
                : u || f(t, e, N, O, r, n, a, o, !1),
              C)
            )
              L
                ? e.props &&
                  t.props &&
                  e.props.to !== t.props.to &&
                  (e.props.to = t.props.to)
                : bf(e, s, _, l, 1)
            else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
              let v = (e.target = bm(e.props, m))
              v
                ? bf(e, v, null, l, 0)
                : Z('Invalid Teleport target on update:', I, `(${typeof I})`)
            } else L && bf(e, I, k, l, 1)
          }
          v_(e)
        },
        remove(t, e, s, { um: i, o: { remove: r } }, n) {
          let {
            shapeFlag: a,
            children: o,
            anchor: u,
            targetStart: l,
            targetAnchor: c,
            target: f,
            props: h,
          } = t
          if ((f && (r(l), r(c)), n && r(u), a & 16)) {
            let p = n || !An(h)
            for (let m = 0; m < o.length; m++) {
              let y = o[m]
              i(y, e, s, p, !!y.dynamicChildren)
            }
          }
        },
        move: bf,
        hydrate: fL,
      }
    function bf(t, e, s, { o: { insert: i }, m: r }, n = 2) {
      n === 0 && i(t.targetAnchor, e, s)
      let { el: a, anchor: o, shapeFlag: u, children: l, props: c } = t,
        f = n === 2
      if ((f && i(a, e, s), (!f || An(c)) && u & 16))
        for (let h = 0; h < l.length; h++) r(l[h], e, s, 2)
      f && i(o, e, s)
    }
    function fL(
      t,
      e,
      s,
      i,
      r,
      n,
      { o: { nextSibling: a, parentNode: o, querySelector: u } },
      l
    ) {
      let c = (e.target = bm(e.props, u))
      if (c) {
        let f = c._lpa || c.firstChild
        if (e.shapeFlag & 16)
          if (An(e.props))
            (e.anchor = l(a(t), e, o(t), s, i, r, n)), (e.targetAnchor = f)
          else {
            e.anchor = a(t)
            let h = f
            for (; h; )
              if (
                ((h = a(h)),
                h && h.nodeType === 8 && h.data === 'teleport anchor')
              ) {
                ;(e.targetAnchor = h),
                  (c._lpa = e.targetAnchor && a(e.targetAnchor))
                break
              }
            l(f, e, c, s, i, r, n)
          }
        v_(e)
      }
      return e.anchor && a(e.anchor)
    }
    var hL = cL
    function v_(t) {
      let e = t.ctx
      if (e && e.ut) {
        let s = t.children[0].el
        for (; s && s !== t.targetAnchor; )
          s.nodeType === 1 && s.setAttribute('data-v-owner', e.uid),
            (s = s.nextSibling)
        e.ut()
      }
    }
    var N_ = !1,
      Pn = () => {
        N_ ||
          (console.error('Hydration completed but contains mismatches.'),
          (N_ = !0))
      },
      pL = (t) =>
        t.namespaceURI.includes('svg') && t.tagName !== 'foreignObject',
      dL = (t) => t.namespaceURI.includes('MathML'),
      Ef = (t) => {
        if (pL(t)) return 'svg'
        if (dL(t)) return 'mathml'
      },
      uu = (t) => t.nodeType === 8
    function mL(t) {
      let {
          mt: e,
          p: s,
          o: {
            patchProp: i,
            createText: r,
            nextSibling: n,
            parentNode: a,
            remove: o,
            insert: u,
            createComment: l,
          },
        } = t,
        c = (g, S) => {
          if (!S.hasChildNodes()) {
            Z(
              'Attempting to hydrate existing markup but container is empty. Performing full mount instead.'
            ),
              s(null, g, S),
              nf(),
              (S._vnode = g)
            return
          }
          f(S.firstChild, g, null, null, null), nf(), (S._vnode = g)
        },
        f = (g, S, _, I, k, L = !1) => {
          L = L || !!S.dynamicChildren
          let N = uu(g) && g.data === '[',
            O = () => y(g, S, _, I, k, N),
            { type: v, ref: A, shapeFlag: V, patchFlag: se } = S,
            Y = g.nodeType
          ;(S.el = g),
            b.def(g, '__vnode', S, !0),
            b.def(g, '__vueParentComponent', _, !0),
            se === -2 && ((L = !1), (S.dynamicChildren = null))
          let q = null
          switch (v) {
            case Fi:
              Y !== 3
                ? S.children === ''
                  ? (u((S.el = r('')), a(g), g), (q = g))
                  : (q = O())
                : (g.data !== S.children &&
                    (Z(
                      'Hydration text mismatch in',
                      g.parentNode,
                      `
  - rendered on server: ${JSON.stringify(g.data)}
  - expected on client: ${JSON.stringify(S.children)}`
                    ),
                    Pn(),
                    (g.data = S.children)),
                  (q = n(g)))
              break
            case ut:
              E(g)
                ? ((q = n(g)), C((S.el = g.content.firstChild), g, _))
                : Y !== 8 || N
                ? (q = O())
                : (q = n(g))
              break
            case vn:
              if ((N && ((g = n(g)), (Y = g.nodeType)), Y === 1 || Y === 3)) {
                q = g
                let ee = !S.children.length
                for (let z = 0; z < S.staticCount; z++)
                  ee && (S.children += q.nodeType === 1 ? q.outerHTML : q.data),
                    z === S.staticCount - 1 && (S.anchor = q),
                    (q = n(q))
                return N ? n(q) : q
              } else O()
              break
            case Vt:
              N ? (q = m(g, S, _, I, k, L)) : (q = O())
              break
            default:
              if (V & 1)
                (Y !== 1 || S.type.toLowerCase() !== g.tagName.toLowerCase()) &&
                !E(g)
                  ? (q = O())
                  : (q = h(g, S, _, I, k, L))
              else if (V & 6) {
                S.slotScopeIds = k
                let ee = a(g)
                if (
                  (N
                    ? (q = x(g))
                    : uu(g) && g.data === 'teleport start'
                    ? (q = x(g, g.data, 'teleport end'))
                    : (q = n(g)),
                  e(S, ee, null, _, I, Ef(ee), L),
                  Tn(S))
                ) {
                  let z
                  N
                    ? ((z = lt(Vt)),
                      (z.anchor = q ? q.previousSibling : ee.lastChild))
                    : (z = g.nodeType === 3 ? Nm('') : lt('div')),
                    (z.el = g),
                    (S.component.subTree = z)
                }
              } else
                V & 64
                  ? Y !== 8
                    ? (q = O())
                    : (q = S.type.hydrate(g, S, _, I, k, L, t, p))
                  : V & 128
                  ? (q = S.type.hydrate(g, S, _, I, Ef(a(g)), k, L, t, f))
                  : Z('Invalid HostVNode type:', v, `(${typeof v})`)
          }
          return A != null && yf(A, null, I, S), q
        },
        h = (g, S, _, I, k, L) => {
          L = L || !!S.dynamicChildren
          let {
              type: N,
              props: O,
              patchFlag: v,
              shapeFlag: A,
              dirs: V,
              transition: se,
            } = S,
            Y = N === 'input' || N === 'option'
          {
            V && li(S, null, _, 'created')
            let q = !1
            if (E(g)) {
              q = R_(I, se) && _ && _.vnode.props && _.vnode.props.appear
              let z = g.content.firstChild
              q && se.beforeEnter(z), C(z, g, _), (S.el = g = z)
            }
            if (A & 16 && !(O && (O.innerHTML || O.textContent))) {
              let z = p(g.firstChild, S, g, _, I, k, L),
                He = !1
              for (; z; ) {
                He ||
                  (Z(
                    'Hydration children mismatch on',
                    g,
                    `
Server rendered element contains more child nodes than client vdom.`
                  ),
                  (He = !0)),
                  Pn()
                let St = z
                ;(z = z.nextSibling), o(St)
              }
            } else
              A & 8 &&
                g.textContent !== S.children &&
                (Z(
                  'Hydration text content mismatch on',
                  g,
                  `
  - rendered on server: ${g.textContent}
  - expected on client: ${S.children}`
                ),
                Pn(),
                (g.textContent = S.children))
            if (O)
              for (let z in O)
                !(V && V.some((He) => He.dir.created)) &&
                  gL(g, z, O[z], S, _) &&
                  Pn(),
                  ((Y && (z.endsWith('value') || z === 'indeterminate')) ||
                    (b.isOn(z) && !b.isReservedProp(z)) ||
                    z[0] === '.') &&
                    i(g, z, null, O[z], void 0, _)
            let ee
            ;(ee = O && O.onVnodeBeforeMount) && ls(ee, _, S),
              V && li(S, null, _, 'beforeMount'),
              ((ee = O && O.onVnodeMounted) || V || q) &&
                G_(() => {
                  ee && ls(ee, _, S),
                    q && se.enter(g),
                    V && li(S, null, _, 'mounted')
                }, I)
          }
          return g.nextSibling
        },
        p = (g, S, _, I, k, L, N) => {
          N = N || !!S.dynamicChildren
          let O = S.children,
            v = O.length,
            A = !1
          for (let V = 0; V < v; V++) {
            let se = N ? O[V] : (O[V] = ss(O[V])),
              Y = se.type === Fi
            if (g) {
              if (Y && !N) {
                let q = O[V + 1]
                q &&
                  (q = ss(q)).type === Fi &&
                  (u(r(g.data.slice(se.children.length)), _, n(g)),
                  (g.data = se.children))
              }
              g = f(g, se, I, k, L, N)
            } else
              Y && !se.children
                ? u((se.el = r('')), _)
                : (A ||
                    (Z(
                      'Hydration children mismatch on',
                      _,
                      `
Server rendered element contains fewer child nodes than client vdom.`
                    ),
                    (A = !0)),
                  Pn(),
                  s(null, se, _, null, I, k, Ef(_), L))
          }
          return g
        },
        m = (g, S, _, I, k, L) => {
          let { slotScopeIds: N } = S
          N && (k = k ? k.concat(N) : N)
          let O = a(g),
            v = p(n(g), S, O, _, I, k, L)
          return v && uu(v) && v.data === ']'
            ? n((S.anchor = v))
            : (Pn(), u((S.anchor = l(']')), O, v), v)
        },
        y = (g, S, _, I, k, L) => {
          if (
            (Z(
              `Hydration node mismatch:
- rendered on server:`,
              g,
              g.nodeType === 3
                ? '(text)'
                : uu(g) && g.data === '['
                ? '(start of fragment)'
                : '',
              `
- expected on client:`,
              S.type
            ),
            Pn(),
            (S.el = null),
            L)
          ) {
            let v = x(g)
            for (;;) {
              let A = n(g)
              if (A && A !== v) o(A)
              else break
            }
          }
          let N = n(g),
            O = a(g)
          return o(g), s(null, S, O, N, _, I, Ef(O), k), N
        },
        x = (g, S = '[', _ = ']') => {
          let I = 0
          for (; g; )
            if (
              ((g = n(g)), g && uu(g) && (g.data === S && I++, g.data === _))
            ) {
              if (I === 0) return n(g)
              I--
            }
          return g
        },
        C = (g, S, _) => {
          let I = S.parentNode
          I && I.replaceChild(g, S)
          let k = _
          for (; k; )
            k.vnode.el === S && (k.vnode.el = k.subTree.el = g), (k = k.parent)
        },
        E = (g) => g.nodeType === 1 && g.tagName.toLowerCase() === 'template'
      return [c, f]
    }
    function gL(t, e, s, i, r) {
      let n, a, o, u
      if (e === 'class')
        (o = t.getAttribute('class')),
          (u = b.normalizeClass(s)),
          yL(I_(o || ''), I_(u)) || (n = a = 'class')
      else if (e === 'style') {
        ;(o = t.getAttribute('style') || ''),
          (u = b.isString(s) ? s : b.stringifyStyle(b.normalizeStyle(s)))
        let l = O_(o),
          c = O_(u)
        if (i.dirs)
          for (let { dir: f, value: h } of i.dirs)
            f.name === 'show' && !h && c.set('display', 'none')
        r && w_(r, i, c), bL(l, c) || (n = a = 'style')
      } else
        ((t instanceof SVGElement && b.isKnownSvgAttr(e)) ||
          (t instanceof HTMLElement &&
            (b.isBooleanAttr(e) || b.isKnownHtmlAttr(e)))) &&
          (b.isBooleanAttr(e)
            ? ((o = t.hasAttribute(e)), (u = b.includeBooleanAttr(s)))
            : s == null
            ? ((o = t.hasAttribute(e)), (u = !1))
            : (t.hasAttribute(e)
                ? (o = t.getAttribute(e))
                : e === 'value' && t.tagName === 'TEXTAREA'
                ? (o = t.value)
                : (o = !1),
              (u = b.isRenderableAttrValue(s) ? String(s) : !1)),
          o !== u && ((n = 'attribute'), (a = e)))
      if (n) {
        let l = (h) => (h === !1 ? '(not rendered)' : `${a}="${h}"`),
          c = `Hydration ${n} mismatch on`,
          f = `
  - rendered on server: ${l(o)}
  - expected on client: ${l(u)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`
        return Z(c, t, f), !0
      }
      return !1
    }
    function I_(t) {
      return new Set(t.trim().split(/\s+/))
    }
    function yL(t, e) {
      if (t.size !== e.size) return !1
      for (let s of t) if (!e.has(s)) return !1
      return !0
    }
    function O_(t) {
      let e = new Map()
      for (let s of t.split(';')) {
        let [i, r] = s.split(':')
        ;(i = i.trim()), (r = r && r.trim()), i && r && e.set(i, r)
      }
      return e
    }
    function bL(t, e) {
      if (t.size !== e.size) return !1
      for (let [s, i] of t) if (i !== e.get(s)) return !1
      return !0
    }
    function w_(t, e, s) {
      let i = t.subTree
      if (
        t.getCssVars &&
        (e === i || (i && i.type === Vt && i.children.includes(e)))
      ) {
        let r = t.getCssVars()
        for (let n in r) s.set(`--${n}`, String(r[n]))
      }
      e === i && t.parent && w_(t.parent, t.vnode, s)
    }
    var lu, Cr
    function ki(t, e) {
      t.appContext.config.performance && Sf() && Cr.mark(`vue-${e}-${t.uid}`),
        rR(t, e, Sf() ? Cr.now() : Date.now())
    }
    function Di(t, e) {
      if (t.appContext.config.performance && Sf()) {
        let s = `vue-${e}-${t.uid}`,
          i = s + ':end'
        Cr.mark(i),
          Cr.measure(`<${wf(t, t.type)}> ${e}`, s, i),
          Cr.clearMarks(s),
          Cr.clearMarks(i)
      }
      nR(t, e, Sf() ? Cr.now() : Date.now())
    }
    function Sf() {
      return (
        lu !== void 0 ||
          (typeof window != 'undefined' && window.performance
            ? ((lu = !0), (Cr = window.performance))
            : (lu = !1)),
        lu
      )
    }
    var wt = G_
    function EL(t) {
      return M_(t)
    }
    function SL(t) {
      return M_(t, mL)
    }
    function M_(t, e) {
      let s = b.getGlobalThis()
      ;(s.__VUE__ = !0), J0(s.__VUE_DEVTOOLS_GLOBAL_HOOK__, s)
      let {
          insert: i,
          remove: r,
          patchProp: n,
          createElement: a,
          createText: o,
          createComment: u,
          setText: l,
          setElementText: c,
          parentNode: f,
          nextSibling: h,
          setScopeId: p = b.NOOP,
          insertStaticContent: m,
        } = t,
        y = (
          d,
          T,
          M,
          D = null,
          F = null,
          U = null,
          j = void 0,
          $ = null,
          B = Ar ? !1 : !!T.dynamicChildren
        ) => {
          if (d === T) return
          d && !Gs(d, T) && ((D = Xi(d)), Us(d, F, U, !0), (d = null)),
            T.patchFlag === -2 && ((B = !1), (T.dynamicChildren = null))
          let { type: H, ref: J, shapeFlag: Q } = T
          switch (H) {
            case Fi:
              x(d, T, M, D)
              break
            case ut:
              C(d, T, M, D)
              break
            case vn:
              d == null ? E(T, M, D, j) : g(d, T, M, j)
              break
            case Vt:
              V(d, T, M, D, F, U, j, $, B)
              break
            default:
              Q & 1
                ? I(d, T, M, D, F, U, j, $, B)
                : Q & 6
                ? se(d, T, M, D, F, U, j, $, B)
                : Q & 64 || Q & 128
                ? H.process(d, T, M, D, F, U, j, $, B, zs)
                : Z('Invalid VNode type:', H, `(${typeof H})`)
          }
          J != null && F && yf(J, d && d.ref, U, T || d, !T)
        },
        x = (d, T, M, D) => {
          if (d == null) i((T.el = o(T.children)), M, D)
          else {
            let F = (T.el = d.el)
            T.children !== d.children && l(F, T.children)
          }
        },
        C = (d, T, M, D) => {
          d == null ? i((T.el = u(T.children || '')), M, D) : (T.el = d.el)
        },
        E = (d, T, M, D) => {
          ;[d.el, d.anchor] = m(d.children, T, M, D, d.el, d.anchor)
        },
        g = (d, T, M, D) => {
          if (T.children !== d.children) {
            let F = h(d.anchor)
            _(d), ([T.el, T.anchor] = m(T.children, M, F, D))
          } else (T.el = d.el), (T.anchor = d.anchor)
        },
        S = ({ el: d, anchor: T }, M, D) => {
          let F
          for (; d && d !== T; ) (F = h(d)), i(d, M, D), (d = F)
          i(T, M, D)
        },
        _ = ({ el: d, anchor: T }) => {
          let M
          for (; d && d !== T; ) (M = h(d)), r(d), (d = M)
          r(T)
        },
        I = (d, T, M, D, F, U, j, $, B) => {
          T.type === 'svg' ? (j = 'svg') : T.type === 'math' && (j = 'mathml'),
            d == null ? k(T, M, D, F, U, j, $, B) : O(d, T, F, U, j, $, B)
        },
        k = (d, T, M, D, F, U, j, $) => {
          let B,
            H,
            { props: J, shapeFlag: Q, transition: ie, dirs: ne } = d
          if (
            ((B = d.el = a(d.type, U, J && J.is, J)),
            Q & 8
              ? c(B, d.children)
              : Q & 16 && N(d.children, B, null, D, F, Em(d, U), j, $),
            ne && li(d, null, D, 'created'),
            L(B, d, d.scopeId, j, D),
            J)
          ) {
            for (let ye in J)
              ye !== 'value' &&
                !b.isReservedProp(ye) &&
                n(B, ye, null, J[ye], U, D)
            'value' in J && n(B, 'value', null, J.value, U),
              (H = J.onVnodeBeforeMount) && ls(H, D, d)
          }
          b.def(B, '__vnode', d, !0),
            b.def(B, '__vueParentComponent', D, !0),
            ne && li(d, null, D, 'beforeMount')
          let de = R_(F, ie)
          de && ie.beforeEnter(B),
            i(B, T, M),
            ((H = J && J.onVnodeMounted) || de || ne) &&
              wt(() => {
                H && ls(H, D, d),
                  de && ie.enter(B),
                  ne && li(d, null, D, 'mounted')
              }, F)
        },
        L = (d, T, M, D, F) => {
          if ((M && p(d, M), D)) for (let U = 0; U < D.length; U++) p(d, D[U])
          if (F) {
            let U = F.subTree
            if (
              (U.patchFlag > 0 &&
                U.patchFlag & 2048 &&
                (U = vf(U.children) || U),
              T === U)
            ) {
              let j = F.vnode
              L(d, j, j.scopeId, j.slotScopeIds, F.parent)
            }
          }
        },
        N = (d, T, M, D, F, U, j, $, B = 0) => {
          for (let H = B; H < d.length; H++) {
            let J = (d[H] = $ ? Nr(d[H]) : ss(d[H]))
            y(null, J, T, M, D, F, U, j, $)
          }
        },
        O = (d, T, M, D, F, U, j) => {
          let $ = (T.el = d.el)
          $.__vnode = T
          let { patchFlag: B, dynamicChildren: H, dirs: J } = T
          B |= d.patchFlag & 16
          let Q = d.props || b.EMPTY_OBJ,
            ie = T.props || b.EMPTY_OBJ,
            ne
          if (
            (M && Cn(M, !1),
            (ne = ie.onVnodeBeforeUpdate) && ls(ne, M, T, d),
            J && li(T, d, M, 'beforeUpdate'),
            M && Cn(M, !0),
            Ar && ((B = 0), (j = !1), (H = null)),
            ((Q.innerHTML && ie.innerHTML == null) ||
              (Q.textContent && ie.textContent == null)) &&
              c($, ''),
            H
              ? (v(d.dynamicChildren, H, $, M, D, Em(T, F), U), Tf(d, T))
              : j || He(d, T, $, null, M, D, Em(T, F), U, !1),
            B > 0)
          ) {
            if (B & 16) A($, Q, ie, M, F)
            else if (
              (B & 2 &&
                Q.class !== ie.class &&
                n($, 'class', null, ie.class, F),
              B & 4 && n($, 'style', Q.style, ie.style, F),
              B & 8)
            ) {
              let de = T.dynamicProps
              for (let ye = 0; ye < de.length; ye++) {
                let Ee = de[ye],
                  $e = Q[Ee],
                  Pt = ie[Ee]
                ;(Pt !== $e || Ee === 'value') && n($, Ee, $e, Pt, F, M)
              }
            }
            B & 1 && d.children !== T.children && c($, T.children)
          } else !j && H == null && A($, Q, ie, M, F)
          ;((ne = ie.onVnodeUpdated) || J) &&
            wt(() => {
              ne && ls(ne, M, T, d), J && li(T, d, M, 'updated')
            }, D)
        },
        v = (d, T, M, D, F, U, j) => {
          for (let $ = 0; $ < T.length; $++) {
            let B = d[$],
              H = T[$],
              J =
                B.el && (B.type === Vt || !Gs(B, H) || B.shapeFlag & (6 | 64))
                  ? f(B.el)
                  : M
            y(B, H, J, null, D, F, U, j, !0)
          }
        },
        A = (d, T, M, D, F) => {
          if (T !== M) {
            if (T !== b.EMPTY_OBJ)
              for (let U in T)
                !b.isReservedProp(U) && !(U in M) && n(d, U, T[U], null, F, D)
            for (let U in M) {
              if (b.isReservedProp(U)) continue
              let j = M[U],
                $ = T[U]
              j !== $ && U !== 'value' && n(d, U, $, j, F, D)
            }
            'value' in M && n(d, 'value', T.value, M.value, F)
          }
        },
        V = (d, T, M, D, F, U, j, $, B) => {
          let H = (T.el = d ? d.el : o('')),
            J = (T.anchor = d ? d.anchor : o('')),
            { patchFlag: Q, dynamicChildren: ie, slotScopeIds: ne } = T
          ;(Ar || Q & 2048) && ((Q = 0), (B = !1), (ie = null)),
            ne && ($ = $ ? $.concat(ne) : ne),
            d == null
              ? (i(H, M, D),
                i(J, M, D),
                N(T.children || [], M, J, F, U, j, $, B))
              : Q > 0 && Q & 64 && ie && d.dynamicChildren
              ? (v(d.dynamicChildren, ie, M, F, U, j, $), Tf(d, T))
              : He(d, T, M, J, F, U, j, $, B)
        },
        se = (d, T, M, D, F, U, j, $, B) => {
          ;(T.slotScopeIds = $),
            d == null
              ? T.shapeFlag & 512
                ? F.ctx.activate(T, M, D, j, B)
                : Y(T, M, D, F, U, j, B)
              : q(d, T, B)
        },
        Y = (d, T, M, D, F, U, j) => {
          let $ = (d.component = ex(d, D, F))
          if (
            ($.type.__hmrId && J8($),
            Wo(d),
            ki($, 'mount'),
            Ea(d) && ($.ctx.renderer = zs),
            ki($, 'init'),
            sx($, !1, j),
            Di($, 'init'),
            $.asyncDep)
          ) {
            if ((F && F.registerDep($, ee, j), !d.el)) {
              let B = ($.subTree = lt(ut))
              C(null, B, T, M)
            }
          } else ee($, d, T, M, F, U, j)
          zo(), Di($, 'mount')
        },
        q = (d, T, M) => {
          let D = (T.component = d.component)
          if (IL(d, T, M))
            if (D.asyncDep && !D.asyncResolved) {
              Wo(T), z(D, T, M), zo()
              return
            } else (D.next = T), W8(D.update), (D.effect.dirty = !0), D.update()
          else (T.el = d.el), (D.vnode = T)
        },
        ee = (d, T, M, D, F, U, j) => {
          let $ = () => {
              if (d.isMounted) {
                let { next: J, bu: Q, u: ie, parent: ne, vnode: de } = d
                {
                  let fi = L_(d)
                  if (fi) {
                    J && ((J.el = de.el), z(d, J, j)),
                      fi.asyncDep.then(() => {
                        d.isUnmounted || $()
                      })
                    return
                  }
                }
                let ye = J,
                  Ee
                Wo(J || d.vnode),
                  Cn(d, !1),
                  J ? ((J.el = de.el), z(d, J, j)) : (J = de),
                  Q && b.invokeArrayFns(Q),
                  (Ee = J.props && J.props.onVnodeBeforeUpdate) &&
                    ls(Ee, ne, J, de),
                  Cn(d, !0),
                  ki(d, 'render')
                let $e = Cf(d)
                Di(d, 'render')
                let Pt = d.subTree
                ;(d.subTree = $e),
                  ki(d, 'patch'),
                  y(Pt, $e, f(Pt.el), Xi(Pt), d, F, U),
                  Di(d, 'patch'),
                  (J.el = $e.el),
                  ye === null && Tm(d, $e.el),
                  ie && wt(ie, F),
                  (Ee = J.props && J.props.onVnodeUpdated) &&
                    wt(() => ls(Ee, ne, J, de), F),
                  F2(d),
                  zo()
              } else {
                let J,
                  { el: Q, props: ie } = T,
                  { bm: ne, m: de, parent: ye } = d,
                  Ee = Tn(T)
                if (
                  (Cn(d, !1),
                  ne && b.invokeArrayFns(ne),
                  !Ee && (J = ie && ie.onVnodeBeforeMount) && ls(J, ye, T),
                  Cn(d, !0),
                  Q && w)
                ) {
                  let $e = () => {
                    ki(d, 'render'),
                      (d.subTree = Cf(d)),
                      Di(d, 'render'),
                      ki(d, 'hydrate'),
                      w(Q, d.subTree, d, F, null),
                      Di(d, 'hydrate')
                  }
                  Ee
                    ? T.type.__asyncLoader().then(() => !d.isUnmounted && $e())
                    : $e()
                } else {
                  ki(d, 'render')
                  let $e = (d.subTree = Cf(d))
                  Di(d, 'render'),
                    ki(d, 'patch'),
                    y(null, $e, M, D, d, F, U),
                    Di(d, 'patch'),
                    (T.el = $e.el)
                }
                if ((de && wt(de, F), !Ee && (J = ie && ie.onVnodeMounted))) {
                  let $e = T
                  wt(() => ls(J, ye, $e), F)
                }
                ;(T.shapeFlag & 256 ||
                  (ye && Tn(ye.vnode) && ye.vnode.shapeFlag & 256)) &&
                  d.a &&
                  wt(d.a, F),
                  (d.isMounted = !0),
                  Y0(d),
                  (T = M = D = null)
              }
            },
            B = (d.effect = new te.ReactiveEffect(
              $,
              b.NOOP,
              () => Yo(H),
              d.scope
            )),
            H = (d.update = () => {
              B.dirty && B.run()
            })
          ;(H.i = d),
            (H.id = d.uid),
            Cn(d, !0),
            (B.onTrack = d.rtc ? (J) => b.invokeArrayFns(d.rtc, J) : void 0),
            (B.onTrigger = d.rtg ? (J) => b.invokeArrayFns(d.rtg, J) : void 0),
            H()
        },
        z = (d, T, M) => {
          T.component = d
          let D = d.vnode.props
          ;(d.vnode = T),
            (d.next = null),
            ZR(d, T.props, D, M),
            uL(d, T.children, M),
            te.pauseTracking(),
            R2(d),
            te.resetTracking()
        },
        He = (d, T, M, D, F, U, j, $, B = !1) => {
          let H = d && d.children,
            J = d ? d.shapeFlag : 0,
            Q = T.children,
            { patchFlag: ie, shapeFlag: ne } = T
          if (ie > 0) {
            if (ie & 128) {
              Ze(H, Q, M, D, F, U, j, $, B)
              return
            } else if (ie & 256) {
              St(H, Q, M, D, F, U, j, $, B)
              return
            }
          }
          ne & 8
            ? (J & 16 && Ws(H, F, U), Q !== H && c(M, Q))
            : J & 16
            ? ne & 16
              ? Ze(H, Q, M, D, F, U, j, $, B)
              : Ws(H, F, U, !0)
            : (J & 8 && c(M, ''), ne & 16 && N(Q, M, D, F, U, j, $, B))
        },
        St = (d, T, M, D, F, U, j, $, B) => {
          ;(d = d || b.EMPTY_ARR), (T = T || b.EMPTY_ARR)
          let H = d.length,
            J = T.length,
            Q = Math.min(H, J),
            ie
          for (ie = 0; ie < Q; ie++) {
            let ne = (T[ie] = B ? Nr(T[ie]) : ss(T[ie]))
            y(d[ie], ne, M, null, F, U, j, $, B)
          }
          H > J ? Ws(d, F, U, !0, !1, Q) : N(T, M, D, F, U, j, $, B, Q)
        },
        Ze = (d, T, M, D, F, U, j, $, B) => {
          let H = 0,
            J = T.length,
            Q = d.length - 1,
            ie = J - 1
          for (; H <= Q && H <= ie; ) {
            let ne = d[H],
              de = (T[H] = B ? Nr(T[H]) : ss(T[H]))
            if (Gs(ne, de)) y(ne, de, M, null, F, U, j, $, B)
            else break
            H++
          }
          for (; H <= Q && H <= ie; ) {
            let ne = d[Q],
              de = (T[ie] = B ? Nr(T[ie]) : ss(T[ie]))
            if (Gs(ne, de)) y(ne, de, M, null, F, U, j, $, B)
            else break
            Q--, ie--
          }
          if (H > Q) {
            if (H <= ie) {
              let ne = ie + 1,
                de = ne < J ? T[ne].el : D
              for (; H <= ie; )
                y(null, (T[H] = B ? Nr(T[H]) : ss(T[H])), M, de, F, U, j, $, B),
                  H++
            }
          } else if (H > ie) for (; H <= Q; ) Us(d[H], F, U, !0), H++
          else {
            let ne = H,
              de = H,
              ye = new Map()
            for (H = de; H <= ie; H++) {
              let We = (T[H] = B ? Nr(T[H]) : ss(T[H]))
              We.key != null &&
                (ye.has(We.key) &&
                  Z(
                    'Duplicate keys found during update:',
                    JSON.stringify(We.key),
                    'Make sure keys are unique.'
                  ),
                ye.set(We.key, H))
            }
            let Ee,
              $e = 0,
              Pt = ie - de + 1,
              fi = !1,
              Gi = 0,
              Wi = new Array(Pt)
            for (H = 0; H < Pt; H++) Wi[H] = 0
            for (H = ne; H <= Q; H++) {
              let We = d[H]
              if ($e >= Pt) {
                Us(We, F, U, !0)
                continue
              }
              let cs
              if (We.key != null) cs = ye.get(We.key)
              else
                for (Ee = de; Ee <= ie; Ee++)
                  if (Wi[Ee - de] === 0 && Gs(We, T[Ee])) {
                    cs = Ee
                    break
                  }
              cs === void 0
                ? Us(We, F, U, !0)
                : ((Wi[cs - de] = H + 1),
                  cs >= Gi ? (Gi = cs) : (fi = !0),
                  y(We, T[cs], M, null, F, U, j, $, B),
                  $e++)
            }
            let Ut = fi ? TL(Wi) : b.EMPTY_ARR
            for (Ee = Ut.length - 1, H = Pt - 1; H >= 0; H--) {
              let We = de + H,
                cs = T[We],
                sg = We + 1 < J ? T[We + 1].el : D
              Wi[H] === 0
                ? y(null, cs, M, sg, F, U, j, $, B)
                : fi && (Ee < 0 || H !== Ut[Ee] ? rt(cs, M, sg, 2) : Ee--)
            }
          }
        },
        rt = (d, T, M, D, F = null) => {
          let { el: U, type: j, transition: $, children: B, shapeFlag: H } = d
          if (H & 6) {
            rt(d.component.subTree, T, M, D)
            return
          }
          if (H & 128) {
            d.suspense.move(T, M, D)
            return
          }
          if (H & 64) {
            j.move(d, T, M, zs)
            return
          }
          if (j === Vt) {
            i(U, T, M)
            for (let Q = 0; Q < B.length; Q++) rt(B[Q], T, M, D)
            i(d.anchor, T, M)
            return
          }
          if (j === vn) {
            S(d, T, M)
            return
          }
          if (D !== 2 && H & 1 && $)
            if (D === 0) $.beforeEnter(U), i(U, T, M), wt(() => $.enter(U), F)
            else {
              let { leave: Q, delayLeave: ie, afterLeave: ne } = $,
                de = () => i(U, T, M),
                ye = () => {
                  Q(U, () => {
                    de(), ne && ne()
                  })
                }
              ie ? ie(U, de, ye) : ye()
            }
          else i(U, T, M)
        },
        Us = (d, T, M, D = !1, F = !1) => {
          let {
            type: U,
            props: j,
            ref: $,
            children: B,
            dynamicChildren: H,
            shapeFlag: J,
            patchFlag: Q,
            dirs: ie,
            cacheIndex: ne,
          } = d
          if (
            (Q === -2 && (F = !1),
            $ != null && yf($, null, M, d, !0),
            ne != null && (T.renderCache[ne] = void 0),
            J & 256)
          ) {
            T.ctx.deactivate(d)
            return
          }
          let de = J & 1 && ie,
            ye = !Tn(d),
            Ee
          if ((ye && (Ee = j && j.onVnodeBeforeUnmount) && ls(Ee, T, d), J & 6))
            kr(d.component, M, D)
          else {
            if (J & 128) {
              d.suspense.unmount(M, D)
              return
            }
            de && li(d, null, T, 'beforeUnmount'),
              J & 64
                ? d.type.remove(d, T, M, zs, D)
                : H && !H.hasOnce && (U !== Vt || (Q > 0 && Q & 64))
                ? Ws(H, T, M, !1, !0)
                : ((U === Vt && Q & (128 | 256)) || (!F && J & 16)) &&
                  Ws(B, T, M),
              D && Na(d)
          }
          ;((ye && (Ee = j && j.onVnodeUnmounted)) || de) &&
            wt(() => {
              Ee && ls(Ee, T, d), de && li(d, null, T, 'unmounted')
            }, M)
        },
        Na = (d) => {
          let { type: T, el: M, anchor: D, transition: F } = d
          if (T === Vt) {
            d.patchFlag > 0 && d.patchFlag & 2048 && F && !F.persisted
              ? d.children.forEach((j) => {
                  j.type === ut ? r(j.el) : Na(j)
                })
              : qf(M, D)
            return
          }
          if (T === vn) {
            _(d)
            return
          }
          let U = () => {
            r(M), F && !F.persisted && F.afterLeave && F.afterLeave()
          }
          if (d.shapeFlag & 1 && F && !F.persisted) {
            let { leave: j, delayLeave: $ } = F,
              B = () => j(M, U)
            $ ? $(d.el, U, B) : B()
          } else U()
        },
        qf = (d, T) => {
          let M
          for (; d !== T; ) (M = h(d)), r(d), (d = M)
          r(T)
        },
        kr = (d, T, M) => {
          d.type.__hmrId && Y8(d)
          let { bum: D, scope: F, update: U, subTree: j, um: $, m: B, a: H } = d
          _f(B),
            _f(H),
            D && b.invokeArrayFns(D),
            F.stop(),
            U && ((U.active = !1), Us(j, d, T, M)),
            $ && wt($, T),
            wt(() => {
              d.isUnmounted = !0
            }, T),
            T &&
              T.pendingBranch &&
              !T.isUnmounted &&
              d.asyncDep &&
              !d.asyncResolved &&
              d.suspenseId === T.pendingId &&
              (T.deps--, T.deps === 0 && T.resolve()),
            iR(d)
        },
        Ws = (d, T, M, D = !1, F = !1, U = 0) => {
          for (let j = U; j < d.length; j++) Us(d[j], T, M, D, F)
        },
        Xi = (d) => {
          if (d.shapeFlag & 6) return Xi(d.component.subTree)
          if (d.shapeFlag & 128) return d.suspense.next()
          let T = h(d.anchor || d.el),
            M = T && T[A_]
          return M ? h(M) : T
        },
        kn = !1,
        ci = (d, T, M) => {
          d == null
            ? T._vnode && Us(T._vnode, null, null, !0)
            : y(T._vnode || null, d, T, null, null, null, M),
            kn || ((kn = !0), R2(), nf(), (kn = !1)),
            (T._vnode = d)
        },
        zs = {
          p: y,
          um: Us,
          m: rt,
          r: Na,
          mt: Y,
          mc: N,
          pc: He,
          pbc: v,
          n: Xi,
          o: t,
        },
        Dr,
        w
      return (
        e && ([Dr, w] = e(zs)),
        { render: ci, hydrate: Dr, createApp: zR(ci, Dr) }
      )
    }
    function Em({ type: t, props: e }, s) {
      return (s === 'svg' && t === 'foreignObject') ||
        (s === 'mathml' &&
          t === 'annotation-xml' &&
          e &&
          e.encoding &&
          e.encoding.includes('html'))
        ? void 0
        : s
    }
    function Cn({ effect: t, update: e }, s) {
      t.allowRecurse = e.allowRecurse = s
    }
    function R_(t, e) {
      return (!t || (t && !t.pendingBranch)) && e && !e.persisted
    }
    function Tf(t, e, s = !1) {
      let i = t.children,
        r = e.children
      if (b.isArray(i) && b.isArray(r))
        for (let n = 0; n < i.length; n++) {
          let a = i[n],
            o = r[n]
          o.shapeFlag & 1 &&
            !o.dynamicChildren &&
            ((o.patchFlag <= 0 || o.patchFlag === 32) &&
              ((o = r[n] = Nr(r[n])), (o.el = a.el)),
            !s && o.patchFlag !== -2 && Tf(a, o)),
            o.type === Fi && (o.el = a.el),
            o.type === ut && !o.el && (o.el = a.el)
        }
    }
    function TL(t) {
      let e = t.slice(),
        s = [0],
        i,
        r,
        n,
        a,
        o,
        u = t.length
      for (i = 0; i < u; i++) {
        let l = t[i]
        if (l !== 0) {
          if (((r = s[s.length - 1]), t[r] < l)) {
            ;(e[i] = r), s.push(i)
            continue
          }
          for (n = 0, a = s.length - 1; n < a; )
            (o = (n + a) >> 1), t[s[o]] < l ? (n = o + 1) : (a = o)
          l < t[s[n]] && (n > 0 && (e[i] = s[n - 1]), (s[n] = i))
        }
      }
      for (n = s.length, a = s[n - 1]; n-- > 0; ) (s[n] = a), (a = e[a])
      return s
    }
    function L_(t) {
      let e = t.subTree.component
      if (e) return e.asyncDep && !e.asyncResolved ? e : L_(e)
    }
    function _f(t) {
      if (t) for (let e = 0; e < t.length; e++) t[e].active = !1
    }
    var k_ = Symbol.for('v-scx'),
      D_ = () => {
        {
          let t = ou(k_)
          return (
            t ||
              Z(
                'Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.'
              ),
            t
          )
        }
      }
    function _L(t, e) {
      return fu(t, null, e)
    }
    function xL(t, e) {
      return fu(t, null, b.extend({}, e, { flush: 'post' }))
    }
    function F_(t, e) {
      return fu(t, null, b.extend({}, e, { flush: 'sync' }))
    }
    var xf = {}
    function cu(t, e, s) {
      return (
        b.isFunction(e) ||
          Z(
            '`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature.'
          ),
        fu(t, e, s)
      )
    }
    function fu(
      t,
      e,
      {
        immediate: s,
        deep: i,
        flush: r,
        once: n,
        onTrack: a,
        onTrigger: o,
      } = b.EMPTY_OBJ
    ) {
      if (e && n) {
        let k = e
        e = (...L) => {
          k(...L), I()
        }
      }
      i !== void 0 &&
        typeof i == 'number' &&
        Z(
          'watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.'
        ),
        e ||
          (s !== void 0 &&
            Z(
              'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
            ),
          i !== void 0 &&
            Z(
              'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
            ),
          n !== void 0 &&
            Z(
              'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
            ))
      let u = (k) => {
          Z(
            'Invalid watch source: ',
            k,
            'A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.'
          )
        },
        l = gt,
        c = (k) => (i === !0 ? k : vr(k, i === !1 ? 1 : void 0)),
        f,
        h = !1,
        p = !1
      if (
        (te.isRef(t)
          ? ((f = () => t.value), (h = te.isShallow(t)))
          : te.isReactive(t)
          ? ((f = () => c(t)), (h = !0))
          : b.isArray(t)
          ? ((p = !0),
            (h = t.some((k) => te.isReactive(k) || te.isShallow(k))),
            (f = () =>
              t.map((k) => {
                if (te.isRef(k)) return k.value
                if (te.isReactive(k)) return c(k)
                if (b.isFunction(k)) return oi(k, l, 2)
                u(k)
              })))
          : b.isFunction(t)
          ? e
            ? (f = () => oi(t, l, 2))
            : (f = () => (m && m(), ks(t, l, 3, [y])))
          : ((f = b.NOOP), u(t)),
        e && i)
      ) {
        let k = f
        f = () => vr(k())
      }
      let m,
        y = (k) => {
          m = S.onStop = () => {
            oi(k, l, 4), (m = S.onStop = void 0)
          }
        },
        x
      if (du)
        if (
          ((y = b.NOOP),
          e ? s && ks(e, l, 3, [f(), p ? [] : void 0, y]) : f(),
          r === 'sync')
        ) {
          let k = D_()
          x = k.__watcherHandles || (k.__watcherHandles = [])
        } else return b.NOOP
      let C = p ? new Array(t.length).fill(xf) : xf,
        E = () => {
          if (!(!S.active || !S.dirty))
            if (e) {
              let k = S.run()
              ;(i ||
                h ||
                (p
                  ? k.some((L, N) => b.hasChanged(L, C[N]))
                  : b.hasChanged(k, C))) &&
                (m && m(),
                ks(e, l, 3, [
                  k,
                  C === xf ? void 0 : p && C[0] === xf ? [] : C,
                  y,
                ]),
                (C = k))
            } else S.run()
        }
      E.allowRecurse = !!e
      let g
      r === 'sync'
        ? (g = E)
        : r === 'post'
        ? (g = () => wt(E, l && l.suspense))
        : ((E.pre = !0), l && (E.id = l.uid), (g = () => Yo(E)))
      let S = new te.ReactiveEffect(f, b.NOOP, g),
        _ = te.getCurrentScope(),
        I = () => {
          S.stop(), _ && b.remove(_.effects, S)
        }
      return (
        (S.onTrack = a),
        (S.onTrigger = o),
        e
          ? s
            ? E()
            : (C = S.run())
          : r === 'post'
          ? wt(S.run.bind(S), l && l.suspense)
          : S.run(),
        x && x.push(I),
        I
      )
    }
    function AL(t, e, s) {
      let i = this.proxy,
        r = b.isString(t)
          ? t.includes('.')
            ? B_(i, t)
            : () => i[t]
          : t.bind(i, i),
        n
      b.isFunction(e) ? (n = e) : ((n = e.handler), (s = e))
      let a = On(this),
        o = fu(r, n.bind(i), s)
      return a(), o
    }
    function B_(t, e) {
      let s = e.split('.')
      return () => {
        let i = t
        for (let r = 0; r < s.length && i; r++) i = i[s[r]]
        return i
      }
    }
    function vr(t, e = 1 / 0, s) {
      if (
        e <= 0 ||
        !b.isObject(t) ||
        t.__v_skip ||
        ((s = s || new Set()), s.has(t))
      )
        return t
      if ((s.add(t), e--, te.isRef(t))) vr(t.value, e, s)
      else if (b.isArray(t)) for (let i = 0; i < t.length; i++) vr(t[i], e, s)
      else if (b.isSet(t) || b.isMap(t))
        t.forEach((i) => {
          vr(i, e, s)
        })
      else if (b.isPlainObject(t)) {
        for (let i in t) vr(t[i], e, s)
        for (let i of Object.getOwnPropertySymbols(t))
          Object.prototype.propertyIsEnumerable.call(t, i) && vr(t[i], e, s)
      }
      return t
    }
    function PL(t, e, s = b.EMPTY_OBJ) {
      let i = In()
      if (!i) return Z('useModel() called without active instance.'), te.ref()
      if (!i.propsOptions[0][e])
        return (
          Z(`useModel() called with prop "${e}" which is not declared.`),
          te.ref()
        )
      let r = b.camelize(e),
        n = b.hyphenate(e),
        a = V_(t, e),
        o = te.customRef((u, l) => {
          let c,
            f = b.EMPTY_OBJ,
            h
          return (
            F_(() => {
              let p = t[e]
              b.hasChanged(c, p) && ((c = p), l())
            }),
            {
              get() {
                return u(), s.get ? s.get(c) : c
              },
              set(p) {
                if (
                  !b.hasChanged(p, c) &&
                  !(f !== b.EMPTY_OBJ && b.hasChanged(p, f))
                )
                  return
                let m = i.vnode.props
                ;(m &&
                  (e in m || r in m || n in m) &&
                  (`onUpdate:${e}` in m ||
                    `onUpdate:${r}` in m ||
                    `onUpdate:${n}` in m)) ||
                  ((c = p), l())
                let y = s.set ? s.set(p) : p
                i.emit(`update:${e}`, y),
                  b.hasChanged(p, y) &&
                    b.hasChanged(p, f) &&
                    !b.hasChanged(y, h) &&
                    l(),
                  (f = p),
                  (h = y)
              },
            }
          )
        })
      return (
        (o[Symbol.iterator] = () => {
          let u = 0
          return {
            next() {
              return u < 2
                ? { value: u++ ? a || b.EMPTY_OBJ : o, done: !1 }
                : { done: !0 }
            },
          }
        }),
        o
      )
    }
    var V_ = (t, e) =>
      e === 'modelValue' || e === 'model-value'
        ? t.modelModifiers
        : t[`${e}Modifiers`] ||
          t[`${b.camelize(e)}Modifiers`] ||
          t[`${b.hyphenate(e)}Modifiers`]
    function CL(t, e, ...s) {
      if (t.isUnmounted) return
      let i = t.vnode.props || b.EMPTY_OBJ
      {
        let {
          emitsOptions: c,
          propsOptions: [f],
        } = t
        if (c)
          if (!(e in c))
            (!f || !(b.toHandlerKey(e) in f)) &&
              Z(
                `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${b.toHandlerKey(
                  e
                )}" prop.`
              )
          else {
            let h = c[e]
            b.isFunction(h) &&
              (h(...s) ||
                Z(
                  `Invalid event arguments: event validation failed for event "${e}".`
                ))
          }
      }
      let r = s,
        n = e.startsWith('update:'),
        a = n && V_(i, e.slice(7))
      a &&
        (a.trim && (r = s.map((c) => (b.isString(c) ? c.trim() : c))),
        a.number && (r = s.map(b.looseToNumber))),
        aR(t, e, r)
      {
        let c = e.toLowerCase()
        c !== e &&
          i[b.toHandlerKey(c)] &&
          Z(
            `Event "${c}" is emitted in component ${wf(
              t,
              t.type
            )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${b.hyphenate(
              e
            )}" instead of "${e}".`
          )
      }
      let o,
        u = i[(o = b.toHandlerKey(e))] || i[(o = b.toHandlerKey(b.camelize(e)))]
      !u && n && (u = i[(o = b.toHandlerKey(b.hyphenate(e)))]),
        u && ks(u, t, 6, r)
      let l = i[o + 'Once']
      if (l) {
        if (!t.emitted) t.emitted = {}
        else if (t.emitted[o]) return
        ;(t.emitted[o] = !0), ks(l, t, 6, r)
      }
    }
    function U_(t, e, s = !1) {
      let i = e.emitsCache,
        r = i.get(t)
      if (r !== void 0) return r
      let n = t.emits,
        a = {},
        o = !1
      if (!b.isFunction(t)) {
        let u = (l) => {
          let c = U_(l, e, !0)
          c && ((o = !0), b.extend(a, c))
        }
        !s && e.mixins.length && e.mixins.forEach(u),
          t.extends && u(t.extends),
          t.mixins && t.mixins.forEach(u)
      }
      return !n && !o
        ? (b.isObject(t) && i.set(t, null), null)
        : (b.isArray(n) ? n.forEach((u) => (a[u] = null)) : b.extend(a, n),
          b.isObject(t) && i.set(t, a),
          a)
    }
    function Af(t, e) {
      return !t || !b.isOn(e)
        ? !1
        : ((e = e.slice(2).replace(/Once$/, '')),
          b.hasOwn(t, e[0].toLowerCase() + e.slice(1)) ||
            b.hasOwn(t, b.hyphenate(e)) ||
            b.hasOwn(t, e))
    }
    var Sm = !1
    function Pf() {
      Sm = !0
    }
    function Cf(t) {
      let {
          type: e,
          vnode: s,
          proxy: i,
          withProxy: r,
          propsOptions: [n],
          slots: a,
          attrs: o,
          emit: u,
          render: l,
          renderCache: c,
          props: f,
          data: h,
          setupState: p,
          ctx: m,
          inheritAttrs: y,
        } = t,
        x = su(t),
        C,
        E
      Sm = !1
      try {
        if (s.shapeFlag & 4) {
          let _ = r || i,
            I = p.__isScriptSetup
              ? new Proxy(_, {
                  get(k, L, N) {
                    return (
                      Z(
                        `Property '${String(
                          L
                        )}' was accessed via 'this'. Avoid using 'this' in templates.`
                      ),
                      Reflect.get(k, L, N)
                    )
                  },
                })
              : _
          ;(C = ss(l.call(I, _, c, te.shallowReadonly(f), p, h, m))), (E = o)
        } else {
          let _ = e
          o === f && Pf(),
            (C = ss(
              _.length > 1
                ? _(te.shallowReadonly(f), {
                    get attrs() {
                      return Pf(), te.shallowReadonly(o)
                    },
                    slots: a,
                    emit: u,
                  })
                : _(te.shallowReadonly(f), null)
            )),
            (E = e.props ? o : vL(o))
        }
      } catch (_) {
        ;(pu.length = 0), _r(_, t, 1), (C = lt(ut))
      }
      let g = C,
        S
      if (
        (C.patchFlag > 0 && C.patchFlag & 2048 && ([g, S] = H_(C)),
        E && y !== !1)
      ) {
        let _ = Object.keys(E),
          { shapeFlag: I } = g
        if (_.length) {
          if (I & (1 | 6))
            n && _.some(b.isModelListener) && (E = NL(E, n)),
              (g = Fs(g, E, !1, !0))
          else if (!Sm && g.type !== ut) {
            let k = Object.keys(o),
              L = [],
              N = []
            for (let O = 0, v = k.length; O < v; O++) {
              let A = k[O]
              b.isOn(A)
                ? b.isModelListener(A) ||
                  L.push(A[2].toLowerCase() + A.slice(3))
                : N.push(A)
            }
            N.length &&
              Z(
                `Extraneous non-props attributes (${N.join(
                  ', '
                )}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
              ),
              L.length &&
                Z(
                  `Extraneous non-emits event listeners (${L.join(
                    ', '
                  )}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
                )
          }
        }
      }
      return (
        s.dirs &&
          ($_(g) ||
            Z(
              'Runtime directive used on component with non-element root node. The directives will not function as intended.'
            ),
          (g = Fs(g, null, !1, !0)),
          (g.dirs = g.dirs ? g.dirs.concat(s.dirs) : s.dirs)),
        s.transition &&
          ($_(g) ||
            Z(
              'Component inside <Transition> renders non-element root node that cannot be animated.'
            ),
          (g.transition = s.transition)),
        S ? S(g) : (C = g),
        su(x),
        C
      )
    }
    var H_ = (t) => {
      let e = t.children,
        s = t.dynamicChildren,
        i = vf(e, !1)
      if (i) {
        if (i.patchFlag > 0 && i.patchFlag & 2048) return H_(i)
      } else return [t, void 0]
      let r = e.indexOf(i),
        n = s ? s.indexOf(i) : -1,
        a = (o) => {
          ;(e[r] = o),
            s &&
              (n > -1
                ? (s[n] = o)
                : o.patchFlag > 0 && (t.dynamicChildren = [...s, o]))
        }
      return [ss(i), a]
    }
    function vf(t, e = !0) {
      let s
      for (let i = 0; i < t.length; i++) {
        let r = t[i]
        if (Bi(r)) {
          if (r.type !== ut || r.children === 'v-if') {
            if (s) return
            if (((s = r), e && s.patchFlag > 0 && s.patchFlag & 2048))
              return vf(s.children)
          }
        } else return
      }
      return s
    }
    var vL = (t) => {
        let e
        for (let s in t)
          (s === 'class' || s === 'style' || b.isOn(s)) &&
            ((e || (e = {}))[s] = t[s])
        return e
      },
      NL = (t, e) => {
        let s = {}
        for (let i in t)
          (!b.isModelListener(i) || !(i.slice(9) in e)) && (s[i] = t[i])
        return s
      },
      $_ = (t) => t.shapeFlag & (6 | 1) || t.type === ut
    function IL(t, e, s) {
      let { props: i, children: r, component: n } = t,
        { props: a, children: o, patchFlag: u } = e,
        l = n.emitsOptions
      if (((r || o) && Ar) || e.dirs || e.transition) return !0
      if (s && u >= 0) {
        if (u & 1024) return !0
        if (u & 16) return i ? j_(i, a, l) : !!a
        if (u & 8) {
          let c = e.dynamicProps
          for (let f = 0; f < c.length; f++) {
            let h = c[f]
            if (a[h] !== i[h] && !Af(l, h)) return !0
          }
        }
      } else
        return (r || o) && (!o || !o.$stable)
          ? !0
          : i === a
          ? !1
          : i
          ? a
            ? j_(i, a, l)
            : !0
          : !!a
      return !1
    }
    function j_(t, e, s) {
      let i = Object.keys(e)
      if (i.length !== Object.keys(t).length) return !0
      for (let r = 0; r < i.length; r++) {
        let n = i[r]
        if (e[n] !== t[n] && !Af(s, n)) return !0
      }
      return !1
    }
    function Tm({ vnode: t, parent: e }, s) {
      for (; e; ) {
        let i = e.subTree
        if (
          (i.suspense && i.suspense.activeBranch === t && (i.el = t.el),
          i === t)
        )
          ((t = e.vnode).el = s), (e = e.parent)
        else break
      }
    }
    var _m = (t) => t.__isSuspense,
      xm = 0,
      OL = {
        name: 'Suspense',
        __isSuspense: !0,
        process(t, e, s, i, r, n, a, o, u, l) {
          if (t == null) ML(e, s, i, r, n, a, o, u, l)
          else {
            if (n && n.deps > 0 && !t.suspense.isInFallback) {
              ;(e.suspense = t.suspense), (e.suspense.vnode = e), (e.el = t.el)
              return
            }
            RL(t, e, s, i, r, a, o, u, l)
          }
        },
        hydrate: LL,
        normalize: kL,
      },
      wL = OL
    function hu(t, e) {
      let s = t.props && t.props[e]
      b.isFunction(s) && s()
    }
    function ML(t, e, s, i, r, n, a, o, u) {
      let {
          p: l,
          o: { createElement: c },
        } = u,
        f = c('div'),
        h = (t.suspense = K_(t, r, i, e, f, s, n, a, o, u))
      l(null, (h.pendingBranch = t.ssContent), f, null, i, h, n, a),
        h.deps > 0
          ? (hu(t, 'onPending'),
            hu(t, 'onFallback'),
            l(null, t.ssFallback, e, s, i, null, n, a),
            Ta(h, t.ssFallback))
          : h.resolve(!1, !0)
    }
    function RL(
      t,
      e,
      s,
      i,
      r,
      n,
      a,
      o,
      { p: u, um: l, o: { createElement: c } }
    ) {
      let f = (e.suspense = t.suspense)
      ;(f.vnode = e), (e.el = t.el)
      let h = e.ssContent,
        p = e.ssFallback,
        {
          activeBranch: m,
          pendingBranch: y,
          isInFallback: x,
          isHydrating: C,
        } = f
      if (y)
        (f.pendingBranch = h),
          Gs(h, y)
            ? (u(y, h, f.hiddenContainer, null, r, f, n, a, o),
              f.deps <= 0
                ? f.resolve()
                : x && (C || (u(m, p, s, i, r, null, n, a, o), Ta(f, p))))
            : ((f.pendingId = xm++),
              C ? ((f.isHydrating = !1), (f.activeBranch = y)) : l(y, r, f),
              (f.deps = 0),
              (f.effects.length = 0),
              (f.hiddenContainer = c('div')),
              x
                ? (u(null, h, f.hiddenContainer, null, r, f, n, a, o),
                  f.deps <= 0
                    ? f.resolve()
                    : (u(m, p, s, i, r, null, n, a, o), Ta(f, p)))
                : m && Gs(h, m)
                ? (u(m, h, s, i, r, f, n, a, o), f.resolve(!0))
                : (u(null, h, f.hiddenContainer, null, r, f, n, a, o),
                  f.deps <= 0 && f.resolve()))
      else if (m && Gs(h, m)) u(m, h, s, i, r, f, n, a, o), Ta(f, h)
      else if (
        (hu(e, 'onPending'),
        (f.pendingBranch = h),
        h.shapeFlag & 512
          ? (f.pendingId = h.component.suspenseId)
          : (f.pendingId = xm++),
        u(null, h, f.hiddenContainer, null, r, f, n, a, o),
        f.deps <= 0)
      )
        f.resolve()
      else {
        let { timeout: E, pendingId: g } = f
        E > 0
          ? setTimeout(() => {
              f.pendingId === g && f.fallback(p)
            }, E)
          : E === 0 && f.fallback(p)
      }
    }
    var q_ = !1
    function K_(t, e, s, i, r, n, a, o, u, l, c = !1) {
      q_ ||
        ((q_ = !0),
        console[console.info ? 'info' : 'log'](
          '<Suspense> is an experimental feature and its API will likely change.'
        ))
      let {
          p: f,
          m: h,
          um: p,
          n: m,
          o: { parentNode: y, remove: x },
        } = l,
        C,
        E = DL(t)
      E && e && e.pendingBranch && ((C = e.pendingId), e.deps++)
      let g = t.props ? b.toNumber(t.props.timeout) : void 0
      I2(g, 'Suspense timeout')
      let S = n,
        _ = {
          vnode: t,
          parent: e,
          parentComponent: s,
          namespace: a,
          container: i,
          hiddenContainer: r,
          deps: 0,
          pendingId: xm++,
          timeout: typeof g == 'number' ? g : -1,
          activeBranch: null,
          pendingBranch: null,
          isInFallback: !c,
          isHydrating: c,
          isUnmounted: !1,
          effects: [],
          resolve(I = !1, k = !1) {
            {
              if (!I && !_.pendingBranch)
                throw new Error(
                  'suspense.resolve() is called without a pending branch.'
                )
              if (_.isUnmounted)
                throw new Error(
                  'suspense.resolve() is called on an already unmounted suspense boundary.'
                )
            }
            let {
                vnode: L,
                activeBranch: N,
                pendingBranch: O,
                pendingId: v,
                effects: A,
                parentComponent: V,
                container: se,
              } = _,
              Y = !1
            _.isHydrating
              ? (_.isHydrating = !1)
              : I ||
                ((Y = N && O.transition && O.transition.mode === 'out-in'),
                Y &&
                  (N.transition.afterLeave = () => {
                    v === _.pendingId &&
                      (h(O, se, n === S ? m(N) : n, 0), Qo(A))
                  }),
                N &&
                  (y(N.el) !== _.hiddenContainer && (n = m(N)), p(N, V, _, !0)),
                Y || h(O, se, n, 0)),
              Ta(_, O),
              (_.pendingBranch = null),
              (_.isInFallback = !1)
            let q = _.parent,
              ee = !1
            for (; q; ) {
              if (q.pendingBranch) {
                q.effects.push(...A), (ee = !0)
                break
              }
              q = q.parent
            }
            !ee && !Y && Qo(A),
              (_.effects = []),
              E &&
                e &&
                e.pendingBranch &&
                C === e.pendingId &&
                (e.deps--, e.deps === 0 && !k && e.resolve()),
              hu(L, 'onResolve')
          },
          fallback(I) {
            if (!_.pendingBranch) return
            let {
              vnode: k,
              activeBranch: L,
              parentComponent: N,
              container: O,
              namespace: v,
            } = _
            hu(k, 'onFallback')
            let A = m(L),
              V = () => {
                !_.isInFallback ||
                  (f(null, I, O, A, N, null, v, o, u), Ta(_, I))
              },
              se = I.transition && I.transition.mode === 'out-in'
            se && (L.transition.afterLeave = V),
              (_.isInFallback = !0),
              p(L, N, null, !0),
              se || V()
          },
          move(I, k, L) {
            _.activeBranch && h(_.activeBranch, I, k, L), (_.container = I)
          },
          next() {
            return _.activeBranch && m(_.activeBranch)
          },
          registerDep(I, k, L) {
            let N = !!_.pendingBranch
            N && _.deps++
            let O = I.vnode.el
            I.asyncDep
              .catch((v) => {
                _r(v, I, 0)
              })
              .then((v) => {
                if (
                  I.isUnmounted ||
                  _.isUnmounted ||
                  _.pendingId !== I.suspenseId
                )
                  return
                I.asyncResolved = !0
                let { vnode: A } = I
                Wo(A), Rm(I, v, !1), O && (A.el = O)
                let V = !O && I.subTree.el
                k(I, A, y(O || I.subTree.el), O ? null : m(I.subTree), _, a, L),
                  V && x(V),
                  Tm(I, A.el),
                  zo(),
                  N && --_.deps == 0 && _.resolve()
              })
          },
          unmount(I, k) {
            ;(_.isUnmounted = !0),
              _.activeBranch && p(_.activeBranch, s, I, k),
              _.pendingBranch && p(_.pendingBranch, s, I, k)
          },
        }
      return _
    }
    function LL(t, e, s, i, r, n, a, o, u) {
      let l = (e.suspense = K_(
          e,
          i,
          s,
          t.parentNode,
          document.createElement('div'),
          null,
          r,
          n,
          a,
          o,
          !0
        )),
        c = u(t, (l.pendingBranch = e.ssContent), s, l, n, a)
      return l.deps === 0 && l.resolve(!1, !0), c
    }
    function kL(t) {
      let { shapeFlag: e, children: s } = t,
        i = e & 32
      ;(t.ssContent = X_(i ? s.default : s)),
        (t.ssFallback = i ? X_(s.fallback) : lt(ut))
    }
    function X_(t) {
      let e
      if (b.isFunction(t)) {
        let s = Nn && t._c
        s && ((t._d = !1), Nf()), (t = t()), s && ((t._d = !0), (e = Wt), W_())
      }
      if (b.isArray(t)) {
        let s = vf(t)
        !s &&
          t.filter((i) => i !== am).length > 0 &&
          Z('<Suspense> slots expect a single root node.'),
          (t = s)
      }
      return (
        (t = ss(t)),
        e &&
          !t.dynamicChildren &&
          (t.dynamicChildren = e.filter((s) => s !== t)),
        t
      )
    }
    function G_(t, e) {
      e && e.pendingBranch
        ? b.isArray(t)
          ? e.effects.push(...t)
          : e.effects.push(t)
        : Qo(t)
    }
    function Ta(t, e) {
      t.activeBranch = e
      let { vnode: s, parentComponent: i } = t,
        r = e.el
      for (; !r && e.component; ) (e = e.component.subTree), (r = e.el)
      ;(s.el = r), i && i.subTree === s && ((i.vnode.el = r), Tm(i, r))
    }
    function DL(t) {
      let e = t.props && t.props.suspensible
      return e != null && e !== !1
    }
    var Vt = Symbol.for('v-fgt'),
      Fi = Symbol.for('v-txt'),
      ut = Symbol.for('v-cmt'),
      vn = Symbol.for('v-stc'),
      pu = [],
      Wt = null
    function Nf(t = !1) {
      pu.push((Wt = t ? null : []))
    }
    function W_() {
      pu.pop(), (Wt = pu[pu.length - 1] || null)
    }
    var Nn = 1
    function Am(t) {
      ;(Nn += t), t < 0 && Wt && (Wt.hasOnce = !0)
    }
    function z_(t) {
      return (
        (t.dynamicChildren = Nn > 0 ? Wt || b.EMPTY_ARR : null),
        W_(),
        Nn > 0 && Wt && Wt.push(t),
        t
      )
    }
    function FL(t, e, s, i, r, n) {
      return z_(vm(t, e, s, i, r, n, !0))
    }
    function Pm(t, e, s, i, r) {
      return z_(lt(t, e, s, i, r, !0))
    }
    function Bi(t) {
      return t ? t.__v_isVNode === !0 : !1
    }
    function Gs(t, e) {
      if (e.shapeFlag & 6 && t.component) {
        let s = af.get(e.type)
        if (s && s.has(t.component))
          return (t.shapeFlag &= ~256), (e.shapeFlag &= ~512), !1
      }
      return t.type === e.type && t.key === e.key
    }
    var Cm
    function BL(t) {
      Cm = t
    }
    var VL = (...t) => UL(...(Cm ? Cm(t, ht) : t)),
      J_ = ({ key: t }) => (t != null ? t : null),
      If = ({ ref: t, ref_key: e, ref_for: s }) => (
        typeof t == 'number' && (t = '' + t),
        t != null
          ? b.isString(t) || te.isRef(t) || b.isFunction(t)
            ? { i: ht, r: t, k: e, f: !!s }
            : t
          : null
      )
    function vm(
      t,
      e = null,
      s = null,
      i = 0,
      r = null,
      n = t === Vt ? 0 : 1,
      a = !1,
      o = !1
    ) {
      let u = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && J_(e),
        ref: e && If(e),
        scopeId: uf,
        slotScopeIds: null,
        children: s,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: n,
        patchFlag: i,
        dynamicProps: r,
        dynamicChildren: null,
        appContext: null,
        ctx: ht,
      }
      return (
        o
          ? (Im(u, s), n & 128 && t.normalize(u))
          : s && (u.shapeFlag |= b.isString(s) ? 8 : 16),
        u.key !== u.key &&
          Z('VNode created with invalid key (NaN). VNode type:', u.type),
        Nn > 0 &&
          !a &&
          Wt &&
          (u.patchFlag > 0 || n & 6) &&
          u.patchFlag !== 32 &&
          Wt.push(u),
        u
      )
    }
    var lt = VL
    function UL(t, e = null, s = null, i = 0, r = null, n = !1) {
      if (
        ((!t || t === am) &&
          (t || Z(`Invalid vnode type when creating vnode: ${t}.`), (t = ut)),
        Bi(t))
      ) {
        let o = Fs(t, e, !0)
        return (
          s && Im(o, s),
          Nn > 0 &&
            !n &&
            Wt &&
            (o.shapeFlag & 6 ? (Wt[Wt.indexOf(t)] = o) : Wt.push(o)),
          (o.patchFlag = -2),
          o
        )
      }
      if ((ax(t) && (t = t.__vccOpts), e)) {
        e = Y_(e)
        let { class: o, style: u } = e
        o && !b.isString(o) && (e.class = b.normalizeClass(o)),
          b.isObject(u) &&
            (te.isProxy(u) && !b.isArray(u) && (u = b.extend({}, u)),
            (e.style = b.normalizeStyle(u)))
      }
      let a = b.isString(t)
        ? 1
        : _m(t)
        ? 128
        : lL(t)
        ? 64
        : b.isObject(t)
        ? 4
        : b.isFunction(t)
        ? 2
        : 0
      return (
        a & 4 &&
          te.isProxy(t) &&
          ((t = te.toRaw(t)),
          Z(
            'Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.',
            `
Component that was made reactive: `,
            t
          )),
        vm(t, e, s, i, r, a, n, !0)
      )
    }
    function Y_(t) {
      return t ? (te.isProxy(t) || h_(t) ? b.extend({}, t) : t) : null
    }
    function Fs(t, e, s = !1, i = !1) {
      let { props: r, ref: n, patchFlag: a, children: o, transition: u } = t,
        l = e ? Z_(r || {}, e) : r,
        c = {
          __v_isVNode: !0,
          __v_skip: !0,
          type: t.type,
          props: l,
          key: l && J_(l),
          ref:
            e && e.ref
              ? s && n
                ? b.isArray(n)
                  ? n.concat(If(e))
                  : [n, If(e)]
                : If(e)
              : n,
          scopeId: t.scopeId,
          slotScopeIds: t.slotScopeIds,
          children: a === -1 && b.isArray(o) ? o.map(Q_) : o,
          target: t.target,
          targetStart: t.targetStart,
          targetAnchor: t.targetAnchor,
          staticCount: t.staticCount,
          shapeFlag: t.shapeFlag,
          patchFlag: e && t.type !== Vt ? (a === -1 ? 16 : a | 16) : a,
          dynamicProps: t.dynamicProps,
          dynamicChildren: t.dynamicChildren,
          appContext: t.appContext,
          dirs: t.dirs,
          transition: u,
          component: t.component,
          suspense: t.suspense,
          ssContent: t.ssContent && Fs(t.ssContent),
          ssFallback: t.ssFallback && Fs(t.ssFallback),
          el: t.el,
          anchor: t.anchor,
          ctx: t.ctx,
          ce: t.ce,
        }
      return u && i && ba(c, u.clone(c)), c
    }
    function Q_(t) {
      let e = Fs(t)
      return b.isArray(t.children) && (e.children = t.children.map(Q_)), e
    }
    function Nm(t = ' ', e = 0) {
      return lt(Fi, null, t, e)
    }
    function HL(t, e) {
      let s = lt(vn, null, t)
      return (s.staticCount = e), s
    }
    function $L(t = '', e = !1) {
      return e ? (Nf(), Pm(ut, null, t)) : lt(ut, null, t)
    }
    function ss(t) {
      return t == null || typeof t == 'boolean'
        ? lt(ut)
        : b.isArray(t)
        ? lt(Vt, null, t.slice())
        : typeof t == 'object'
        ? Nr(t)
        : lt(Fi, null, String(t))
    }
    function Nr(t) {
      return (t.el === null && t.patchFlag !== -1) || t.memo ? t : Fs(t)
    }
    function Im(t, e) {
      let s = 0,
        { shapeFlag: i } = t
      if (e == null) e = null
      else if (b.isArray(e)) s = 16
      else if (typeof e == 'object')
        if (i & (1 | 64)) {
          let r = e.default
          r && (r._c && (r._d = !1), Im(t, r()), r._c && (r._d = !0))
          return
        } else {
          s = 32
          let r = e._
          !r && !h_(e)
            ? (e._ctx = ht)
            : r === 3 &&
              ht &&
              (ht.slots._ === 1
                ? (e._ = 1)
                : ((e._ = 2), (t.patchFlag |= 1024)))
        }
      else
        b.isFunction(e)
          ? ((e = { default: e, _ctx: ht }), (s = 32))
          : ((e = String(e)), i & 64 ? ((s = 16), (e = [Nm(e)])) : (s = 8))
      ;(t.children = e), (t.shapeFlag |= s)
    }
    function Z_(...t) {
      let e = {}
      for (let s = 0; s < t.length; s++) {
        let i = t[s]
        for (let r in i)
          if (r === 'class')
            e.class !== i.class &&
              (e.class = b.normalizeClass([e.class, i.class]))
          else if (r === 'style') e.style = b.normalizeStyle([e.style, i.style])
          else if (b.isOn(r)) {
            let n = e[r],
              a = i[r]
            a &&
              n !== a &&
              !(b.isArray(n) && n.includes(a)) &&
              (e[r] = n ? [].concat(n, a) : a)
          } else r !== '' && (e[r] = i[r])
      }
      return e
    }
    function ls(t, e, s, i = null) {
      ks(t, e, 7, [s, i])
    }
    var jL = u_(),
      qL = 0
    function ex(t, e, s) {
      let i = t.type,
        r = (e ? e.appContext : t.appContext) || jL,
        n = {
          uid: qL++,
          vnode: t,
          type: i,
          parent: e,
          appContext: r,
          root: null,
          next: null,
          subTree: null,
          effect: null,
          update: null,
          scope: new te.EffectScope(!0),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: e ? e.provides : Object.create(r.provides),
          accessCache: null,
          renderCache: [],
          components: null,
          directives: null,
          propsOptions: d_(i, r),
          emitsOptions: U_(i, r),
          emit: null,
          emitted: null,
          propsDefaults: b.EMPTY_OBJ,
          inheritAttrs: i.inheritAttrs,
          ctx: b.EMPTY_OBJ,
          data: b.EMPTY_OBJ,
          props: b.EMPTY_OBJ,
          attrs: b.EMPTY_OBJ,
          slots: b.EMPTY_OBJ,
          refs: b.EMPTY_OBJ,
          setupState: b.EMPTY_OBJ,
          setupContext: null,
          suspense: s,
          suspenseId: s ? s.pendingId : 0,
          asyncDep: null,
          asyncResolved: !1,
          isMounted: !1,
          isUnmounted: !1,
          isDeactivated: !1,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null,
        }
      return (
        (n.ctx = CR(n)),
        (n.root = e ? e.root : n),
        (n.emit = CL.bind(null, n)),
        t.ce && t.ce(n),
        n
      )
    }
    var gt = null,
      In = () => gt || ht,
      Of,
      Om
    {
      let t = b.getGlobalThis(),
        e = (s, i) => {
          let r
          return (
            (r = t[s]) || (r = t[s] = []),
            r.push(i),
            (n) => {
              r.length > 1 ? r.forEach((a) => a(n)) : r[0](n)
            }
          )
        }
      ;(Of = e('__VUE_INSTANCE_SETTERS__', (s) => (gt = s))),
        (Om = e('__VUE_SSR_SETTERS__', (s) => (du = s)))
    }
    var On = (t) => {
        let e = gt
        return (
          Of(t),
          t.scope.on(),
          () => {
            t.scope.off(), Of(e)
          }
        )
      },
      wm = () => {
        gt && gt.scope.off(), Of(null)
      },
      KL = b.makeMap('slot,component')
    function Mm(t, { isNativeTag: e }) {
      ;(KL(t) || e(t)) &&
        Z('Do not use built-in or reserved HTML elements as component id: ' + t)
    }
    function tx(t) {
      return t.vnode.shapeFlag & 4
    }
    var du = !1
    function sx(t, e = !1, s = !1) {
      e && Om(e)
      let { props: i, children: r } = t.vnode,
        n = tx(t)
      YR(t, i, n, e), oL(t, r, s)
      let a = n ? XL(t, e) : void 0
      return e && Om(!1), a
    }
    function XL(t, e) {
      var s
      let i = t.type
      {
        if ((i.name && Mm(i.name, t.appContext.config), i.components)) {
          let n = Object.keys(i.components)
          for (let a = 0; a < n.length; a++) Mm(n[a], t.appContext.config)
        }
        if (i.directives) {
          let n = Object.keys(i.directives)
          for (let a = 0; a < n.length; a++) V2(n[a])
        }
        i.compilerOptions &&
          ix() &&
          Z(
            '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
          )
      }
      ;(t.accessCache = Object.create(null)),
        (t.proxy = new Proxy(t.ctx, ru)),
        vR(t)
      let { setup: r } = i
      if (r) {
        let n = (t.setupContext = r.length > 1 ? nx(t) : null),
          a = On(t)
        te.pauseTracking()
        let o = oi(r, t, 0, [te.shallowReadonly(t.props), n])
        if ((te.resetTracking(), a(), b.isPromise(o))) {
          if ((o.then(wm, wm), e))
            return o
              .then((u) => {
                Rm(t, u, e)
              })
              .catch((u) => {
                _r(u, t, 0)
              })
          if (((t.asyncDep = o), !t.suspense)) {
            let u = (s = i.name) != null ? s : 'Anonymous'
            Z(
              `Component <${u}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
            )
          }
        } else Rm(t, o, e)
      } else rx(t, e)
    }
    function Rm(t, e, s) {
      b.isFunction(e)
        ? t.type.__ssrInlineRender
          ? (t.ssrRender = e)
          : (t.render = e)
        : b.isObject(e)
        ? (Bi(e) &&
            Z(
              'setup() should not return VNodes directly - return a render function instead.'
            ),
          (t.devtoolsRawSetupState = e),
          (t.setupState = te.proxyRefs(e)),
          NR(t))
        : e !== void 0 &&
          Z(
            `setup() should return an object. Received: ${
              e === null ? 'null' : typeof e
            }`
          ),
        rx(t, s)
    }
    var mu, Lm
    function GL(t) {
      ;(mu = t),
        (Lm = (e) => {
          e.render._rc && (e.withProxy = new Proxy(e.ctx, PR))
        })
    }
    var ix = () => !mu
    function rx(t, e, s) {
      let i = t.type
      if (!t.render) {
        if (!e && mu && !i.render) {
          let r = i.template || hm(t).template
          if (r) {
            ki(t, 'compile')
            let { isCustomElement: n, compilerOptions: a } =
                t.appContext.config,
              { delimiters: o, compilerOptions: u } = i,
              l = b.extend(
                b.extend({ isCustomElement: n, delimiters: o }, a),
                u
              )
            ;(i.render = mu(r, l)), Di(t, 'compile')
          }
        }
        ;(t.render = i.render || b.NOOP), Lm && Lm(t)
      }
      {
        let r = On(t)
        te.pauseTracking()
        try {
          jR(t)
        } finally {
          te.resetTracking(), r()
        }
      }
      !i.render &&
        t.render === b.NOOP &&
        !e &&
        (!mu && i.template
          ? Z(
              'Component provided template option but runtime compilation is not supported in this build of Vue.'
            )
          : Z('Component is missing template or render function: ', i))
    }
    var WL = {
      get(t, e) {
        return Pf(), te.track(t, 'get', ''), t[e]
      },
      set() {
        return Z('setupContext.attrs is readonly.'), !1
      },
      deleteProperty() {
        return Z('setupContext.attrs is readonly.'), !1
      },
    }
    function zL(t) {
      return new Proxy(t.slots, {
        get(e, s) {
          return te.track(t, 'get', '$slots'), e[s]
        },
      })
    }
    function nx(t) {
      let e = (s) => {
        if (
          (t.exposed && Z('expose() should be called only once per setup().'),
          s != null)
        ) {
          let i = typeof s
          i === 'object' &&
            (b.isArray(s) ? (i = 'array') : te.isRef(s) && (i = 'ref')),
            i !== 'object' &&
              Z(`expose() should be passed a plain object, received ${i}.`)
        }
        t.exposed = s || {}
      }
      {
        let s, i
        return Object.freeze({
          get attrs() {
            return s || (s = new Proxy(t.attrs, WL))
          },
          get slots() {
            return i || (i = zL(t))
          },
          get emit() {
            return (r, ...n) => t.emit(r, ...n)
          },
          expose: e,
        })
      }
    }
    function gu(t) {
      return t.exposed
        ? t.exposeProxy ||
            (t.exposeProxy = new Proxy(te.proxyRefs(te.markRaw(t.exposed)), {
              get(e, s) {
                if (s in e) return e[s]
                if (s in _n) return _n[s](t)
              },
              has(e, s) {
                return s in e || s in _n
              },
            }))
        : t.proxy
    }
    var JL = /(?:^|[-_])(\w)/g,
      YL = (t) => t.replace(JL, (e) => e.toUpperCase()).replace(/[-_]/g, '')
    function yu(t, e = !0) {
      return b.isFunction(t)
        ? t.displayName || t.name
        : t.name || (e && t.__name)
    }
    function wf(t, e, s = !1) {
      let i = yu(e)
      if (!i && e.__file) {
        let r = e.__file.match(/([^/\\]+)\.\w+$/)
        r && (i = r[1])
      }
      if (!i && t && t.parent) {
        let r = (n) => {
          for (let a in n) if (n[a] === e) return a
        }
        i =
          r(t.components || t.parent.type.components) ||
          r(t.appContext.components)
      }
      return i ? YL(i) : s ? 'App' : 'Anonymous'
    }
    function ax(t) {
      return b.isFunction(t) && '__vccOpts' in t
    }
    var ox = (t, e) => {
      let s = te.computed(t, e, du)
      {
        let i = In()
        i &&
          i.appContext.config.warnRecursiveComputed &&
          (s._warnRecursive = !0)
      }
      return s
    }
    function QL(t, e, s) {
      let i = arguments.length
      return i === 2
        ? b.isObject(e) && !b.isArray(e)
          ? Bi(e)
            ? lt(t, null, [e])
            : lt(t, e)
          : lt(t, null, e)
        : (i > 3
            ? (s = Array.prototype.slice.call(arguments, 2))
            : i === 3 && Bi(s) && (s = [s]),
          lt(t, e, s))
    }
    function ZL() {
      if (typeof window == 'undefined') return
      let t = { style: 'color:#3ba776' },
        e = { style: 'color:#1677ff' },
        s = { style: 'color:#f5222d' },
        i = { style: 'color:#eb2f96' },
        r = {
          __vue_custom_formatter: !0,
          header(f) {
            return b.isObject(f)
              ? f.__isVue
                ? ['div', t, 'VueInstance']
                : te.isRef(f)
                ? ['div', {}, ['span', t, c(f)], '<', o(f.value), '>']
                : te.isReactive(f)
                ? [
                    'div',
                    {},
                    [
                      'span',
                      t,
                      te.isShallow(f) ? 'ShallowReactive' : 'Reactive',
                    ],
                    '<',
                    o(f),
                    `>${te.isReadonly(f) ? ' (readonly)' : ''}`,
                  ]
                : te.isReadonly(f)
                ? [
                    'div',
                    {},
                    [
                      'span',
                      t,
                      te.isShallow(f) ? 'ShallowReadonly' : 'Readonly',
                    ],
                    '<',
                    o(f),
                    '>',
                  ]
                : null
              : null
          },
          hasBody(f) {
            return f && f.__isVue
          },
          body(f) {
            if (f && f.__isVue) return ['div', {}, ...n(f.$)]
          },
        }
      function n(f) {
        let h = []
        f.type.props && f.props && h.push(a('props', te.toRaw(f.props))),
          f.setupState !== b.EMPTY_OBJ && h.push(a('setup', f.setupState)),
          f.data !== b.EMPTY_OBJ && h.push(a('data', te.toRaw(f.data)))
        let p = u(f, 'computed')
        p && h.push(a('computed', p))
        let m = u(f, 'inject')
        return (
          m && h.push(a('injected', m)),
          h.push([
            'div',
            {},
            ['span', { style: i.style + ';opacity:0.66' }, '$ (internal): '],
            ['object', { object: f }],
          ]),
          h
        )
      }
      function a(f, h) {
        return (
          (h = b.extend({}, h)),
          Object.keys(h).length
            ? [
                'div',
                { style: 'line-height:1.25em;margin-bottom:0.6em' },
                ['div', { style: 'color:#476582' }, f],
                [
                  'div',
                  { style: 'padding-left:1.25em' },
                  ...Object.keys(h).map((p) => [
                    'div',
                    {},
                    ['span', i, p + ': '],
                    o(h[p], !1),
                  ]),
                ],
              ]
            : ['span', {}]
        )
      }
      function o(f, h = !0) {
        return typeof f == 'number'
          ? ['span', e, f]
          : typeof f == 'string'
          ? ['span', s, JSON.stringify(f)]
          : typeof f == 'boolean'
          ? ['span', i, f]
          : b.isObject(f)
          ? ['object', { object: h ? te.toRaw(f) : f }]
          : ['span', s, String(f)]
      }
      function u(f, h) {
        let p = f.type
        if (b.isFunction(p)) return
        let m = {}
        for (let y in f.ctx) l(p, y, h) && (m[y] = f.ctx[y])
        return m
      }
      function l(f, h, p) {
        let m = f[p]
        if (
          (b.isArray(m) && m.includes(h)) ||
          (b.isObject(m) && h in m) ||
          (f.extends && l(f.extends, h, p)) ||
          (f.mixins && f.mixins.some((y) => l(y, h, p)))
        )
          return !0
      }
      function c(f) {
        return te.isShallow(f) ? 'ShallowRef' : f.effect ? 'ComputedRef' : 'Ref'
      }
      window.devtoolsFormatters
        ? window.devtoolsFormatters.push(r)
        : (window.devtoolsFormatters = [r])
    }
    function ek(t, e, s, i) {
      let r = s[i]
      if (r && ux(r, t)) return r
      let n = e()
      return (n.memo = t.slice()), (n.cacheIndex = i), (s[i] = n)
    }
    function ux(t, e) {
      let s = t.memo
      if (s.length != e.length) return !1
      for (let i = 0; i < s.length; i++) if (b.hasChanged(s[i], e[i])) return !1
      return Nn > 0 && Wt && Wt.push(t), !0
    }
    var km = '3.4.34',
      tk = Z,
      sk = rf,
      ik = Xs,
      rk = J0,
      nk = {
        createComponentInstance: ex,
        setupComponent: sx,
        renderComponentRoot: Cf,
        setCurrentRenderingInstance: su,
        isVNode: Bi,
        normalizeVNode: ss,
        getComponentPublicInstance: gu,
      },
      ak = nk,
      ok = null,
      uk = null,
      lk = null
    X.EffectScope = te.EffectScope
    X.ReactiveEffect = te.ReactiveEffect
    X.TrackOpTypes = te.TrackOpTypes
    X.TriggerOpTypes = te.TriggerOpTypes
    X.customRef = te.customRef
    X.effect = te.effect
    X.effectScope = te.effectScope
    X.getCurrentScope = te.getCurrentScope
    X.isProxy = te.isProxy
    X.isReactive = te.isReactive
    X.isReadonly = te.isReadonly
    X.isRef = te.isRef
    X.isShallow = te.isShallow
    X.markRaw = te.markRaw
    X.onScopeDispose = te.onScopeDispose
    X.proxyRefs = te.proxyRefs
    X.reactive = te.reactive
    X.readonly = te.readonly
    X.ref = te.ref
    X.shallowReactive = te.shallowReactive
    X.shallowReadonly = te.shallowReadonly
    X.shallowRef = te.shallowRef
    X.stop = te.stop
    X.toRaw = te.toRaw
    X.toRef = te.toRef
    X.toRefs = te.toRefs
    X.toValue = te.toValue
    X.triggerRef = te.triggerRef
    X.unref = te.unref
    X.camelize = b.camelize
    X.capitalize = b.capitalize
    X.normalizeClass = b.normalizeClass
    X.normalizeProps = b.normalizeProps
    X.normalizeStyle = b.normalizeStyle
    X.toDisplayString = b.toDisplayString
    X.toHandlerKey = b.toHandlerKey
    X.BaseTransition = hR
    X.BaseTransitionPropsValidators = H2
    X.Comment = ut
    X.DeprecationTypes = lk
    X.ErrorCodes = q8
    X.ErrorTypeStrings = sk
    X.Fragment = Vt
    X.KeepAlive = mR
    X.Static = vn
    X.Suspense = wL
    X.Teleport = hL
    X.Text = Fi
    X.assertNumber = I2
    X.callWithAsyncErrorHandling = ks
    X.callWithErrorHandling = oi
    X.cloneVNode = Fs
    X.compatUtils = uk
    X.computed = ox
    X.createBlock = Pm
    X.createCommentVNode = $L
    X.createElementBlock = FL
    X.createElementVNode = vm
    X.createHydrationRenderer = SL
    X.createPropsRestProxy = UR
    X.createRenderer = EL
    X.createSlots = _R
    X.createStaticVNode = HL
    X.createTextVNode = Nm
    X.createVNode = lt
    X.defineAsyncComponent = pR
    X.defineComponent = K2
    X.defineEmits = OR
    X.defineExpose = wR
    X.defineModel = LR
    X.defineOptions = MR
    X.defineProps = IR
    X.defineSlots = RR
    X.devtools = ik
    X.getCurrentInstance = In
    X.getTransitionRawChildren = tm
    X.guardReactiveProps = Y_
    X.h = QL
    X.handleError = _r
    X.hasInjectionContext = JR
    X.initCustomFormatter = ZL
    X.inject = ou
    X.isMemoSame = ux
    X.isRuntimeOnly = ix
    X.isVNode = Bi
    X.mergeDefaults = BR
    X.mergeModels = VR
    X.mergeProps = Z_
    X.nextTick = w2
    X.onActivated = X2
    X.onBeforeMount = z2
    X.onBeforeUnmount = df
    X.onBeforeUpdate = J2
    X.onDeactivated = G2
    X.onErrorCaptured = e_
    X.onMounted = pf
    X.onRenderTracked = Z2
    X.onRenderTriggered = Q2
    X.onServerPrefetch = Y2
    X.onUnmounted = nm
    X.onUpdated = rm
    X.openBlock = Nf
    X.popScopeId = uR
    X.provide = l_
    X.pushScopeId = oR
    X.queuePostFlushCb = Qo
    X.registerRuntimeCompiler = GL
    X.renderList = TR
    X.renderSlot = xR
    X.resolveComponent = bR
    X.resolveDirective = SR
    X.resolveDynamicComponent = ER
    X.resolveFilter = ok
    X.resolveTransitionHooks = cf
    X.setBlockTracking = Am
    X.setDevtoolsHook = rk
    X.setTransitionHooks = ba
    X.ssrContextKey = k_
    X.ssrUtils = ak
    X.toHandlers = AR
    X.transformVNodeArgs = BL
    X.useAttrs = FR
    X.useModel = PL
    X.useSSRContext = D_
    X.useSlots = DR
    X.useTransitionState = U2
    X.version = km
    X.warn = tk
    X.watch = cu
    X.watchEffect = _L
    X.watchPostEffect = xL
    X.watchSyncEffect = F_
    X.withAsyncContext = HR
    X.withCtx = Z0
    X.withDefaults = kR
    X.withDirectives = cR
    X.withMemo = ek
    X.withScopeId = lR
  })
  var Fm = Oe((VD, Dm) => {
    'use strict'
    process.env.NODE_ENV === 'production'
      ? (Dm.exports = v2())
      : (Dm.exports = lx())
  })
  var zx = Oe((st) => {
    'use strict'
    Object.defineProperty(st, '__esModule', { value: !0 })
    var Qe = Fm(),
      he = fs(),
      ck = 'http://www.w3.org/2000/svg',
      fk = 'http://www.w3.org/1998/Math/MathML',
      Vi = typeof document != 'undefined' ? document : null,
      cx = Vi && Vi.createElement('template'),
      hk = {
        insert: (t, e, s) => {
          e.insertBefore(t, s || null)
        },
        remove: (t) => {
          let e = t.parentNode
          e && e.removeChild(t)
        },
        createElement: (t, e, s, i) => {
          let r =
            e === 'svg'
              ? Vi.createElementNS(ck, t)
              : e === 'mathml'
              ? Vi.createElementNS(fk, t)
              : s
              ? Vi.createElement(t, { is: s })
              : Vi.createElement(t)
          return (
            t === 'select' &&
              i &&
              i.multiple != null &&
              r.setAttribute('multiple', i.multiple),
            r
          )
        },
        createText: (t) => Vi.createTextNode(t),
        createComment: (t) => Vi.createComment(t),
        setText: (t, e) => {
          t.nodeValue = e
        },
        setElementText: (t, e) => {
          t.textContent = e
        },
        parentNode: (t) => t.parentNode,
        nextSibling: (t) => t.nextSibling,
        querySelector: (t) => Vi.querySelector(t),
        setScopeId(t, e) {
          t.setAttribute(e, '')
        },
        insertStaticContent(t, e, s, i, r, n) {
          let a = s ? s.previousSibling : e.lastChild
          if (r && (r === n || r.nextSibling))
            for (
              ;
              e.insertBefore(r.cloneNode(!0), s),
                !(r === n || !(r = r.nextSibling));

            );
          else {
            cx.innerHTML =
              i === 'svg'
                ? `<svg>${t}</svg>`
                : i === 'mathml'
                ? `<math>${t}</math>`
                : t
            let o = cx.content
            if (i === 'svg' || i === 'mathml') {
              let u = o.firstChild
              for (; u.firstChild; ) o.appendChild(u.firstChild)
              o.removeChild(u)
            }
            e.insertBefore(o, s)
          }
          return [
            a ? a.nextSibling : e.firstChild,
            s ? s.previousSibling : e.lastChild,
          ]
        },
      },
      Ir = 'transition',
      bu = 'animation',
      _a = Symbol('_vtc'),
      Bm = (t, { slots: e }) => Qe.h(Qe.BaseTransition, px(t), e)
    Bm.displayName = 'Transition'
    var fx = {
        name: String,
        type: String,
        css: { type: Boolean, default: !0 },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String,
      },
      pk = (Bm.props = he.extend({}, Qe.BaseTransitionPropsValidators, fx)),
      wn = (t, e = []) => {
        he.isArray(t) ? t.forEach((s) => s(...e)) : t && t(...e)
      },
      hx = (t) =>
        t ? (he.isArray(t) ? t.some((e) => e.length > 1) : t.length > 1) : !1
    function px(t) {
      let e = {}
      for (let A in t) A in fx || (e[A] = t[A])
      if (t.css === !1) return e
      let {
          name: s = 'v',
          type: i,
          duration: r,
          enterFromClass: n = `${s}-enter-from`,
          enterActiveClass: a = `${s}-enter-active`,
          enterToClass: o = `${s}-enter-to`,
          appearFromClass: u = n,
          appearActiveClass: l = a,
          appearToClass: c = o,
          leaveFromClass: f = `${s}-leave-from`,
          leaveActiveClass: h = `${s}-leave-active`,
          leaveToClass: p = `${s}-leave-to`,
        } = t,
        m = dk(r),
        y = m && m[0],
        x = m && m[1],
        {
          onBeforeEnter: C,
          onEnter: E,
          onEnterCancelled: g,
          onLeave: S,
          onLeaveCancelled: _,
          onBeforeAppear: I = C,
          onAppear: k = E,
          onAppearCancelled: L = g,
        } = e,
        N = (A, V, se) => {
          Or(A, V ? c : o), Or(A, V ? l : a), se && se()
        },
        O = (A, V) => {
          ;(A._isLeaving = !1), Or(A, f), Or(A, p), Or(A, h), V && V()
        },
        v = (A) => (V, se) => {
          let Y = A ? k : E,
            q = () => N(V, A, se)
          wn(Y, [V, q]),
            dx(() => {
              Or(V, A ? u : n), Ui(V, A ? c : o), hx(Y) || mx(V, i, y, q)
            })
        }
      return he.extend(e, {
        onBeforeEnter(A) {
          wn(C, [A]), Ui(A, n), Ui(A, a)
        },
        onBeforeAppear(A) {
          wn(I, [A]), Ui(A, u), Ui(A, l)
        },
        onEnter: v(!1),
        onAppear: v(!0),
        onLeave(A, V) {
          A._isLeaving = !0
          let se = () => O(A, V)
          Ui(A, f),
            Ui(A, h),
            Ex(),
            dx(() => {
              !A._isLeaving || (Or(A, f), Ui(A, p), hx(S) || mx(A, i, x, se))
            }),
            wn(S, [A, se])
        },
        onEnterCancelled(A) {
          N(A, !1), wn(g, [A])
        },
        onAppearCancelled(A) {
          N(A, !0), wn(L, [A])
        },
        onLeaveCancelled(A) {
          O(A), wn(_, [A])
        },
      })
    }
    function dk(t) {
      if (t == null) return null
      if (he.isObject(t)) return [Vm(t.enter), Vm(t.leave)]
      {
        let e = Vm(t)
        return [e, e]
      }
    }
    function Vm(t) {
      return he.toNumber(t)
    }
    function Ui(t, e) {
      e.split(/\s+/).forEach((s) => s && t.classList.add(s)),
        (t[_a] || (t[_a] = new Set())).add(e)
    }
    function Or(t, e) {
      e.split(/\s+/).forEach((i) => i && t.classList.remove(i))
      let s = t[_a]
      s && (s.delete(e), s.size || (t[_a] = void 0))
    }
    function dx(t) {
      requestAnimationFrame(() => {
        requestAnimationFrame(t)
      })
    }
    var mk = 0
    function mx(t, e, s, i) {
      let r = (t._endId = ++mk),
        n = () => {
          r === t._endId && i()
        }
      if (s) return setTimeout(n, s)
      let { type: a, timeout: o, propCount: u } = gx(t, e)
      if (!a) return i()
      let l = a + 'end',
        c = 0,
        f = () => {
          t.removeEventListener(l, h), n()
        },
        h = (p) => {
          p.target === t && ++c >= u && f()
        }
      setTimeout(() => {
        c < u && f()
      }, o + 1),
        t.addEventListener(l, h)
    }
    function gx(t, e) {
      let s = window.getComputedStyle(t),
        i = (m) => (s[m] || '').split(', '),
        r = i(`${Ir}Delay`),
        n = i(`${Ir}Duration`),
        a = yx(r, n),
        o = i(`${bu}Delay`),
        u = i(`${bu}Duration`),
        l = yx(o, u),
        c = null,
        f = 0,
        h = 0
      e === Ir
        ? a > 0 && ((c = Ir), (f = a), (h = n.length))
        : e === bu
        ? l > 0 && ((c = bu), (f = l), (h = u.length))
        : ((f = Math.max(a, l)),
          (c = f > 0 ? (a > l ? Ir : bu) : null),
          (h = c ? (c === Ir ? n.length : u.length) : 0))
      let p =
        c === Ir && /\b(transform|all)(,|$)/.test(i(`${Ir}Property`).toString())
      return { type: c, timeout: f, propCount: h, hasTransform: p }
    }
    function yx(t, e) {
      for (; t.length < e.length; ) t = t.concat(t)
      return Math.max(...e.map((s, i) => bx(s) + bx(t[i])))
    }
    function bx(t) {
      return t === 'auto' ? 0 : Number(t.slice(0, -1).replace(',', '.')) * 1e3
    }
    function Ex() {
      return document.body.offsetHeight
    }
    function gk(t, e, s) {
      let i = t[_a]
      i && (e = (e ? [e, ...i] : [...i]).join(' ')),
        e == null
          ? t.removeAttribute('class')
          : s
          ? t.setAttribute('class', e)
          : (t.className = e)
    }
    var Mf = Symbol('_vod'),
      Sx = Symbol('_vsh'),
      Tx = {
        beforeMount(t, { value: e }, { transition: s }) {
          ;(t[Mf] = t.style.display === 'none' ? '' : t.style.display),
            s && e ? s.beforeEnter(t) : Eu(t, e)
        },
        mounted(t, { value: e }, { transition: s }) {
          s && e && s.enter(t)
        },
        updated(t, { value: e, oldValue: s }, { transition: i }) {
          !e != !s &&
            (i
              ? e
                ? (i.beforeEnter(t), Eu(t, !0), i.enter(t))
                : i.leave(t, () => {
                    Eu(t, !1)
                  })
              : Eu(t, e))
        },
        beforeUnmount(t, { value: e }) {
          Eu(t, e)
        },
      }
    function Eu(t, e) {
      ;(t.style.display = e ? t[Mf] : 'none'), (t[Sx] = !e)
    }
    function yk() {
      Tx.getSSRProps = ({ value: t }) => {
        if (!t) return { style: { display: 'none' } }
      }
    }
    var bk = Symbol('')
    function Ek(t) {}
    var Sk = /(^|;)\s*display\s*:/
    function Tk(t, e, s) {
      let i = t.style,
        r = he.isString(s),
        n = !1
      if (s && !r) {
        if (e)
          if (he.isString(e))
            for (let a of e.split(';')) {
              let o = a.slice(0, a.indexOf(':')).trim()
              s[o] == null && Rf(i, o, '')
            }
          else for (let a in e) s[a] == null && Rf(i, a, '')
        for (let a in s) a === 'display' && (n = !0), Rf(i, a, s[a])
      } else if (r) {
        if (e !== s) {
          let a = i[bk]
          a && (s += ';' + a), (i.cssText = s), (n = Sk.test(s))
        }
      } else e && t.removeAttribute('style')
      Mf in t && ((t[Mf] = n ? i.display : ''), t[Sx] && (i.display = 'none'))
    }
    var _x = /\s*!important$/
    function Rf(t, e, s) {
      if (he.isArray(s)) s.forEach((i) => Rf(t, e, i))
      else if ((s == null && (s = ''), e.startsWith('--'))) t.setProperty(e, s)
      else {
        let i = _k(t, e)
        _x.test(s)
          ? t.setProperty(he.hyphenate(i), s.replace(_x, ''), 'important')
          : (t[i] = s)
      }
    }
    var xx = ['Webkit', 'Moz', 'ms'],
      Um = {}
    function _k(t, e) {
      let s = Um[e]
      if (s) return s
      let i = Qe.camelize(e)
      if (i !== 'filter' && i in t) return (Um[e] = i)
      i = he.capitalize(i)
      for (let r = 0; r < xx.length; r++) {
        let n = xx[r] + i
        if (n in t) return (Um[e] = n)
      }
      return e
    }
    var Ax = 'http://www.w3.org/1999/xlink'
    function Px(t, e, s, i, r, n = he.isSpecialBooleanAttr(e)) {
      i && e.startsWith('xlink:')
        ? s == null
          ? t.removeAttributeNS(Ax, e.slice(6, e.length))
          : t.setAttributeNS(Ax, e, s)
        : s == null || (n && !he.includeBooleanAttr(s))
        ? t.removeAttribute(e)
        : t.setAttribute(e, n ? '' : he.isSymbol(s) ? String(s) : s)
    }
    function xk(t, e, s, i) {
      if (e === 'innerHTML' || e === 'textContent') {
        if (s == null) return
        t[e] = s
        return
      }
      let r = t.tagName
      if (e === 'value' && r !== 'PROGRESS' && !r.includes('-')) {
        let a = r === 'OPTION' ? t.getAttribute('value') || '' : t.value,
          o = s == null ? '' : String(s)
        ;(a !== o || !('_value' in t)) && (t.value = o),
          s == null && t.removeAttribute(e),
          (t._value = s)
        return
      }
      let n = !1
      if (s === '' || s == null) {
        let a = typeof t[e]
        a === 'boolean'
          ? (s = he.includeBooleanAttr(s))
          : s == null && a === 'string'
          ? ((s = ''), (n = !0))
          : a === 'number' && ((s = 0), (n = !0))
      }
      try {
        t[e] = s
      } catch (a) {}
      n && t.removeAttribute(e)
    }
    function Hi(t, e, s, i) {
      t.addEventListener(e, s, i)
    }
    function Ak(t, e, s, i) {
      t.removeEventListener(e, s, i)
    }
    var Cx = Symbol('_vei')
    function Pk(t, e, s, i, r = null) {
      let n = t[Cx] || (t[Cx] = {}),
        a = n[e]
      if (i && a) a.value = i
      else {
        let [o, u] = Ck(e)
        if (i) {
          let l = (n[e] = Ik(i, r))
          Hi(t, o, l, u)
        } else a && (Ak(t, o, a, u), (n[e] = void 0))
      }
    }
    var vx = /(?:Once|Passive|Capture)$/
    function Ck(t) {
      let e
      if (vx.test(t)) {
        e = {}
        let i
        for (; (i = t.match(vx)); )
          (t = t.slice(0, t.length - i[0].length)), (e[i[0].toLowerCase()] = !0)
      }
      return [t[2] === ':' ? t.slice(3) : he.hyphenate(t.slice(2)), e]
    }
    var Hm = 0,
      vk = Promise.resolve(),
      Nk = () => Hm || (vk.then(() => (Hm = 0)), (Hm = Date.now()))
    function Ik(t, e) {
      let s = (i) => {
        if (!i._vts) i._vts = Date.now()
        else if (i._vts <= s.attached) return
        Qe.callWithAsyncErrorHandling(Ok(i, s.value), e, 5, [i])
      }
      return (s.value = t), (s.attached = Nk()), s
    }
    function Ok(t, e) {
      if (he.isArray(e)) {
        let s = t.stopImmediatePropagation
        return (
          (t.stopImmediatePropagation = () => {
            s.call(t), (t._stopped = !0)
          }),
          e.map((i) => (r) => !r._stopped && i && i(r))
        )
      } else return e
    }
    var Nx = (t) =>
        t.charCodeAt(0) === 111 &&
        t.charCodeAt(1) === 110 &&
        t.charCodeAt(2) > 96 &&
        t.charCodeAt(2) < 123,
      wk = (t, e, s, i, r, n) => {
        let a = r === 'svg'
        e === 'class'
          ? gk(t, i, a)
          : e === 'style'
          ? Tk(t, s, i)
          : he.isOn(e)
          ? he.isModelListener(e) || Pk(t, e, s, i, n)
          : (
              e[0] === '.'
                ? ((e = e.slice(1)), !0)
                : e[0] === '^'
                ? ((e = e.slice(1)), !1)
                : Mk(t, e, i, a)
            )
          ? (xk(t, e, i),
            !t.tagName.includes('-') &&
              (e === 'value' || e === 'checked' || e === 'selected') &&
              Px(t, e, i, a, n, e !== 'value'))
          : (e === 'true-value'
              ? (t._trueValue = i)
              : e === 'false-value' && (t._falseValue = i),
            Px(t, e, i, a))
      }
    function Mk(t, e, s, i) {
      if (i)
        return !!(
          e === 'innerHTML' ||
          e === 'textContent' ||
          (e in t && Nx(e) && he.isFunction(s))
        )
      if (
        e === 'spellcheck' ||
        e === 'draggable' ||
        e === 'translate' ||
        e === 'form' ||
        (e === 'list' && t.tagName === 'INPUT') ||
        (e === 'type' && t.tagName === 'TEXTAREA')
      )
        return !1
      if (e === 'width' || e === 'height') {
        let r = t.tagName
        if (r === 'IMG' || r === 'VIDEO' || r === 'CANVAS' || r === 'SOURCE')
          return !1
      }
      return Nx(e) && he.isString(s) ? !1 : e in t
    }
    function Ix(t, e, s) {
      let i = Qe.defineComponent(t, e)
      class r extends Su {
        constructor(a) {
          super(i, a, s)
        }
      }
      return (r.def = i), r
    }
    var Rk = (t, e) => Ix(t, e, Kx),
      Lk = typeof HTMLElement != 'undefined' ? HTMLElement : class {},
      Su = class extends Lk {
        constructor(e, s = {}, i) {
          super()
          ;(this._def = e),
            (this._props = s),
            (this._instance = null),
            (this._connected = !1),
            (this._resolved = !1),
            (this._numberProps = null),
            (this._ob = null),
            this.shadowRoot && i
              ? i(this._createVNode(), this.shadowRoot)
              : (this.attachShadow({ mode: 'open' }),
                this._def.__asyncLoader || this._resolveProps(this._def))
        }
        connectedCallback() {
          ;(this._connected = !0),
            this._instance ||
              (this._resolved ? this._update() : this._resolveDef())
        }
        disconnectedCallback() {
          ;(this._connected = !1),
            Qe.nextTick(() => {
              this._connected ||
                (this._ob && (this._ob.disconnect(), (this._ob = null)),
                qm(null, this.shadowRoot),
                (this._instance = null))
            })
        }
        _resolveDef() {
          this._resolved = !0
          for (let i = 0; i < this.attributes.length; i++)
            this._setAttr(this.attributes[i].name)
          ;(this._ob = new MutationObserver((i) => {
            for (let r of i) this._setAttr(r.attributeName)
          })),
            this._ob.observe(this, { attributes: !0 })
          let e = (i, r = !1) => {
              let { props: n, styles: a } = i,
                o
              if (n && !he.isArray(n))
                for (let u in n) {
                  let l = n[u]
                  ;(l === Number || (l && l.type === Number)) &&
                    (u in this._props &&
                      (this._props[u] = he.toNumber(this._props[u])),
                    ((o || (o = Object.create(null)))[he.camelize(u)] = !0))
                }
              ;(this._numberProps = o),
                r && this._resolveProps(i),
                this._applyStyles(a),
                this._update()
            },
            s = this._def.__asyncLoader
          s ? s().then((i) => e(i, !0)) : e(this._def)
        }
        _resolveProps(e) {
          let { props: s } = e,
            i = he.isArray(s) ? s : Object.keys(s || {})
          for (let r of Object.keys(this))
            r[0] !== '_' && i.includes(r) && this._setProp(r, this[r], !0, !1)
          for (let r of i.map(he.camelize))
            Object.defineProperty(this, r, {
              get() {
                return this._getProp(r)
              },
              set(n) {
                this._setProp(r, n)
              },
            })
        }
        _setAttr(e) {
          let s = this.hasAttribute(e) ? this.getAttribute(e) : void 0,
            i = he.camelize(e)
          this._numberProps && this._numberProps[i] && (s = he.toNumber(s)),
            this._setProp(i, s, !1)
        }
        _getProp(e) {
          return this._props[e]
        }
        _setProp(e, s, i = !0, r = !0) {
          s !== this._props[e] &&
            ((this._props[e] = s),
            r && this._instance && this._update(),
            i &&
              (s === !0
                ? this.setAttribute(he.hyphenate(e), '')
                : typeof s == 'string' || typeof s == 'number'
                ? this.setAttribute(he.hyphenate(e), s + '')
                : s || this.removeAttribute(he.hyphenate(e))))
        }
        _update() {
          qm(this._createVNode(), this.shadowRoot)
        }
        _createVNode() {
          let e = Qe.createVNode(this._def, he.extend({}, this._props))
          return (
            this._instance ||
              (e.ce = (s) => {
                ;(this._instance = s), (s.isCE = !0)
                let i = (n, a) => {
                  this.dispatchEvent(new CustomEvent(n, { detail: a }))
                }
                s.emit = (n, ...a) => {
                  i(n, a), he.hyphenate(n) !== n && i(he.hyphenate(n), a)
                }
                let r = this
                for (; (r = r && (r.parentNode || r.host)); )
                  if (r instanceof Su) {
                    ;(s.parent = r._instance),
                      (s.provides = r._instance.provides)
                    break
                  }
              }),
            e
          )
        }
        _applyStyles(e) {
          e &&
            e.forEach((s) => {
              let i = document.createElement('style')
              ;(i.textContent = s), this.shadowRoot.appendChild(i)
            })
        }
      }
    function kk(t = '$style') {
      {
        let e = Qe.getCurrentInstance()
        if (!e) return he.EMPTY_OBJ
        let s = e.type.__cssModules
        if (!s) return he.EMPTY_OBJ
        let i = s[t]
        return i || he.EMPTY_OBJ
      }
    }
    var Ox = new WeakMap(),
      wx = new WeakMap(),
      Lf = Symbol('_moveCb'),
      Mx = Symbol('_enterCb'),
      Rx = {
        name: 'TransitionGroup',
        props: he.extend({}, pk, { tag: String, moveClass: String }),
        setup(t, { slots: e }) {
          let s = Qe.getCurrentInstance(),
            i = Qe.useTransitionState(),
            r,
            n
          return (
            Qe.onUpdated(() => {
              if (!r.length) return
              let a = t.moveClass || `${t.name || 'v'}-move`
              if (!Hk(r[0].el, s.vnode.el, a)) return
              r.forEach(Bk), r.forEach(Vk)
              let o = r.filter(Uk)
              Ex(),
                o.forEach((u) => {
                  let l = u.el,
                    c = l.style
                  Ui(l, a),
                    (c.transform =
                      c.webkitTransform =
                      c.transitionDuration =
                        '')
                  let f = (l[Lf] = (h) => {
                    ;(h && h.target !== l) ||
                      ((!h || /transform$/.test(h.propertyName)) &&
                        (l.removeEventListener('transitionend', f),
                        (l[Lf] = null),
                        Or(l, a)))
                  })
                  l.addEventListener('transitionend', f)
                })
            }),
            () => {
              let a = Qe.toRaw(t),
                o = px(a),
                u = a.tag || Qe.Fragment
              if (((r = []), n))
                for (let l = 0; l < n.length; l++) {
                  let c = n[l]
                  c.el &&
                    c.el instanceof Element &&
                    (r.push(c),
                    Qe.setTransitionHooks(
                      c,
                      Qe.resolveTransitionHooks(c, o, i, s)
                    ),
                    Ox.set(c, c.el.getBoundingClientRect()))
                }
              n = e.default ? Qe.getTransitionRawChildren(e.default()) : []
              for (let l = 0; l < n.length; l++) {
                let c = n[l]
                c.key != null &&
                  Qe.setTransitionHooks(
                    c,
                    Qe.resolveTransitionHooks(c, o, i, s)
                  )
              }
              return Qe.createVNode(u, null, n)
            }
          )
        },
      },
      Dk = (t) => delete t.mode
    Rx.props
    var Fk = Rx
    function Bk(t) {
      let e = t.el
      e[Lf] && e[Lf](), e[Mx] && e[Mx]()
    }
    function Vk(t) {
      wx.set(t, t.el.getBoundingClientRect())
    }
    function Uk(t) {
      let e = Ox.get(t),
        s = wx.get(t),
        i = e.left - s.left,
        r = e.top - s.top
      if (i || r) {
        let n = t.el.style
        return (
          (n.transform = n.webkitTransform = `translate(${i}px,${r}px)`),
          (n.transitionDuration = '0s'),
          t
        )
      }
    }
    function Hk(t, e, s) {
      let i = t.cloneNode(),
        r = t[_a]
      r &&
        r.forEach((o) => {
          o.split(/\s+/).forEach((u) => u && i.classList.remove(u))
        }),
        s.split(/\s+/).forEach((o) => o && i.classList.add(o)),
        (i.style.display = 'none')
      let n = e.nodeType === 1 ? e : e.parentNode
      n.appendChild(i)
      let { hasTransform: a } = gx(i)
      return n.removeChild(i), a
    }
    var wr = (t) => {
      let e = t.props['onUpdate:modelValue'] || !1
      return he.isArray(e) ? (s) => he.invokeArrayFns(e, s) : e
    }
    function $k(t) {
      t.target.composing = !0
    }
    function Lx(t) {
      let e = t.target
      e.composing && ((e.composing = !1), e.dispatchEvent(new Event('input')))
    }
    var Bs = Symbol('_assign'),
      kf = {
        created(t, { modifiers: { lazy: e, trim: s, number: i } }, r) {
          t[Bs] = wr(r)
          let n = i || (r.props && r.props.type === 'number')
          Hi(t, e ? 'change' : 'input', (a) => {
            if (a.target.composing) return
            let o = t.value
            s && (o = o.trim()), n && (o = he.looseToNumber(o)), t[Bs](o)
          }),
            s &&
              Hi(t, 'change', () => {
                t.value = t.value.trim()
              }),
            e ||
              (Hi(t, 'compositionstart', $k),
              Hi(t, 'compositionend', Lx),
              Hi(t, 'change', Lx))
        },
        mounted(t, { value: e }) {
          t.value = e == null ? '' : e
        },
        beforeUpdate(
          t,
          { value: e, oldValue: s, modifiers: { lazy: i, trim: r, number: n } },
          a
        ) {
          if (((t[Bs] = wr(a)), t.composing)) return
          let o =
              (n || t.type === 'number') && !/^0\d/.test(t.value)
                ? he.looseToNumber(t.value)
                : t.value,
            u = e == null ? '' : e
          o !== u &&
            ((document.activeElement === t &&
              t.type !== 'range' &&
              ((i && e === s) || (r && t.value.trim() === u))) ||
              (t.value = u))
        },
      },
      $m = {
        deep: !0,
        created(t, e, s) {
          ;(t[Bs] = wr(s)),
            Hi(t, 'change', () => {
              let i = t._modelValue,
                r = xa(t),
                n = t.checked,
                a = t[Bs]
              if (he.isArray(i)) {
                let o = he.looseIndexOf(i, r),
                  u = o !== -1
                if (n && !u) a(i.concat(r))
                else if (!n && u) {
                  let l = [...i]
                  l.splice(o, 1), a(l)
                }
              } else if (he.isSet(i)) {
                let o = new Set(i)
                n ? o.add(r) : o.delete(r), a(o)
              } else a(Bx(t, n))
            })
        },
        mounted: kx,
        beforeUpdate(t, e, s) {
          ;(t[Bs] = wr(s)), kx(t, e, s)
        },
      }
    function kx(t, { value: e, oldValue: s }, i) {
      ;(t._modelValue = e),
        he.isArray(e)
          ? (t.checked = he.looseIndexOf(e, i.props.value) > -1)
          : he.isSet(e)
          ? (t.checked = e.has(i.props.value))
          : e !== s && (t.checked = he.looseEqual(e, Bx(t, !0)))
    }
    var jm = {
        created(t, { value: e }, s) {
          ;(t.checked = he.looseEqual(e, s.props.value)),
            (t[Bs] = wr(s)),
            Hi(t, 'change', () => {
              t[Bs](xa(t))
            })
        },
        beforeUpdate(t, { value: e, oldValue: s }, i) {
          ;(t[Bs] = wr(i)),
            e !== s && (t.checked = he.looseEqual(e, i.props.value))
        },
      },
      Dx = {
        deep: !0,
        created(t, { value: e, modifiers: { number: s } }, i) {
          let r = he.isSet(e)
          Hi(t, 'change', () => {
            let n = Array.prototype.filter
              .call(t.options, (a) => a.selected)
              .map((a) => (s ? he.looseToNumber(xa(a)) : xa(a)))
            t[Bs](t.multiple ? (r ? new Set(n) : n) : n[0]),
              (t._assigning = !0),
              Qe.nextTick(() => {
                t._assigning = !1
              })
          }),
            (t[Bs] = wr(i))
        },
        mounted(t, { value: e, modifiers: { number: s } }) {
          Fx(t, e)
        },
        beforeUpdate(t, e, s) {
          t[Bs] = wr(s)
        },
        updated(t, { value: e, modifiers: { number: s } }) {
          t._assigning || Fx(t, e)
        },
      }
    function Fx(t, e, s) {
      let i = t.multiple,
        r = he.isArray(e)
      if (!(i && !r && !he.isSet(e))) {
        for (let n = 0, a = t.options.length; n < a; n++) {
          let o = t.options[n],
            u = xa(o)
          if (i)
            if (r) {
              let l = typeof u
              l === 'string' || l === 'number'
                ? (o.selected = e.some((c) => String(c) === String(u)))
                : (o.selected = he.looseIndexOf(e, u) > -1)
            } else o.selected = e.has(u)
          else if (he.looseEqual(xa(o), e)) {
            t.selectedIndex !== n && (t.selectedIndex = n)
            return
          }
        }
        !i && t.selectedIndex !== -1 && (t.selectedIndex = -1)
      }
    }
    function xa(t) {
      return '_value' in t ? t._value : t.value
    }
    function Bx(t, e) {
      let s = e ? '_trueValue' : '_falseValue'
      return s in t ? t[s] : e
    }
    var Vx = {
      created(t, e, s) {
        Df(t, e, s, null, 'created')
      },
      mounted(t, e, s) {
        Df(t, e, s, null, 'mounted')
      },
      beforeUpdate(t, e, s, i) {
        Df(t, e, s, i, 'beforeUpdate')
      },
      updated(t, e, s, i) {
        Df(t, e, s, i, 'updated')
      },
    }
    function Ux(t, e) {
      switch (t) {
        case 'SELECT':
          return Dx
        case 'TEXTAREA':
          return kf
        default:
          switch (e) {
            case 'checkbox':
              return $m
            case 'radio':
              return jm
            default:
              return kf
          }
      }
    }
    function Df(t, e, s, i, r) {
      let a = Ux(t.tagName, s.props && s.props.type)[r]
      a && a(t, e, s, i)
    }
    function jk() {
      ;(kf.getSSRProps = ({ value: t }) => ({ value: t })),
        (jm.getSSRProps = ({ value: t }, e) => {
          if (e.props && he.looseEqual(e.props.value, t)) return { checked: !0 }
        }),
        ($m.getSSRProps = ({ value: t }, e) => {
          if (he.isArray(t)) {
            if (e.props && he.looseIndexOf(t, e.props.value) > -1)
              return { checked: !0 }
          } else if (he.isSet(t)) {
            if (e.props && t.has(e.props.value)) return { checked: !0 }
          } else if (t) return { checked: !0 }
        }),
        (Vx.getSSRProps = (t, e) => {
          if (typeof e.type != 'string') return
          let s = Ux(e.type.toUpperCase(), e.props && e.props.type)
          if (s.getSSRProps) return s.getSSRProps(t, e)
        })
    }
    var qk = ['ctrl', 'shift', 'alt', 'meta'],
      Kk = {
        stop: (t) => t.stopPropagation(),
        prevent: (t) => t.preventDefault(),
        self: (t) => t.target !== t.currentTarget,
        ctrl: (t) => !t.ctrlKey,
        shift: (t) => !t.shiftKey,
        alt: (t) => !t.altKey,
        meta: (t) => !t.metaKey,
        left: (t) => 'button' in t && t.button !== 0,
        middle: (t) => 'button' in t && t.button !== 1,
        right: (t) => 'button' in t && t.button !== 2,
        exact: (t, e) => qk.some((s) => t[`${s}Key`] && !e.includes(s)),
      },
      Xk = (t, e) => {
        let s = t._withMods || (t._withMods = {}),
          i = e.join('.')
        return (
          s[i] ||
          (s[i] = (r, ...n) => {
            for (let a = 0; a < e.length; a++) {
              let o = Kk[e[a]]
              if (o && o(r, e)) return
            }
            return t(r, ...n)
          })
        )
      },
      Gk = {
        esc: 'escape',
        space: ' ',
        up: 'arrow-up',
        left: 'arrow-left',
        right: 'arrow-right',
        down: 'arrow-down',
        delete: 'backspace',
      },
      Wk = (t, e) => {
        let s = t._withKeys || (t._withKeys = {}),
          i = e.join('.')
        return (
          s[i] ||
          (s[i] = (r) => {
            if (!('key' in r)) return
            let n = he.hyphenate(r.key)
            if (e.some((a) => a === n || Gk[a] === n)) return t(r)
          })
        )
      },
      Hx = he.extend({ patchProp: wk }, hk),
      Tu,
      $x = !1
    function jx() {
      return Tu || (Tu = Qe.createRenderer(Hx))
    }
    function qx() {
      return (Tu = $x ? Tu : Qe.createHydrationRenderer(Hx)), ($x = !0), Tu
    }
    var qm = (...t) => {
        jx().render(...t)
      },
      Kx = (...t) => {
        qx().hydrate(...t)
      },
      zk = (...t) => {
        let e = jx().createApp(...t),
          { mount: s } = e
        return (
          (e.mount = (i) => {
            let r = Gx(i)
            if (!r) return
            let n = e._component
            !he.isFunction(n) &&
              !n.render &&
              !n.template &&
              (n.template = r.innerHTML),
              (r.innerHTML = '')
            let a = s(r, !1, Xx(r))
            return (
              r instanceof Element &&
                (r.removeAttribute('v-cloak'),
                r.setAttribute('data-v-app', '')),
              a
            )
          }),
          e
        )
      },
      Jk = (...t) => {
        let e = qx().createApp(...t),
          { mount: s } = e
        return (
          (e.mount = (i) => {
            let r = Gx(i)
            if (r) return s(r, !0, Xx(r))
          }),
          e
        )
      }
    function Xx(t) {
      if (t instanceof SVGElement) return 'svg'
      if (typeof MathMLElement == 'function' && t instanceof MathMLElement)
        return 'mathml'
    }
    function Gx(t) {
      return he.isString(t) ? document.querySelector(t) : t
    }
    var Wx = !1,
      Yk = () => {
        Wx || ((Wx = !0), jk(), yk())
      }
    st.Transition = Bm
    st.TransitionGroup = Fk
    st.VueElement = Su
    st.createApp = zk
    st.createSSRApp = Jk
    st.defineCustomElement = Ix
    st.defineSSRCustomElement = Rk
    st.hydrate = Kx
    st.initDirectivesForSSR = Yk
    st.render = qm
    st.useCssModule = kk
    st.useCssVars = Ek
    st.vModelCheckbox = $m
    st.vModelDynamic = Vx
    st.vModelRadio = jm
    st.vModelSelect = Dx
    st.vModelText = kf
    st.vShow = Tx
    st.withKeys = Wk
    st.withModifiers = Xk
    Object.keys(Qe).forEach(function (t) {
      t !== 'default' &&
        !Object.prototype.hasOwnProperty.call(st, t) &&
        (st[t] = Qe[t])
    })
  })
  var FA = Oe((it) => {
    'use strict'
    Object.defineProperty(it, '__esModule', { value: !0 })
    var Ce = Fm(),
      le = fs(),
      Qk = 'http://www.w3.org/2000/svg',
      Zk = 'http://www.w3.org/1998/Math/MathML',
      $i = typeof document != 'undefined' ? document : null,
      Jx = $i && $i.createElement('template'),
      e5 = {
        insert: (t, e, s) => {
          e.insertBefore(t, s || null)
        },
        remove: (t) => {
          let e = t.parentNode
          e && e.removeChild(t)
        },
        createElement: (t, e, s, i) => {
          let r =
            e === 'svg'
              ? $i.createElementNS(Qk, t)
              : e === 'mathml'
              ? $i.createElementNS(Zk, t)
              : s
              ? $i.createElement(t, { is: s })
              : $i.createElement(t)
          return (
            t === 'select' &&
              i &&
              i.multiple != null &&
              r.setAttribute('multiple', i.multiple),
            r
          )
        },
        createText: (t) => $i.createTextNode(t),
        createComment: (t) => $i.createComment(t),
        setText: (t, e) => {
          t.nodeValue = e
        },
        setElementText: (t, e) => {
          t.textContent = e
        },
        parentNode: (t) => t.parentNode,
        nextSibling: (t) => t.nextSibling,
        querySelector: (t) => $i.querySelector(t),
        setScopeId(t, e) {
          t.setAttribute(e, '')
        },
        insertStaticContent(t, e, s, i, r, n) {
          let a = s ? s.previousSibling : e.lastChild
          if (r && (r === n || r.nextSibling))
            for (
              ;
              e.insertBefore(r.cloneNode(!0), s),
                !(r === n || !(r = r.nextSibling));

            );
          else {
            Jx.innerHTML =
              i === 'svg'
                ? `<svg>${t}</svg>`
                : i === 'mathml'
                ? `<math>${t}</math>`
                : t
            let o = Jx.content
            if (i === 'svg' || i === 'mathml') {
              let u = o.firstChild
              for (; u.firstChild; ) o.appendChild(u.firstChild)
              o.removeChild(u)
            }
            e.insertBefore(o, s)
          }
          return [
            a ? a.nextSibling : e.firstChild,
            s ? s.previousSibling : e.lastChild,
          ]
        },
      },
      Mr = 'transition',
      _u = 'animation',
      Aa = Symbol('_vtc'),
      Km = (t, { slots: e }) => Ce.h(Ce.BaseTransition, Zx(t), e)
    Km.displayName = 'Transition'
    var Yx = {
        name: String,
        type: String,
        css: { type: Boolean, default: !0 },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String,
      },
      t5 = (Km.props = le.extend({}, Ce.BaseTransitionPropsValidators, Yx)),
      Mn = (t, e = []) => {
        le.isArray(t) ? t.forEach((s) => s(...e)) : t && t(...e)
      },
      Qx = (t) =>
        t ? (le.isArray(t) ? t.some((e) => e.length > 1) : t.length > 1) : !1
    function Zx(t) {
      let e = {}
      for (let A in t) A in Yx || (e[A] = t[A])
      if (t.css === !1) return e
      let {
          name: s = 'v',
          type: i,
          duration: r,
          enterFromClass: n = `${s}-enter-from`,
          enterActiveClass: a = `${s}-enter-active`,
          enterToClass: o = `${s}-enter-to`,
          appearFromClass: u = n,
          appearActiveClass: l = a,
          appearToClass: c = o,
          leaveFromClass: f = `${s}-leave-from`,
          leaveActiveClass: h = `${s}-leave-active`,
          leaveToClass: p = `${s}-leave-to`,
        } = t,
        m = s5(r),
        y = m && m[0],
        x = m && m[1],
        {
          onBeforeEnter: C,
          onEnter: E,
          onEnterCancelled: g,
          onLeave: S,
          onLeaveCancelled: _,
          onBeforeAppear: I = C,
          onAppear: k = E,
          onAppearCancelled: L = g,
        } = e,
        N = (A, V, se) => {
          Rr(A, V ? c : o), Rr(A, V ? l : a), se && se()
        },
        O = (A, V) => {
          ;(A._isLeaving = !1), Rr(A, f), Rr(A, p), Rr(A, h), V && V()
        },
        v = (A) => (V, se) => {
          let Y = A ? k : E,
            q = () => N(V, A, se)
          Mn(Y, [V, q]),
            eA(() => {
              Rr(V, A ? u : n), ji(V, A ? c : o), Qx(Y) || tA(V, i, y, q)
            })
        }
      return le.extend(e, {
        onBeforeEnter(A) {
          Mn(C, [A]), ji(A, n), ji(A, a)
        },
        onBeforeAppear(A) {
          Mn(I, [A]), ji(A, u), ji(A, l)
        },
        onEnter: v(!1),
        onAppear: v(!0),
        onLeave(A, V) {
          A._isLeaving = !0
          let se = () => O(A, V)
          ji(A, f),
            ji(A, h),
            nA(),
            eA(() => {
              !A._isLeaving || (Rr(A, f), ji(A, p), Qx(S) || tA(A, i, x, se))
            }),
            Mn(S, [A, se])
        },
        onEnterCancelled(A) {
          N(A, !1), Mn(g, [A])
        },
        onAppearCancelled(A) {
          N(A, !0), Mn(L, [A])
        },
        onLeaveCancelled(A) {
          O(A), Mn(_, [A])
        },
      })
    }
    function s5(t) {
      if (t == null) return null
      if (le.isObject(t)) return [Xm(t.enter), Xm(t.leave)]
      {
        let e = Xm(t)
        return [e, e]
      }
    }
    function Xm(t) {
      let e = le.toNumber(t)
      return Ce.assertNumber(e, '<transition> explicit duration'), e
    }
    function ji(t, e) {
      e.split(/\s+/).forEach((s) => s && t.classList.add(s)),
        (t[Aa] || (t[Aa] = new Set())).add(e)
    }
    function Rr(t, e) {
      e.split(/\s+/).forEach((i) => i && t.classList.remove(i))
      let s = t[Aa]
      s && (s.delete(e), s.size || (t[Aa] = void 0))
    }
    function eA(t) {
      requestAnimationFrame(() => {
        requestAnimationFrame(t)
      })
    }
    var i5 = 0
    function tA(t, e, s, i) {
      let r = (t._endId = ++i5),
        n = () => {
          r === t._endId && i()
        }
      if (s) return setTimeout(n, s)
      let { type: a, timeout: o, propCount: u } = sA(t, e)
      if (!a) return i()
      let l = a + 'end',
        c = 0,
        f = () => {
          t.removeEventListener(l, h), n()
        },
        h = (p) => {
          p.target === t && ++c >= u && f()
        }
      setTimeout(() => {
        c < u && f()
      }, o + 1),
        t.addEventListener(l, h)
    }
    function sA(t, e) {
      let s = window.getComputedStyle(t),
        i = (m) => (s[m] || '').split(', '),
        r = i(`${Mr}Delay`),
        n = i(`${Mr}Duration`),
        a = iA(r, n),
        o = i(`${_u}Delay`),
        u = i(`${_u}Duration`),
        l = iA(o, u),
        c = null,
        f = 0,
        h = 0
      e === Mr
        ? a > 0 && ((c = Mr), (f = a), (h = n.length))
        : e === _u
        ? l > 0 && ((c = _u), (f = l), (h = u.length))
        : ((f = Math.max(a, l)),
          (c = f > 0 ? (a > l ? Mr : _u) : null),
          (h = c ? (c === Mr ? n.length : u.length) : 0))
      let p =
        c === Mr && /\b(transform|all)(,|$)/.test(i(`${Mr}Property`).toString())
      return { type: c, timeout: f, propCount: h, hasTransform: p }
    }
    function iA(t, e) {
      for (; t.length < e.length; ) t = t.concat(t)
      return Math.max(...e.map((s, i) => rA(s) + rA(t[i])))
    }
    function rA(t) {
      return t === 'auto' ? 0 : Number(t.slice(0, -1).replace(',', '.')) * 1e3
    }
    function nA() {
      return document.body.offsetHeight
    }
    function r5(t, e, s) {
      let i = t[Aa]
      i && (e = (e ? [e, ...i] : [...i]).join(' ')),
        e == null
          ? t.removeAttribute('class')
          : s
          ? t.setAttribute('class', e)
          : (t.className = e)
    }
    var Ff = Symbol('_vod'),
      aA = Symbol('_vsh'),
      Gm = {
        beforeMount(t, { value: e }, { transition: s }) {
          ;(t[Ff] = t.style.display === 'none' ? '' : t.style.display),
            s && e ? s.beforeEnter(t) : xu(t, e)
        },
        mounted(t, { value: e }, { transition: s }) {
          s && e && s.enter(t)
        },
        updated(t, { value: e, oldValue: s }, { transition: i }) {
          !e != !s &&
            (i
              ? e
                ? (i.beforeEnter(t), xu(t, !0), i.enter(t))
                : i.leave(t, () => {
                    xu(t, !1)
                  })
              : xu(t, e))
        },
        beforeUnmount(t, { value: e }) {
          xu(t, e)
        },
      }
    Gm.name = 'show'
    function xu(t, e) {
      ;(t.style.display = e ? t[Ff] : 'none'), (t[aA] = !e)
    }
    function n5() {
      Gm.getSSRProps = ({ value: t }) => {
        if (!t) return { style: { display: 'none' } }
      }
    }
    var a5 = Symbol('CSS_VAR_TEXT')
    function o5(t) {}
    var u5 = /(^|;)\s*display\s*:/
    function l5(t, e, s) {
      let i = t.style,
        r = le.isString(s),
        n = !1
      if (s && !r) {
        if (e)
          if (le.isString(e))
            for (let a of e.split(';')) {
              let o = a.slice(0, a.indexOf(':')).trim()
              s[o] == null && Bf(i, o, '')
            }
          else for (let a in e) s[a] == null && Bf(i, a, '')
        for (let a in s) a === 'display' && (n = !0), Bf(i, a, s[a])
      } else if (r) {
        if (e !== s) {
          let a = i[a5]
          a && (s += ';' + a), (i.cssText = s), (n = u5.test(s))
        }
      } else e && t.removeAttribute('style')
      Ff in t && ((t[Ff] = n ? i.display : ''), t[aA] && (i.display = 'none'))
    }
    var c5 = /[^\\];\s*$/,
      oA = /\s*!important$/
    function Bf(t, e, s) {
      if (le.isArray(s)) s.forEach((i) => Bf(t, e, i))
      else if (
        (s == null && (s = ''),
        c5.test(s) &&
          Ce.warn(
            `Unexpected semicolon at the end of '${e}' style value: '${s}'`
          ),
        e.startsWith('--'))
      )
        t.setProperty(e, s)
      else {
        let i = f5(t, e)
        oA.test(s)
          ? t.setProperty(le.hyphenate(i), s.replace(oA, ''), 'important')
          : (t[i] = s)
      }
    }
    var uA = ['Webkit', 'Moz', 'ms'],
      Wm = {}
    function f5(t, e) {
      let s = Wm[e]
      if (s) return s
      let i = Ce.camelize(e)
      if (i !== 'filter' && i in t) return (Wm[e] = i)
      i = le.capitalize(i)
      for (let r = 0; r < uA.length; r++) {
        let n = uA[r] + i
        if (n in t) return (Wm[e] = n)
      }
      return e
    }
    var lA = 'http://www.w3.org/1999/xlink'
    function cA(t, e, s, i, r, n = le.isSpecialBooleanAttr(e)) {
      i && e.startsWith('xlink:')
        ? s == null
          ? t.removeAttributeNS(lA, e.slice(6, e.length))
          : t.setAttributeNS(lA, e, s)
        : s == null || (n && !le.includeBooleanAttr(s))
        ? t.removeAttribute(e)
        : t.setAttribute(e, n ? '' : le.isSymbol(s) ? String(s) : s)
    }
    function h5(t, e, s, i) {
      if (e === 'innerHTML' || e === 'textContent') {
        if (s == null) return
        t[e] = s
        return
      }
      let r = t.tagName
      if (e === 'value' && r !== 'PROGRESS' && !r.includes('-')) {
        let a = r === 'OPTION' ? t.getAttribute('value') || '' : t.value,
          o = s == null ? '' : String(s)
        ;(a !== o || !('_value' in t)) && (t.value = o),
          s == null && t.removeAttribute(e),
          (t._value = s)
        return
      }
      let n = !1
      if (s === '' || s == null) {
        let a = typeof t[e]
        a === 'boolean'
          ? (s = le.includeBooleanAttr(s))
          : s == null && a === 'string'
          ? ((s = ''), (n = !0))
          : a === 'number' && ((s = 0), (n = !0))
      }
      try {
        t[e] = s
      } catch (a) {
        n ||
          Ce.warn(
            `Failed setting prop "${e}" on <${r.toLowerCase()}>: value ${s} is invalid.`,
            a
          )
      }
      n && t.removeAttribute(e)
    }
    function qi(t, e, s, i) {
      t.addEventListener(e, s, i)
    }
    function p5(t, e, s, i) {
      t.removeEventListener(e, s, i)
    }
    var fA = Symbol('_vei')
    function d5(t, e, s, i, r = null) {
      let n = t[fA] || (t[fA] = {}),
        a = n[e]
      if (i && a) a.value = pA(i, e)
      else {
        let [o, u] = m5(e)
        if (i) {
          let l = (n[e] = b5(pA(i, e), r))
          qi(t, o, l, u)
        } else a && (p5(t, o, a, u), (n[e] = void 0))
      }
    }
    var hA = /(?:Once|Passive|Capture)$/
    function m5(t) {
      let e
      if (hA.test(t)) {
        e = {}
        let i
        for (; (i = t.match(hA)); )
          (t = t.slice(0, t.length - i[0].length)), (e[i[0].toLowerCase()] = !0)
      }
      return [t[2] === ':' ? t.slice(3) : le.hyphenate(t.slice(2)), e]
    }
    var zm = 0,
      g5 = Promise.resolve(),
      y5 = () => zm || (g5.then(() => (zm = 0)), (zm = Date.now()))
    function b5(t, e) {
      let s = (i) => {
        if (!i._vts) i._vts = Date.now()
        else if (i._vts <= s.attached) return
        Ce.callWithAsyncErrorHandling(E5(i, s.value), e, 5, [i])
      }
      return (s.value = t), (s.attached = y5()), s
    }
    function pA(t, e) {
      return le.isFunction(t) || le.isArray(t)
        ? t
        : (Ce.warn(`Wrong type passed as event handler to ${e} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof t}.`),
          le.NOOP)
    }
    function E5(t, e) {
      if (le.isArray(e)) {
        let s = t.stopImmediatePropagation
        return (
          (t.stopImmediatePropagation = () => {
            s.call(t), (t._stopped = !0)
          }),
          e.map((i) => (r) => !r._stopped && i && i(r))
        )
      } else return e
    }
    var dA = (t) =>
        t.charCodeAt(0) === 111 &&
        t.charCodeAt(1) === 110 &&
        t.charCodeAt(2) > 96 &&
        t.charCodeAt(2) < 123,
      S5 = (t, e, s, i, r, n) => {
        let a = r === 'svg'
        e === 'class'
          ? r5(t, i, a)
          : e === 'style'
          ? l5(t, s, i)
          : le.isOn(e)
          ? le.isModelListener(e) || d5(t, e, s, i, n)
          : (
              e[0] === '.'
                ? ((e = e.slice(1)), !0)
                : e[0] === '^'
                ? ((e = e.slice(1)), !1)
                : T5(t, e, i, a)
            )
          ? (h5(t, e, i),
            !t.tagName.includes('-') &&
              (e === 'value' || e === 'checked' || e === 'selected') &&
              cA(t, e, i, a, n, e !== 'value'))
          : (e === 'true-value'
              ? (t._trueValue = i)
              : e === 'false-value' && (t._falseValue = i),
            cA(t, e, i, a))
      }
    function T5(t, e, s, i) {
      if (i)
        return !!(
          e === 'innerHTML' ||
          e === 'textContent' ||
          (e in t && dA(e) && le.isFunction(s))
        )
      if (
        e === 'spellcheck' ||
        e === 'draggable' ||
        e === 'translate' ||
        e === 'form' ||
        (e === 'list' && t.tagName === 'INPUT') ||
        (e === 'type' && t.tagName === 'TEXTAREA')
      )
        return !1
      if (e === 'width' || e === 'height') {
        let r = t.tagName
        if (r === 'IMG' || r === 'VIDEO' || r === 'CANVAS' || r === 'SOURCE')
          return !1
      }
      return dA(e) && le.isString(s) ? !1 : e in t
    }
    function mA(t, e, s) {
      let i = Ce.defineComponent(t, e)
      class r extends Au {
        constructor(a) {
          super(i, a, s)
        }
      }
      return (r.def = i), r
    }
    var _5 = (t, e) => mA(t, e, wA),
      x5 = typeof HTMLElement != 'undefined' ? HTMLElement : class {},
      Au = class extends x5 {
        constructor(e, s = {}, i) {
          super()
          ;(this._def = e),
            (this._props = s),
            (this._instance = null),
            (this._connected = !1),
            (this._resolved = !1),
            (this._numberProps = null),
            (this._ob = null),
            this.shadowRoot && i
              ? i(this._createVNode(), this.shadowRoot)
              : (this.shadowRoot &&
                  Ce.warn(
                    'Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`.'
                  ),
                this.attachShadow({ mode: 'open' }),
                this._def.__asyncLoader || this._resolveProps(this._def))
        }
        connectedCallback() {
          ;(this._connected = !0),
            this._instance ||
              (this._resolved ? this._update() : this._resolveDef())
        }
        disconnectedCallback() {
          ;(this._connected = !1),
            Ce.nextTick(() => {
              this._connected ||
                (this._ob && (this._ob.disconnect(), (this._ob = null)),
                Qm(null, this.shadowRoot),
                (this._instance = null))
            })
        }
        _resolveDef() {
          this._resolved = !0
          for (let i = 0; i < this.attributes.length; i++)
            this._setAttr(this.attributes[i].name)
          ;(this._ob = new MutationObserver((i) => {
            for (let r of i) this._setAttr(r.attributeName)
          })),
            this._ob.observe(this, { attributes: !0 })
          let e = (i, r = !1) => {
              let { props: n, styles: a } = i,
                o
              if (n && !le.isArray(n))
                for (let u in n) {
                  let l = n[u]
                  ;(l === Number || (l && l.type === Number)) &&
                    (u in this._props &&
                      (this._props[u] = le.toNumber(this._props[u])),
                    ((o || (o = Object.create(null)))[le.camelize(u)] = !0))
                }
              ;(this._numberProps = o),
                r && this._resolveProps(i),
                this._applyStyles(a),
                this._update()
            },
            s = this._def.__asyncLoader
          s ? s().then((i) => e(i, !0)) : e(this._def)
        }
        _resolveProps(e) {
          let { props: s } = e,
            i = le.isArray(s) ? s : Object.keys(s || {})
          for (let r of Object.keys(this))
            r[0] !== '_' && i.includes(r) && this._setProp(r, this[r], !0, !1)
          for (let r of i.map(le.camelize))
            Object.defineProperty(this, r, {
              get() {
                return this._getProp(r)
              },
              set(n) {
                this._setProp(r, n)
              },
            })
        }
        _setAttr(e) {
          let s = this.hasAttribute(e) ? this.getAttribute(e) : void 0,
            i = le.camelize(e)
          this._numberProps && this._numberProps[i] && (s = le.toNumber(s)),
            this._setProp(i, s, !1)
        }
        _getProp(e) {
          return this._props[e]
        }
        _setProp(e, s, i = !0, r = !0) {
          s !== this._props[e] &&
            ((this._props[e] = s),
            r && this._instance && this._update(),
            i &&
              (s === !0
                ? this.setAttribute(le.hyphenate(e), '')
                : typeof s == 'string' || typeof s == 'number'
                ? this.setAttribute(le.hyphenate(e), s + '')
                : s || this.removeAttribute(le.hyphenate(e))))
        }
        _update() {
          Qm(this._createVNode(), this.shadowRoot)
        }
        _createVNode() {
          let e = Ce.createVNode(this._def, le.extend({}, this._props))
          return (
            this._instance ||
              (e.ce = (s) => {
                ;(this._instance = s),
                  (s.isCE = !0),
                  (s.ceReload = (n) => {
                    this._styles &&
                      (this._styles.forEach((a) =>
                        this.shadowRoot.removeChild(a)
                      ),
                      (this._styles.length = 0)),
                      this._applyStyles(n),
                      (this._instance = null),
                      this._update()
                  })
                let i = (n, a) => {
                  this.dispatchEvent(new CustomEvent(n, { detail: a }))
                }
                s.emit = (n, ...a) => {
                  i(n, a), le.hyphenate(n) !== n && i(le.hyphenate(n), a)
                }
                let r = this
                for (; (r = r && (r.parentNode || r.host)); )
                  if (r instanceof Au) {
                    ;(s.parent = r._instance),
                      (s.provides = r._instance.provides)
                    break
                  }
              }),
            e
          )
        }
        _applyStyles(e) {
          e &&
            e.forEach((s) => {
              let i = document.createElement('style')
              ;(i.textContent = s),
                this.shadowRoot.appendChild(i),
                (this._styles || (this._styles = [])).push(i)
            })
        }
      }
    function A5(t = '$style') {
      {
        let e = Ce.getCurrentInstance()
        if (!e)
          return (
            Ce.warn('useCssModule must be called inside setup()'), le.EMPTY_OBJ
          )
        let s = e.type.__cssModules
        if (!s)
          return (
            Ce.warn('Current instance does not have CSS modules injected.'),
            le.EMPTY_OBJ
          )
        let i = s[t]
        return (
          i ||
          (Ce.warn(`Current instance does not have CSS module named "${t}".`),
          le.EMPTY_OBJ)
        )
      }
    }
    var gA = new WeakMap(),
      yA = new WeakMap(),
      Vf = Symbol('_moveCb'),
      bA = Symbol('_enterCb'),
      EA = {
        name: 'TransitionGroup',
        props: le.extend({}, t5, { tag: String, moveClass: String }),
        setup(t, { slots: e }) {
          let s = Ce.getCurrentInstance(),
            i = Ce.useTransitionState(),
            r,
            n
          return (
            Ce.onUpdated(() => {
              if (!r.length) return
              let a = t.moveClass || `${t.name || 'v'}-move`
              if (!O5(r[0].el, s.vnode.el, a)) return
              r.forEach(v5), r.forEach(N5)
              let o = r.filter(I5)
              nA(),
                o.forEach((u) => {
                  let l = u.el,
                    c = l.style
                  ji(l, a),
                    (c.transform =
                      c.webkitTransform =
                      c.transitionDuration =
                        '')
                  let f = (l[Vf] = (h) => {
                    ;(h && h.target !== l) ||
                      ((!h || /transform$/.test(h.propertyName)) &&
                        (l.removeEventListener('transitionend', f),
                        (l[Vf] = null),
                        Rr(l, a)))
                  })
                  l.addEventListener('transitionend', f)
                })
            }),
            () => {
              let a = Ce.toRaw(t),
                o = Zx(a),
                u = a.tag || Ce.Fragment
              if (((r = []), n))
                for (let l = 0; l < n.length; l++) {
                  let c = n[l]
                  c.el &&
                    c.el instanceof Element &&
                    (r.push(c),
                    Ce.setTransitionHooks(
                      c,
                      Ce.resolveTransitionHooks(c, o, i, s)
                    ),
                    gA.set(c, c.el.getBoundingClientRect()))
                }
              n = e.default ? Ce.getTransitionRawChildren(e.default()) : []
              for (let l = 0; l < n.length; l++) {
                let c = n[l]
                c.key != null
                  ? Ce.setTransitionHooks(
                      c,
                      Ce.resolveTransitionHooks(c, o, i, s)
                    )
                  : Ce.warn('<TransitionGroup> children must be keyed.')
              }
              return Ce.createVNode(u, null, n)
            }
          )
        },
      },
      P5 = (t) => delete t.mode
    EA.props
    var C5 = EA
    function v5(t) {
      let e = t.el
      e[Vf] && e[Vf](), e[bA] && e[bA]()
    }
    function N5(t) {
      yA.set(t, t.el.getBoundingClientRect())
    }
    function I5(t) {
      let e = gA.get(t),
        s = yA.get(t),
        i = e.left - s.left,
        r = e.top - s.top
      if (i || r) {
        let n = t.el.style
        return (
          (n.transform = n.webkitTransform = `translate(${i}px,${r}px)`),
          (n.transitionDuration = '0s'),
          t
        )
      }
    }
    function O5(t, e, s) {
      let i = t.cloneNode(),
        r = t[Aa]
      r &&
        r.forEach((o) => {
          o.split(/\s+/).forEach((u) => u && i.classList.remove(u))
        }),
        s.split(/\s+/).forEach((o) => o && i.classList.add(o)),
        (i.style.display = 'none')
      let n = e.nodeType === 1 ? e : e.parentNode
      n.appendChild(i)
      let { hasTransform: a } = sA(i)
      return n.removeChild(i), a
    }
    var Lr = (t) => {
      let e = t.props['onUpdate:modelValue'] || !1
      return le.isArray(e) ? (s) => le.invokeArrayFns(e, s) : e
    }
    function w5(t) {
      t.target.composing = !0
    }
    function SA(t) {
      let e = t.target
      e.composing && ((e.composing = !1), e.dispatchEvent(new Event('input')))
    }
    var Vs = Symbol('_assign'),
      Uf = {
        created(t, { modifiers: { lazy: e, trim: s, number: i } }, r) {
          t[Vs] = Lr(r)
          let n = i || (r.props && r.props.type === 'number')
          qi(t, e ? 'change' : 'input', (a) => {
            if (a.target.composing) return
            let o = t.value
            s && (o = o.trim()), n && (o = le.looseToNumber(o)), t[Vs](o)
          }),
            s &&
              qi(t, 'change', () => {
                t.value = t.value.trim()
              }),
            e ||
              (qi(t, 'compositionstart', w5),
              qi(t, 'compositionend', SA),
              qi(t, 'change', SA))
        },
        mounted(t, { value: e }) {
          t.value = e == null ? '' : e
        },
        beforeUpdate(
          t,
          { value: e, oldValue: s, modifiers: { lazy: i, trim: r, number: n } },
          a
        ) {
          if (((t[Vs] = Lr(a)), t.composing)) return
          let o =
              (n || t.type === 'number') && !/^0\d/.test(t.value)
                ? le.looseToNumber(t.value)
                : t.value,
            u = e == null ? '' : e
          o !== u &&
            ((document.activeElement === t &&
              t.type !== 'range' &&
              ((i && e === s) || (r && t.value.trim() === u))) ||
              (t.value = u))
        },
      },
      Jm = {
        deep: !0,
        created(t, e, s) {
          ;(t[Vs] = Lr(s)),
            qi(t, 'change', () => {
              let i = t._modelValue,
                r = Pa(t),
                n = t.checked,
                a = t[Vs]
              if (le.isArray(i)) {
                let o = le.looseIndexOf(i, r),
                  u = o !== -1
                if (n && !u) a(i.concat(r))
                else if (!n && u) {
                  let l = [...i]
                  l.splice(o, 1), a(l)
                }
              } else if (le.isSet(i)) {
                let o = new Set(i)
                n ? o.add(r) : o.delete(r), a(o)
              } else a(AA(t, n))
            })
        },
        mounted: TA,
        beforeUpdate(t, e, s) {
          ;(t[Vs] = Lr(s)), TA(t, e, s)
        },
      }
    function TA(t, { value: e, oldValue: s }, i) {
      ;(t._modelValue = e),
        le.isArray(e)
          ? (t.checked = le.looseIndexOf(e, i.props.value) > -1)
          : le.isSet(e)
          ? (t.checked = e.has(i.props.value))
          : e !== s && (t.checked = le.looseEqual(e, AA(t, !0)))
    }
    var Ym = {
        created(t, { value: e }, s) {
          ;(t.checked = le.looseEqual(e, s.props.value)),
            (t[Vs] = Lr(s)),
            qi(t, 'change', () => {
              t[Vs](Pa(t))
            })
        },
        beforeUpdate(t, { value: e, oldValue: s }, i) {
          ;(t[Vs] = Lr(i)),
            e !== s && (t.checked = le.looseEqual(e, i.props.value))
        },
      },
      _A = {
        deep: !0,
        created(t, { value: e, modifiers: { number: s } }, i) {
          let r = le.isSet(e)
          qi(t, 'change', () => {
            let n = Array.prototype.filter
              .call(t.options, (a) => a.selected)
              .map((a) => (s ? le.looseToNumber(Pa(a)) : Pa(a)))
            t[Vs](t.multiple ? (r ? new Set(n) : n) : n[0]),
              (t._assigning = !0),
              Ce.nextTick(() => {
                t._assigning = !1
              })
          }),
            (t[Vs] = Lr(i))
        },
        mounted(t, { value: e, modifiers: { number: s } }) {
          xA(t, e)
        },
        beforeUpdate(t, e, s) {
          t[Vs] = Lr(s)
        },
        updated(t, { value: e, modifiers: { number: s } }) {
          t._assigning || xA(t, e)
        },
      }
    function xA(t, e, s) {
      let i = t.multiple,
        r = le.isArray(e)
      if (i && !r && !le.isSet(e)) {
        Ce.warn(
          `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString
            .call(e)
            .slice(8, -1)}.`
        )
        return
      }
      for (let n = 0, a = t.options.length; n < a; n++) {
        let o = t.options[n],
          u = Pa(o)
        if (i)
          if (r) {
            let l = typeof u
            l === 'string' || l === 'number'
              ? (o.selected = e.some((c) => String(c) === String(u)))
              : (o.selected = le.looseIndexOf(e, u) > -1)
          } else o.selected = e.has(u)
        else if (le.looseEqual(Pa(o), e)) {
          t.selectedIndex !== n && (t.selectedIndex = n)
          return
        }
      }
      !i && t.selectedIndex !== -1 && (t.selectedIndex = -1)
    }
    function Pa(t) {
      return '_value' in t ? t._value : t.value
    }
    function AA(t, e) {
      let s = e ? '_trueValue' : '_falseValue'
      return s in t ? t[s] : e
    }
    var PA = {
      created(t, e, s) {
        Hf(t, e, s, null, 'created')
      },
      mounted(t, e, s) {
        Hf(t, e, s, null, 'mounted')
      },
      beforeUpdate(t, e, s, i) {
        Hf(t, e, s, i, 'beforeUpdate')
      },
      updated(t, e, s, i) {
        Hf(t, e, s, i, 'updated')
      },
    }
    function CA(t, e) {
      switch (t) {
        case 'SELECT':
          return _A
        case 'TEXTAREA':
          return Uf
        default:
          switch (e) {
            case 'checkbox':
              return Jm
            case 'radio':
              return Ym
            default:
              return Uf
          }
      }
    }
    function Hf(t, e, s, i, r) {
      let a = CA(t.tagName, s.props && s.props.type)[r]
      a && a(t, e, s, i)
    }
    function M5() {
      ;(Uf.getSSRProps = ({ value: t }) => ({ value: t })),
        (Ym.getSSRProps = ({ value: t }, e) => {
          if (e.props && le.looseEqual(e.props.value, t)) return { checked: !0 }
        }),
        (Jm.getSSRProps = ({ value: t }, e) => {
          if (le.isArray(t)) {
            if (e.props && le.looseIndexOf(t, e.props.value) > -1)
              return { checked: !0 }
          } else if (le.isSet(t)) {
            if (e.props && t.has(e.props.value)) return { checked: !0 }
          } else if (t) return { checked: !0 }
        }),
        (PA.getSSRProps = (t, e) => {
          if (typeof e.type != 'string') return
          let s = CA(e.type.toUpperCase(), e.props && e.props.type)
          if (s.getSSRProps) return s.getSSRProps(t, e)
        })
    }
    var R5 = ['ctrl', 'shift', 'alt', 'meta'],
      L5 = {
        stop: (t) => t.stopPropagation(),
        prevent: (t) => t.preventDefault(),
        self: (t) => t.target !== t.currentTarget,
        ctrl: (t) => !t.ctrlKey,
        shift: (t) => !t.shiftKey,
        alt: (t) => !t.altKey,
        meta: (t) => !t.metaKey,
        left: (t) => 'button' in t && t.button !== 0,
        middle: (t) => 'button' in t && t.button !== 1,
        right: (t) => 'button' in t && t.button !== 2,
        exact: (t, e) => R5.some((s) => t[`${s}Key`] && !e.includes(s)),
      },
      k5 = (t, e) => {
        let s = t._withMods || (t._withMods = {}),
          i = e.join('.')
        return (
          s[i] ||
          (s[i] = (r, ...n) => {
            for (let a = 0; a < e.length; a++) {
              let o = L5[e[a]]
              if (o && o(r, e)) return
            }
            return t(r, ...n)
          })
        )
      },
      D5 = {
        esc: 'escape',
        space: ' ',
        up: 'arrow-up',
        left: 'arrow-left',
        right: 'arrow-right',
        down: 'arrow-down',
        delete: 'backspace',
      },
      F5 = (t, e) => {
        let s = t._withKeys || (t._withKeys = {}),
          i = e.join('.')
        return (
          s[i] ||
          (s[i] = (r) => {
            if (!('key' in r)) return
            let n = le.hyphenate(r.key)
            if (e.some((a) => a === n || D5[a] === n)) return t(r)
          })
        )
      },
      vA = le.extend({ patchProp: S5 }, e5),
      Pu,
      NA = !1
    function IA() {
      return Pu || (Pu = Ce.createRenderer(vA))
    }
    function OA() {
      return (Pu = NA ? Pu : Ce.createHydrationRenderer(vA)), (NA = !0), Pu
    }
    var Qm = (...t) => {
        IA().render(...t)
      },
      wA = (...t) => {
        OA().hydrate(...t)
      },
      B5 = (...t) => {
        let e = IA().createApp(...t)
        RA(e), LA(e)
        let { mount: s } = e
        return (
          (e.mount = (i) => {
            let r = kA(i)
            if (!r) return
            let n = e._component
            !le.isFunction(n) &&
              !n.render &&
              !n.template &&
              (n.template = r.innerHTML),
              (r.innerHTML = '')
            let a = s(r, !1, MA(r))
            return (
              r instanceof Element &&
                (r.removeAttribute('v-cloak'),
                r.setAttribute('data-v-app', '')),
              a
            )
          }),
          e
        )
      },
      V5 = (...t) => {
        let e = OA().createApp(...t)
        RA(e), LA(e)
        let { mount: s } = e
        return (
          (e.mount = (i) => {
            let r = kA(i)
            if (r) return s(r, !0, MA(r))
          }),
          e
        )
      }
    function MA(t) {
      if (t instanceof SVGElement) return 'svg'
      if (typeof MathMLElement == 'function' && t instanceof MathMLElement)
        return 'mathml'
    }
    function RA(t) {
      Object.defineProperty(t.config, 'isNativeTag', {
        value: (e) => le.isHTMLTag(e) || le.isSVGTag(e) || le.isMathMLTag(e),
        writable: !1,
      })
    }
    function LA(t) {
      if (Ce.isRuntimeOnly()) {
        let e = t.config.isCustomElement
        Object.defineProperty(t.config, 'isCustomElement', {
          get() {
            return e
          },
          set() {
            Ce.warn(
              'The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.'
            )
          },
        })
        let s = t.config.compilerOptions,
          i =
            'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc'
        Object.defineProperty(t.config, 'compilerOptions', {
          get() {
            return Ce.warn(i), s
          },
          set() {
            Ce.warn(i)
          },
        })
      }
    }
    function kA(t) {
      if (le.isString(t)) {
        let e = document.querySelector(t)
        return (
          e ||
            Ce.warn(
              `Failed to mount app: mount target selector "${t}" returned null.`
            ),
          e
        )
      }
      return (
        window.ShadowRoot &&
          t instanceof window.ShadowRoot &&
          t.mode === 'closed' &&
          Ce.warn(
            'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
          ),
        t
      )
    }
    var DA = !1,
      U5 = () => {
        DA || ((DA = !0), M5(), n5())
      }
    it.Transition = Km
    it.TransitionGroup = C5
    it.VueElement = Au
    it.createApp = B5
    it.createSSRApp = V5
    it.defineCustomElement = mA
    it.defineSSRCustomElement = _5
    it.hydrate = wA
    it.initDirectivesForSSR = U5
    it.render = Qm
    it.useCssModule = A5
    it.useCssVars = o5
    it.vModelCheckbox = Jm
    it.vModelDynamic = PA
    it.vModelRadio = Ym
    it.vModelSelect = _A
    it.vModelText = Uf
    it.vShow = Gm
    it.withKeys = F5
    it.withModifiers = k5
    Object.keys(Ce).forEach(function (t) {
      t !== 'default' &&
        !Object.prototype.hasOwnProperty.call(it, t) &&
        (it[t] = Ce[t])
    })
  })
  var eg = Oe(($D, Zm) => {
    'use strict'
    process.env.NODE_ENV === 'production'
      ? (Zm.exports = zx())
      : (Zm.exports = FA())
  })
  var UA = Oe((Cu) => {
    'use strict'
    Object.defineProperty(Cu, '__esModule', { value: !0 })
    var H5 = Ad(),
      $f = eg(),
      Ca = fs()
    function $5(t) {
      var e = Object.create(null)
      if (t) for (var s in t) e[s] = t[s]
      return (e.default = t), Object.freeze(e)
    }
    var j5 = $5($f),
      BA = new WeakMap()
    function q5(t) {
      let e = BA.get(t != null ? t : Ca.EMPTY_OBJ)
      return (
        e ||
          ((e = Object.create(null)), BA.set(t != null ? t : Ca.EMPTY_OBJ, e)),
        e
      )
    }
    function VA(t, e) {
      if (!Ca.isString(t))
        if (t.nodeType) t = t.innerHTML
        else return Ca.NOOP
      let s = t,
        i = q5(e),
        r = i[s]
      if (r) return r
      if (t[0] === '#') {
        let u = document.querySelector(t)
        t = u ? u.innerHTML : ''
      }
      let n = Ca.extend(
        { hoistStatic: !0, onError: void 0, onWarn: Ca.NOOP },
        e
      )
      !n.isCustomElement &&
        typeof customElements != 'undefined' &&
        (n.isCustomElement = (u) => !!customElements.get(u))
      let { code: a } = H5.compile(t, n),
        o = new Function('Vue', a)(j5)
      return (o._rc = !0), (i[s] = o)
    }
    $f.registerRuntimeCompiler(VA)
    Cu.compile = VA
    Object.keys($f).forEach(function (t) {
      t !== 'default' &&
        !Object.prototype.hasOwnProperty.call(Cu, t) &&
        (Cu[t] = $f[t])
    })
  })
  var jA = Oe((vu) => {
    'use strict'
    Object.defineProperty(vu, '__esModule', { value: !0 })
    var K5 = Ad(),
      Rn = eg(),
      va = fs()
    function X5(t) {
      var e = Object.create(null)
      if (t) for (var s in t) e[s] = t[s]
      return (e.default = t), Object.freeze(e)
    }
    var G5 = X5(Rn),
      HA = new WeakMap()
    function W5(t) {
      let e = HA.get(t != null ? t : va.EMPTY_OBJ)
      return (
        e ||
          ((e = Object.create(null)), HA.set(t != null ? t : va.EMPTY_OBJ, e)),
        e
      )
    }
    function $A(t, e) {
      if (!va.isString(t))
        if (t.nodeType) t = t.innerHTML
        else return Rn.warn('invalid template option: ', t), va.NOOP
      let s = t,
        i = W5(e),
        r = i[s]
      if (r) return r
      if (t[0] === '#') {
        let l = document.querySelector(t)
        l || Rn.warn(`Template element not found or is empty: ${t}`),
          (t = l ? l.innerHTML : '')
      }
      let n = va.extend(
        { hoistStatic: !0, onError: o, onWarn: (l) => o(l, !0) },
        e
      )
      !n.isCustomElement &&
        typeof customElements != 'undefined' &&
        (n.isCustomElement = (l) => !!customElements.get(l))
      let { code: a } = K5.compile(t, n)
      function o(l, c = !1) {
        let f = c ? l.message : `Template compilation error: ${l.message}`,
          h =
            l.loc &&
            va.generateCodeFrame(t, l.loc.start.offset, l.loc.end.offset)
        Rn.warn(
          h
            ? `${f}
${h}`
            : f
        )
      }
      let u = new Function('Vue', a)(G5)
      return (u._rc = !0), (i[s] = u)
    }
    Rn.registerRuntimeCompiler($A)
    vu.compile = $A
    Object.keys(Rn).forEach(function (t) {
      t !== 'default' &&
        !Object.prototype.hasOwnProperty.call(vu, t) &&
        (vu[t] = Rn[t])
    })
  })
  var qA = Oe((KD, tg) => {
    'use strict'
    process.env.NODE_ENV === 'production'
      ? (tg.exports = UA())
      : (tg.exports = jA())
  })
  var tD = {}
  tP(tD, {
    BasePiniaHistoryOptions: () => XA,
    PiniaHistory: () => eD,
    persistentKey: () => jf,
  })
  var Ki = {}
  Kf(Ki)
  Xf(Ki, Gf(qA()))
  var Ln = Gf(ig('@emanimation/js-serial-js')),
    KA = Gf(ig('lzutf8')),
    { compress: z5, decompress: J5 } = KA.default,
    XA = {
      max: 10,
      persistent: !1,
      omit: [],
      persistentStrategy: {
        get(t, e) {
          if (typeof localStorage !== void 0) {
            let s = jf(t, e),
              i = localStorage.getItem(s)
            return i ? J5(i, { inputEncoding: 'Base64' }).split(',') : void 0
          }
        },
        set(t, e, s) {
          if (typeof localStorage !== void 0) {
            let i = jf(t, e),
              r = s.join(',')
            localStorage.setItem(i, z5(r, { outputEncoding: 'Base64' }))
          }
        },
        remove(t, e) {
          if (typeof localStorage !== void 0) {
            let s = jf(t, e)
            localStorage.removeItem(s)
          }
        },
      },
    }
  function Y5(t) {
    return { ...XA, ...(typeof t == 'boolean' ? {} : t) }
  }
  function GA(t, e, s) {
    let i = s ? (0, Ln.stringify)(s) : (0, Ln.stringify)(t.$state),
      r = (0, Ln.parse)(i)
    return (
      e.omit.length &&
        e.omit.forEach((n) => {
          delete r[n]
        }),
      (0, Ln.stringify)(r)
    )
  }
  function WA(t, e) {
    let {
      persistent: s,
      persistentStrategy: { set: i },
      done: r,
      undone: n,
    } = e
    s && (i(t, 'undo', r), i(t, 'redo', n))
  }
  function Q5(t, e) {
    var a, o
    let {
      persistent: s,
      persistentStrategy: { get: i, set: r, remove: n },
    } = e
    s
      ? (e.done.length === 0
          ? (e.done = (a = i(t, 'undo')) != null ? a : [])
          : r(t, 'undo', e.done),
        e.undone.length === 0
          ? (e.undone = (o = i(t, 'redo')) != null ? o : [])
          : r(t, 'redo', e.undone))
      : (n(t, 'undo'), n(t, 'redo'))
  }
  function zA(t, e, s) {
    let i = s === 'undo' ? 'canUndo' : 'canRedo'
    return () => {
      if (t[i]) {
        let { undone: r, done: n, max: a, current: o } = e,
          u = s === 'undo' ? n : r,
          l = s === 'undo' ? r : n,
          c = u.pop()
        if (c === void 0) return
        l.length >= a && l.splice(0, 1),
          l.push(o),
          (e.preventUpdateOnSubscribe = !1),
          t.$patch(Object.assign({}, t.$state, (0, Ln.parse)(c))),
          (e.preventUpdateOnSubscribe = !0),
          WA(t, e)
      }
    }
  }
  function Z5(t, e) {
    return (s, i) => {
      let { preventUpdateOnSubscribe: r, max: n, done: a, current: o } = e
      r &&
        (a.length >= n && a.splice(0, 1), a.push(o), (e.undone = []), WA(t, e)),
        (e.current = GA(t, e, i))
    }
  }
  function jf(t, e) {
    return `pinia-plugin-history-${t.$id}-${e}`
  }
  var eD = ({ options: t, store: e }) => {
    let { history: s } = t
    if (s) {
      let { max: i, omit: r, persistent: n, persistentStrategy: a } = Y5(s),
        o = e,
        u = (0, Ki.reactive)({
          max: i,
          omit: r,
          persistent: n,
          persistentStrategy: a,
          done: [],
          undone: [],
          current: '',
          preventUpdateOnSubscribe: !0,
          resetUndone: !1,
        })
      ;(u.current = GA(o, u)),
        (e.canUndo = (0, Ki.computed)(() => u.done.length > 0)),
        (e.canRedo = (0, Ki.computed)(() => u.undone.length > 0)),
        (e.undo = zA(o, u, 'undo')),
        (e.redo = zA(o, u, 'redo')),
        e.$subscribe(Z5(o, u)),
        Q5(o, u)
    }
  }
  return tD
})()
/*! #__NO_SIDE_EFFECTS__ */
/**
 * @vue/compiler-core v3.4.34
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/**
 * @vue/compiler-dom v3.4.34
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/**
 * @vue/reactivity v3.4.34
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/**
 * @vue/runtime-core v3.4.34
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/**
 * @vue/runtime-dom v3.4.34
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/**
 * @vue/shared v3.4.34
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/**
 * vue v3.4.34
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
